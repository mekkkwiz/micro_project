CCS PCM C Compiler, Version 5.074, 32906               11-มี.ค.-21 17:52

               Filename:   D:\WORK\em_lab\micro_project\main_module.lst

               ROM used:   1956 words (24%)
                           Largest free fragment is 2048
               RAM used:   168 (46%) at main() level
                           187 (51%) worst case
               Stack used: 1 locations (0 in main + 1 for interrupts)
               Stack size: 8

*
0000:  MOVLW  03
0001:  MOVWF  0A
0002:  GOTO   3C5
0003:  NOP
0004:  MOVWF  7F
0005:  SWAPF  03,W
0006:  CLRF   03
0007:  MOVWF  21
0008:  MOVF   0A,W
0009:  MOVWF  20
000A:  CLRF   0A
000B:  MOVF   04,W
000C:  MOVWF  22
000D:  MOVF   77,W
000E:  MOVWF  23
000F:  MOVF   78,W
0010:  MOVWF  24
0011:  MOVF   79,W
0012:  MOVWF  25
0013:  MOVF   7A,W
0014:  MOVWF  26
0015:  BSF    03.6
0016:  MOVF   0D,W
0017:  BCF    03.6
0018:  MOVWF  27
0019:  BSF    03.6
001A:  MOVF   0F,W
001B:  BCF    03.6
001C:  MOVWF  28
001D:  BSF    03.6
001E:  MOVF   0C,W
001F:  BCF    03.6
0020:  MOVWF  29
0021:  BSF    03.6
0022:  MOVF   0E,W
0023:  BCF    03.6
0024:  MOVWF  2A
0025:  BCF    03.7
0026:  BCF    03.5
0027:  MOVLW  8C
0028:  MOVWF  04
0029:  BTFSS  00.0
002A:  GOTO   02D
002B:  BTFSC  0C.0
002C:  GOTO   04E
002D:  MOVF   22,W
002E:  MOVWF  04
002F:  MOVF   23,W
0030:  MOVWF  77
0031:  MOVF   24,W
0032:  MOVWF  78
0033:  MOVF   25,W
0034:  MOVWF  79
0035:  MOVF   26,W
0036:  MOVWF  7A
0037:  MOVF   27,W
0038:  BSF    03.6
0039:  MOVWF  0D
003A:  BCF    03.6
003B:  MOVF   28,W
003C:  BSF    03.6
003D:  MOVWF  0F
003E:  BCF    03.6
003F:  MOVF   29,W
0040:  BSF    03.6
0041:  MOVWF  0C
0042:  BCF    03.6
0043:  MOVF   2A,W
0044:  BSF    03.6
0045:  MOVWF  0E
0046:  BCF    03.6
0047:  MOVF   20,W
0048:  MOVWF  0A
0049:  SWAPF  21,W
004A:  MOVWF  03
004B:  SWAPF  7F,F
004C:  SWAPF  7F,W
004D:  RETFIE
004E:  BCF    0A.3
004F:  BCF    0A.4
0050:  GOTO   08F
.................... #include <16F886.h> 
.................... //////////// Standard Header file for the PIC16F886 device //////////////// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996, 2014 Custom Computer Services          //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... #device PIC16F886 
0051:  BCF    0A.0
0052:  BCF    0A.1
0053:  BCF    0A.2
0054:  ADDWF  02,F
0055:  RETLW  46
0056:  RETLW  52
0057:  RETLW  51
0058:  RETLW  5F
0059:  RETLW  52
005A:  RETLW  45
005B:  RETLW  53
005C:  RETLW  45
005D:  RETLW  54
005E:  RETLW  00
005F:  BCF    0A.0
0060:  BCF    0A.1
0061:  BCF    0A.2
0062:  ADDWF  02,F
0063:  RETLW  43
0064:  RETLW  55
0065:  RETLW  52
0066:  RETLW  52
0067:  RETLW  45
0068:  RETLW  4E
0069:  RETLW  54
006A:  RETLW  5F
006B:  RETLW  46
006C:  RETLW  45
006D:  RETLW  51
006E:  RETLW  00
006F:  BCF    0A.0
0070:  BCF    0A.1
0071:  BCF    0A.2
0072:  ADDWF  02,F
0073:  RETLW  42
0074:  RETLW  54
0075:  RETLW  31
0076:  RETLW  5F
0077:  RETLW  46
0078:  RETLW  45
0079:  RETLW  51
007A:  RETLW  5F
007B:  RETLW  53
007C:  RETLW  45
007D:  RETLW  54
007E:  RETLW  00
007F:  BCF    0A.0
0080:  BCF    0A.1
0081:  BCF    0A.2
0082:  ADDWF  02,F
0083:  RETLW  42
0084:  RETLW  54
0085:  RETLW  32
0086:  RETLW  5F
0087:  RETLW  46
0088:  RETLW  45
0089:  RETLW  51
008A:  RETLW  5F
008B:  RETLW  53
008C:  RETLW  45
008D:  RETLW  54
008E:  RETLW  00
*
009D:  DATA 48,3D
009E:  DATA 00,00
009F:  DATA 31,10
00A0:  DATA 70,39
00A1:  DATA E5,39
00A2:  DATA F3,32
00A3:  DATA 64,05
00A4:  DATA 00,00
00A5:  DATA 32,10
00A6:  DATA 70,39
00A7:  DATA E5,39
00A8:  DATA F3,32
00A9:  DATA 64,05
00AA:  DATA 00,01
00AB:  DATA 48,3D
00AC:  DATA 00,01
00AD:  RETLW  74
00AE:  RETLW  72
00AF:  RETLW  75
00B0:  RETLW  65
00B1:  RETLW  00
00B2:  RETLW  66
00B3:  RETLW  61
00B4:  RETLW  6C
00B5:  RETLW  73
00B6:  RETLW  65
00B7:  RETLW  00
00B8:  DATA 31,10
00B9:  DATA 70,39
00BA:  DATA E5,39
00BB:  DATA F3,32
00BC:  DATA 64,05
00BD:  DATA 00,01
00BE:  DATA 32,10
00BF:  DATA 70,39
00C0:  DATA E5,39
00C1:  DATA F3,32
00C2:  DATA 64,05
00C3:  DATA 00,01
00C4:  DATA 33,10
00C5:  DATA 70,39
00C6:  DATA E5,39
00C7:  DATA F3,32
00C8:  DATA 64,05
00C9:  DATA 00,01
00CA:  DATA 34,10
00CB:  DATA 70,39
00CC:  DATA E5,39
00CD:  DATA F3,32
00CE:  DATA 64,05
00CF:  DATA 00,01
00D0:  DATA 35,10
00D1:  DATA 70,39
00D2:  DATA E5,39
00D3:  DATA F3,32
00D4:  DATA 64,05
00D5:  DATA 00,01
00D6:  DATA 36,10
00D7:  DATA 70,39
00D8:  DATA E5,39
00D9:  DATA F3,32
00DA:  DATA 64,05
00DB:  DATA 00,00
*
01A5:  MOVF   0B,W
01A6:  BSF    03.6
01A7:  MOVWF  19
01A8:  BCF    03.6
01A9:  BCF    0B.7
01AA:  BSF    03.5
01AB:  BSF    03.6
01AC:  BSF    0C.7
01AD:  BSF    0C.0
01AE:  NOP
01AF:  NOP
01B0:  BCF    03.5
01B1:  BTFSS  19.7
01B2:  GOTO   1B6
01B3:  BCF    03.6
01B4:  BSF    0B.7
01B5:  BSF    03.6
01B6:  MOVF   0C,W
01B7:  ANDLW  7F
01B8:  BTFSC  03.2
01B9:  GOTO   1F5
01BA:  MOVWF  19
01BB:  MOVF   0D,W
01BC:  MOVWF  1A
01BD:  MOVF   0F,W
01BE:  MOVWF  1B
01BF:  MOVF   19,W
01C0:  BCF    03.6
01C1:  BTFSS  0C.4
01C2:  GOTO   1C1
01C3:  MOVWF  19
01C4:  BSF    03.6
01C5:  MOVF   1A,W
01C6:  MOVWF  0D
01C7:  MOVF   1B,W
01C8:  MOVWF  0F
01C9:  BCF    03.6
01CA:  MOVF   0B,W
01CB:  BSF    03.6
01CC:  MOVWF  1C
01CD:  BCF    03.6
01CE:  BCF    0B.7
01CF:  BSF    03.5
01D0:  BSF    03.6
01D1:  BSF    0C.7
01D2:  BSF    0C.0
01D3:  NOP
01D4:  NOP
01D5:  BCF    03.5
01D6:  BTFSS  1C.7
01D7:  GOTO   1DB
01D8:  BCF    03.6
01D9:  BSF    0B.7
01DA:  BSF    03.6
01DB:  RLF    0C,W
01DC:  RLF    0E,W
01DD:  ANDLW  7F
01DE:  BTFSC  03.2
01DF:  GOTO   1F5
01E0:  MOVWF  19
01E1:  MOVF   0D,W
01E2:  MOVWF  1A
01E3:  MOVF   0F,W
01E4:  MOVWF  1B
01E5:  MOVF   19,W
01E6:  BCF    03.6
01E7:  BTFSS  0C.4
01E8:  GOTO   1E7
01E9:  MOVWF  19
01EA:  BSF    03.6
01EB:  MOVF   1A,W
01EC:  MOVWF  0D
01ED:  MOVF   1B,W
01EE:  MOVWF  0F
01EF:  INCF   0D,F
01F0:  BTFSC  03.2
01F1:  INCF   0F,F
01F2:  BCF    03.6
01F3:  GOTO   1A5
01F4:  BSF    03.6
01F5:  BCF    03.6
01F6:  RETURN
*
0245:  BSF    03.6
0246:  CLRF   23
0247:  MOVF   04,W
0248:  MOVWF  22
0249:  BCF    23.0
024A:  BTFSC  03.7
024B:  BSF    23.0
024C:  SWAPF  1C,W
024D:  IORLW  F0
024E:  MOVWF  1E
024F:  ADDWF  1E,F
0250:  ADDLW  E2
0251:  MOVWF  1F
0252:  ADDLW  32
0253:  MOVWF  21
0254:  MOVF   1C,W
0255:  ANDLW  0F
0256:  ADDWF  1F,F
0257:  ADDWF  1F,F
0258:  ADDWF  21,F
0259:  ADDLW  E9
025A:  MOVWF  20
025B:  ADDWF  20,F
025C:  ADDWF  20,F
025D:  SWAPF  1B,W
025E:  ANDLW  0F
025F:  ADDWF  20,F
0260:  ADDWF  21,F
0261:  RLF    20,F
0262:  RLF    21,F
0263:  COMF   21,F
0264:  RLF    21,F
0265:  MOVF   1B,W
0266:  ANDLW  0F
0267:  ADDWF  21,F
0268:  RLF    1E,F
0269:  MOVLW  07
026A:  MOVWF  1D
026B:  MOVLW  0A
026C:  ADDWF  21,F
026D:  DECF   20,F
026E:  BTFSS  03.0
026F:  GOTO   26C
0270:  ADDWF  20,F
0271:  DECF   1F,F
0272:  BTFSS  03.0
0273:  GOTO   270
0274:  ADDWF  1F,F
0275:  DECF   1E,F
0276:  BTFSS  03.0
0277:  GOTO   274
0278:  ADDWF  1E,F
0279:  DECF   1D,F
027A:  BTFSS  03.0
027B:  GOTO   278
027C:  MOVLW  1D
027D:  MOVWF  04
027E:  BSF    03.7
027F:  MOVLW  07
0280:  ANDWF  22,W
0281:  BCF    22.6
0282:  ADDWF  04,F
0283:  MOVLW  21
0284:  SUBWF  04,W
0285:  BTFSC  03.2
0286:  BSF    22.6
0287:  MOVF   00,W
0288:  MOVWF  77
0289:  BTFSS  03.2
028A:  GOTO   293
028B:  BTFSC  22.6
028C:  GOTO   293
028D:  BTFSC  22.4
028E:  GOTO   2A7
028F:  BTFSC  22.3
0290:  GOTO   293
0291:  MOVLW  20
0292:  GOTO   296
0293:  BSF    22.3
0294:  BCF    22.4
0295:  MOVLW  30
0296:  ADDWF  77,F
0297:  CLRF   1C
0298:  MOVF   04,W
0299:  MOVWF  1B
029A:  BCF    1C.0
029B:  BTFSC  03.7
029C:  BSF    1C.0
029D:  MOVF   77,W
029E:  MOVWF  24
029F:  BCF    03.6
02A0:  CALL   20B
02A1:  BSF    03.6
02A2:  MOVF   1B,W
02A3:  MOVWF  04
02A4:  BCF    03.7
02A5:  BTFSC  1C.0
02A6:  BSF    03.7
02A7:  INCF   04,F
02A8:  BTFSS  22.6
02A9:  GOTO   283
02AA:  BCF    03.6
02AB:  RETURN
02AC:  MOVF   0B,W
02AD:  BSF    03.6
02AE:  MOVWF  1B
02AF:  BCF    03.6
02B0:  BCF    0B.7
02B1:  BSF    03.5
02B2:  BSF    03.6
02B3:  BSF    0C.7
02B4:  BSF    0C.0
02B5:  NOP
02B6:  NOP
02B7:  BCF    03.5
02B8:  BTFSS  1B.7
02B9:  GOTO   2BD
02BA:  BCF    03.6
02BB:  BSF    0B.7
02BC:  BSF    03.6
02BD:  MOVF   0C,W
02BE:  ANDLW  7F
02BF:  BTFSC  03.2
02C0:  GOTO   2FA
02C1:  MOVWF  1B
02C2:  MOVF   0D,W
02C3:  MOVWF  1C
02C4:  MOVF   0F,W
02C5:  MOVWF  1D
02C6:  MOVF   1B,W
02C7:  MOVWF  24
02C8:  BCF    03.6
02C9:  CALL   20B
02CA:  BSF    03.6
02CB:  MOVF   1C,W
02CC:  MOVWF  0D
02CD:  MOVF   1D,W
02CE:  MOVWF  0F
02CF:  BCF    03.6
02D0:  MOVF   0B,W
02D1:  BSF    03.6
02D2:  MOVWF  1E
02D3:  BCF    03.6
02D4:  BCF    0B.7
02D5:  BSF    03.5
02D6:  BSF    03.6
02D7:  BSF    0C.7
02D8:  BSF    0C.0
02D9:  NOP
02DA:  NOP
02DB:  BCF    03.5
02DC:  BTFSS  1E.7
02DD:  GOTO   2E1
02DE:  BCF    03.6
02DF:  BSF    0B.7
02E0:  BSF    03.6
02E1:  RLF    0C,W
02E2:  RLF    0E,W
02E3:  ANDLW  7F
02E4:  BTFSC  03.2
02E5:  GOTO   2FA
02E6:  MOVWF  1B
02E7:  MOVF   0D,W
02E8:  MOVWF  1C
02E9:  MOVF   0F,W
02EA:  MOVWF  1D
02EB:  MOVF   1B,W
02EC:  MOVWF  24
02ED:  BCF    03.6
02EE:  CALL   20B
02EF:  BSF    03.6
02F0:  MOVF   1C,W
02F1:  MOVWF  0D
02F2:  MOVF   1D,W
02F3:  MOVWF  0F
02F4:  INCF   0D,F
02F5:  BTFSC  03.2
02F6:  INCF   0F,F
02F7:  BCF    03.6
02F8:  GOTO   2AC
02F9:  BSF    03.6
02FA:  BCF    03.6
02FB:  RETURN
02FC:  MOVF   00,F
02FD:  BTFSC  03.2
02FE:  GOTO   319
02FF:  BSF    03.6
0300:  CLRF   1B
0301:  MOVF   04,W
0302:  MOVWF  1A
0303:  BCF    1B.0
0304:  BTFSC  03.7
0305:  BSF    1B.0
0306:  MOVF   00,W
0307:  BCF    03.6
0308:  BTFSS  0C.4
0309:  GOTO   308
030A:  MOVWF  19
030B:  BSF    03.6
030C:  MOVF   1A,W
030D:  MOVWF  04
030E:  BCF    03.7
030F:  BTFSC  1B.0
0310:  BSF    03.7
0311:  INCF   04,F
0312:  BTFSS  03.2
0313:  GOTO   317
0314:  BCF    03.6
0315:  INCF   05,F
0316:  BSF    03.6
0317:  BCF    03.6
0318:  GOTO   2FC
0319:  BCF    0A.3
031A:  BCF    0A.4
031B:  GOTO   600 (RETURN)
*
0337:  BTFSC  03.1
0338:  GOTO   33C
0339:  MOVLW  25
033A:  MOVWF  04
033B:  BSF    03.7
033C:  CLRF   77
033D:  CLRF   78
033E:  CLRF   79
033F:  CLRF   7A
0340:  CLRF   25
0341:  CLRF   26
0342:  CLRF   27
0343:  CLRF   28
0344:  MOVF   24,W
0345:  IORWF  23,W
0346:  IORWF  22,W
0347:  IORWF  21,W
0348:  BTFSC  03.2
0349:  GOTO   37A
034A:  MOVLW  20
034B:  MOVWF  29
034C:  BCF    03.0
034D:  RLF    1D,F
034E:  RLF    1E,F
034F:  RLF    1F,F
0350:  RLF    20,F
0351:  RLF    25,F
0352:  RLF    26,F
0353:  RLF    27,F
0354:  RLF    28,F
0355:  MOVF   24,W
0356:  SUBWF  28,W
0357:  BTFSS  03.2
0358:  GOTO   363
0359:  MOVF   23,W
035A:  SUBWF  27,W
035B:  BTFSS  03.2
035C:  GOTO   363
035D:  MOVF   22,W
035E:  SUBWF  26,W
035F:  BTFSS  03.2
0360:  GOTO   363
0361:  MOVF   21,W
0362:  SUBWF  25,W
0363:  BTFSS  03.0
0364:  GOTO   374
0365:  MOVF   21,W
0366:  SUBWF  25,F
0367:  MOVF   22,W
0368:  BTFSS  03.0
0369:  INCFSZ 22,W
036A:  SUBWF  26,F
036B:  MOVF   23,W
036C:  BTFSS  03.0
036D:  INCFSZ 23,W
036E:  SUBWF  27,F
036F:  MOVF   24,W
0370:  BTFSS  03.0
0371:  INCFSZ 24,W
0372:  SUBWF  28,F
0373:  BSF    03.0
0374:  RLF    77,F
0375:  RLF    78,F
0376:  RLF    79,F
0377:  RLF    7A,F
0378:  DECFSZ 29,F
0379:  GOTO   34C
037A:  MOVF   25,W
037B:  MOVWF  00
037C:  INCF   04,F
037D:  MOVF   26,W
037E:  MOVWF  00
037F:  INCF   04,F
0380:  MOVF   27,W
0381:  MOVWF  00
0382:  INCF   04,F
0383:  MOVF   28,W
0384:  MOVWF  00
*
079A:  BSF    0A.0
079B:  BSF    0A.1
079C:  BSF    0A.2
079D:  ADDWF  02,F
079E:  GOTO   60D
079F:  GOTO   620
07A0:  GOTO   633
07A1:  GOTO   648
07A2:  GOTO   65D
07A3:  GOTO   672
....................  
.................... #list 
....................  
.................... #device ADC=10 *=16 
....................  
.................... #FUSES NOWDT                    //No Watch Dog Timer 
.................... #FUSES PUT                      //Power Up Timer 
.................... #FUSES NOMCLR                   //Master Clear pin not enabled 
.................... #FUSES NOPROTECT                //Code not protected from reading 
.................... #FUSES NOCPD                    //No EE protection 
.................... #FUSES BROWNOUT                 //Brownout reset 
.................... #FUSES IESO                     //Internal External Switch Over mode enabled 
.................... #FUSES FCMEN                    //Fail-safe clock monitor enabled 
.................... #FUSES NOLVP                    //No low voltage prgming, B3(PIC16) or B5(PIC18) used for I/O 
.................... #FUSES NODEBUG                  //No Debug mode for ICD 
.................... #FUSES NOWRT                    //Program memory not write protected 
.................... #FUSES BORV40                   //Brownout reset at 4.0V 
.................... #FUSES RESERVED                 //Used to set the reserved FUSE bits 
.................... #FUSES INTRC_IO  
....................  
.................... #use delay(clock=8M) 
*
00DC:  MOVLW  25
00DD:  MOVWF  04
00DE:  BSF    03.7
00DF:  MOVF   00,W
00E0:  BTFSC  03.2
00E1:  GOTO   0EF
00E2:  MOVLW  02
00E3:  MOVWF  78
00E4:  CLRF   77
00E5:  DECFSZ 77,F
00E6:  GOTO   0E5
00E7:  DECFSZ 78,F
00E8:  GOTO   0E4
00E9:  MOVLW  97
00EA:  MOVWF  77
00EB:  DECFSZ 77,F
00EC:  GOTO   0EB
00ED:  DECFSZ 00,F
00EE:  GOTO   0E2
00EF:  RETURN
....................  
.................... #use rs232(baud=9600,parity=N,xmit=PIN_C6,rcv=PIN_C7,bits=8) 
....................  
.................... #define RUN_BUTTON   PIN_B7 
.................... #define _FLEX_LCD216_H  //  LCD Type 16x2 
.................... //#define _FLEX_LCD416_H  //  LCD Type 16x4 
.................... // Assign MCU's pin to LCD 
.................... #define LCD_DB4   PIN_A0 
.................... #define LCD_DB5   PIN_A1 
.................... #define LCD_DB6   PIN_A2 
.................... #define LCD_DB7   PIN_A3 
.................... #define LCD_RS    PIN_C1 
.................... #define LCD_E     PIN_A5 
....................  
.................... #include <stdio.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDIO 
.................... #define _STDIO 
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) || defined(__PCM__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *memmove(void *s1,void *s2,size_t n) 
.................... { 
....................    unsigned char *sc1; 
....................    unsigned char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *strncpy(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................   unsigned char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... unsigned char *strcat(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... unsigned char *strncat(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,void *s2,size_t n) 
.................... { 
.................... unsigned char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1, returns number of chars written ot s1. 
....................    if s1 is NULL and n is 0, then it returns the length of s2.*/ 
.................... size_t strxfrm(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char c; 
....................    unsigned int8 n1; 
....................     
....................    if (!s1 && !n) 
....................       n = -1; //find length 
....................  
....................    n1 = 0; 
....................     
....................    for (; n1 < n; n1++) 
....................    { 
....................       c = *s2++; 
....................       if (!c) 
....................          break; 
....................       if (s1) 
....................          *s1++ = c; 
....................    } 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... unsigned char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    unsigned char uc; 
....................    unsigned char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... unsigned char *strchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... unsigned char *strpbrk(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... unsigned char *strrchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... unsigned char *strstr(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... size_t strlen(unsigned char *s) 
.................... { 
....................    unsigned char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... unsigned char *strtok(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *beg, *end; 
....................    static char *save; 
*
03EF:  BCF    03.6
03F0:  CLRF   2B
03F1:  CLRF   2C
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................       return(0); 
....................        
....................    end = strpbrk(beg, s2); 
....................    if (end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................       save = end; 
....................    } 
....................    else 
....................       save = beg + strlen(beg); 
....................     
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... unsigned char * strerror(unsigned int8 errnum) 
.................... { 
.................... static unsigned char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strlwr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strupr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
.................... #ifndef getc 
.................... #define getc getch 
.................... #define getchar getch 
.................... #define puts(s) {printf(s); putchar(13); putchar(10);} 
.................... #define putc putchar 
.................... #endif 
.................... /* maps error number to an error message. Writes a sequence of characters to 
.................... stderr stream thus: if s is not null then string pointed to by s follwed by 
.................... a colon (:) and a space and the appropriate error message returned by strerror 
.................... function with argument errno 
....................  
.................... Returns: no value 
.................... */ 
....................  
.................... #ifdef _ERRNO 
.................... void perror(char *s) 
.................... { 
....................   if(s) 
....................   fprintf(STDERR,"%s: ",s); 
....................   fprintf(STDERR,"%s\r\n",strerror(errno)); 
.................... } 
.................... #endif 
.................... #endif 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... #include <ctype.h> 
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *memmove(void *s1,void *s2,size_t n) 
.................... { 
....................    unsigned char *sc1; 
....................    unsigned char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *strncpy(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................   unsigned char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... unsigned char *strcat(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... unsigned char *strncat(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,void *s2,size_t n) 
.................... { 
.................... unsigned char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1, returns number of chars written ot s1. 
....................    if s1 is NULL and n is 0, then it returns the length of s2.*/ 
.................... size_t strxfrm(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char c; 
....................    unsigned int8 n1; 
....................     
....................    if (!s1 && !n) 
....................       n = -1; //find length 
....................  
....................    n1 = 0; 
....................     
....................    for (; n1 < n; n1++) 
....................    { 
....................       c = *s2++; 
....................       if (!c) 
....................          break; 
....................       if (s1) 
....................          *s1++ = c; 
....................    } 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... unsigned char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    unsigned char uc; 
....................    unsigned char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... unsigned char *strchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... unsigned char *strpbrk(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... unsigned char *strrchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... unsigned char *strstr(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... size_t strlen(unsigned char *s) 
.................... { 
....................    unsigned char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... unsigned char *strtok(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................       return(0); 
....................        
....................    end = strpbrk(beg, s2); 
....................    if (end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................       save = end; 
....................    } 
....................    else 
....................       save = beg + strlen(beg); 
....................     
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... unsigned char * strerror(unsigned int8 errnum) 
.................... { 
.................... static unsigned char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strlwr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strupr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
.................... #include <stdlib.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2007 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
....................  
.................... #ifndef _STDLIB 
.................... #define _STDLIB 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Definitions and types 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #ifndef RAND_MAX 
.................... #define RAND_MAX  32767    // The value of which is the maximum value 
....................                            // ... returned by the rand function 
.................... #endif 
....................  
....................  
.................... #IF (sizeof(int16*)>1) 
.................... #DEFINE LONG_POINTERS 1 
.................... #ELSE  
.................... #DEFINE LONG_POINTERS 0 
.................... #ENDIF 
....................  
.................... typedef struct { 
....................    signed int quot; 
....................    signed int rem; 
.................... } div_t; 
....................  
.................... typedef struct { 
....................    signed long quot; 
....................    signed long rem; 
.................... } ldiv_t; 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) || defined(__PCM__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // String conversion functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Standard template: signed int  atoi(char * s) 
....................  * converts the initial portion of the string s to a signed int 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed int atoi(char *s); 
....................  
.................... /* Syntax: signed int32  atoi32(char * s) 
....................    converts the initial portion of the string s to a signed int32 
....................    returns the converted value if any, 0 otherwise*/ 
.................... #if (sizeof(long)==4) 
....................  #define atoi32(s) atol(s) 
.................... #else  
....................  signed int32 atoi32(char *s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
.................... /* Syntax: signed int48  atoi48(char * s) 
....................    converts the initial portion of the string s to a signed int48 
....................    returns the converted value if any, 0 otherwise*/ 
....................     
.................... signed int48 atoi48(char *s); 
....................  
.................... /* Syntax: signed int64  atoi64(char * s) 
....................    converts the initial portion of the string s to a signed int64 
....................    returns the converted value if any, 0 otherwise*/ 
.................... signed int64 atoi64(char *s); 
.................... #endif 
....................  
.................... /* Syntax: char *  itoa(signed int32 num, int8 base, char * s) 
....................    converts the signed int32 to a string and 
....................    returns the converted value if any, 0 otherwise*/ 
.................... char * itoa(signed int32 num, unsigned int base, char * s); 
....................  
.................... /* Standard template: signed int16  atol(char * s) 
....................  * converts the initial portion of the string s to a signed int16 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed long atol(char *s); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base  to a signed long. 
....................  * Returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... signed long strtol(char *s,char *endptr, signed int base); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base to a unsigned long. 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... unsigned long strtoul(char *s,char *endptr, signed int base); 
....................  
.................... /* Standart template: float strtof(char * s,char *endptr) 
....................                       float48 strtof48(char *s,char *endptr); 
....................                       float64 strtod(char *s,char *endptr); 
....................  * converts the initial portion of the string s to a float32, float48 or float64, 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null                    
.................... */ 
.................... float strtof(char *s,char **endptr); 
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s,char **endptr); 
.................... float64 strtod(char *s,char **endptr); 
.................... #else 
.................... //provided for compatibility 
.................... #define strtof48(s, e) strtof(s, e) 
.................... #define strtod(s, e) strtof(s, e) 
.................... #endif 
....................  
.................... /* Standard template: float32 atof(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof(s)   strtof(s, (char*)0) 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
....................  
.................... /* Standard template: float48 atof48(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof48(s) strtof48(s, 0) 
....................  
.................... /* Standard template: float64 atof64(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof64(s) strtod(s, 0) 
.................... #endif 
....................  
.................... /* Standard template: float32 atoe(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  * also handles E format numbers 
....................  */ 
.................... #if !defined(__PCD__) 
.................... float atoe(char * s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s); 
.................... #endif 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Pseudo-random sequence generation functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The rand function computes a sequence of pseudo-random integers in 
....................  * the range 0 to RAND_MAX 
....................  * 
....................  * Parameters: 
....................  *       (none) 
....................  * 
....................  * Returns: 
....................  *       The pseudo-random integer 
....................  */ 
.................... unsigned int16 rand(void); 
....................  
.................... /* The srand function uses the argument as a seed for a new sequence of 
....................  * pseudo-random numbers to be returned by subsequent calls to rand. 
....................  * 
....................  * Parameters: 
....................  *       [in] seed: The seed value to start from. You might need to pass 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  * 
....................  * Remarks 
....................  *          The srand function sets the starting point for generating 
....................  *       a series of pseudorandom integers. To reinitialize the 
....................  *       generator, use 1 as the seed argument. Any other value for 
....................  *       seed sets the generator to a random starting point. rand 
....................  *       retrieves the pseudorandom numbers that are generated. 
....................  *       Calling rand before any call to srand generates the same 
....................  *       sequence as calling srand with seed passed as 1. 
....................  *          Usually, you need to pass a time here from outer source 
....................  *       so that the numbers will be different every time you run. 
....................  */ 
.................... void srand(unsigned int32 seed); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Memory management functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Comming soon 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Communication with the environment 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The function returns 0 always 
....................  */ 
.................... signed int8 system(char *string); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Performs a binary search of a sorted array.. 
....................  * 
....................  * Parameters: 
....................  *       [in] key: Object to search for 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       bsearch returns a pointer to an occurrence of key in the array pointed 
....................  *       to by base. If key is not found, the function returns NULL. If the 
....................  *       array is not in order or contains duplicate records with identical keys, 
....................  *       the result is unpredictable. 
....................  */ 
.................... //void *bsearch(const void *key, const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... /* Performs the shell-metzner sort (not the quick sort algorithm). The contents 
....................  * of the array are sorted into ascending order according to a comparison 
....................  * function pointed to by compar. 
....................  * 
....................  * Parameters: 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  */ 
.................... //void *qsort(const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Integer arithmetic functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #define labs abs 
....................  
.................... div_t div(signed int numer, signed int denom); 
.................... ldiv_t ldiv(signed long numer, signed long denom); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte character functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte string functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Internal implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) || defined(__PCM__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... #include <ctype.h> 
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *memmove(void *s1,void *s2,size_t n) 
.................... { 
....................    unsigned char *sc1; 
....................    unsigned char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *strncpy(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................   unsigned char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... unsigned char *strcat(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... unsigned char *strncat(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,void *s2,size_t n) 
.................... { 
.................... unsigned char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1, returns number of chars written ot s1. 
....................    if s1 is NULL and n is 0, then it returns the length of s2.*/ 
.................... size_t strxfrm(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char c; 
....................    unsigned int8 n1; 
....................     
....................    if (!s1 && !n) 
....................       n = -1; //find length 
....................  
....................    n1 = 0; 
....................     
....................    for (; n1 < n; n1++) 
....................    { 
....................       c = *s2++; 
....................       if (!c) 
....................          break; 
....................       if (s1) 
....................          *s1++ = c; 
....................    } 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... unsigned char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    unsigned char uc; 
....................    unsigned char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... unsigned char *strchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... unsigned char *strpbrk(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... unsigned char *strrchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... unsigned char *strstr(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... size_t strlen(unsigned char *s) 
.................... { 
....................    unsigned char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... unsigned char *strtok(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................       return(0); 
....................        
....................    end = strpbrk(beg, s2); 
....................    if (end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................       save = end; 
....................    } 
....................    else 
....................       save = beg + strlen(beg); 
....................     
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... unsigned char * strerror(unsigned int8 errnum) 
.................... { 
.................... static unsigned char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strlwr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strupr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
.................... div_t div(signed int numer, signed int denom) 
.................... { 
....................    div_t val; 
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... ldiv_t ldiv(signed long numer, signed long denom) 
.................... { 
....................    ldiv_t val; 
....................  
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s) 
.................... { 
....................    float32 pow10 = 1.0; 
....................    float32 result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float32 exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if !defined(__PCD__) 
.................... float atoe(char * s) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... signed int atoi(char *s) 
.................... { 
....................    signed int result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    // Omit all preceeding alpha characters 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................  
....................       // Check for hexa number 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c<='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++]; 
....................             c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (sign == 1 && base == 10) 
....................        result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed long atol(char *s) 
.................... { 
....................    signed long result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... /* A fast routine to multiply by 10 
....................  */ 
.................... signed int32 mult_with10(int32 num) 
.................... { 
....................    return ( (num << 1) + (num << 3) ); 
.................... } 
....................  
.................... #if sizeof(long)==2 
.................... signed int32 atoi32(char *s) 
.................... { 
....................    signed int32 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
....................  
.................... signed int48 atoi48(char *s) 
.................... { 
....................    signed int48 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed int64 atoi64(char *s) 
.................... { 
....................    signed int64 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... char * itoa(signed int32 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int32 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #if defined(__PCD__) 
....................  
.................... char * itoa(signed int48 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int48 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... char * itoa(signed int64 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int64 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................       
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1;         
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................              
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #endif 
....................  
.................... float strtof(char *s, char **endptr) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s, char **endptr) 
.................... { 
....................    float48 pow10 = 1.0; 
....................    float48 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float48)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float48)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... float64 strtod(char *s, char **endptr) 
.................... { 
....................    float64 pow10 = 1.0; 
....................    float64 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float64)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float64)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... unsigned long strtoul(char *s, char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    unsigned long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if(sign=='-' || base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtoulGO; 
....................  
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(; sd!=0; ) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtoulGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................          } 
....................    return 0; 
....................    } 
....................    if (endptr) 
....................    { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................          #ELSE 
....................          *((char *)endptr)=sc;  
....................          #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
....................  
.................... signed long strtol(char *s,char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    signed long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if (base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtolGO; 
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................  
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(;sd!=0;) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtolGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................       } 
....................    return 0; 
....................    } 
....................    if(sign=='-') 
....................       x  =-x; 
....................    if (endptr) 
....................    { 
....................         #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................         #ELSE 
....................         *((char *)endptr)=sc; 
....................         #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
.................... signed int8 system(char *string) 
.................... { 
....................    return 0; 
.................... } 
....................  
.................... size_t mblen(char *s,size_t n) 
.................... { 
....................    return strlen(s); 
.................... } 
....................  
.................... int8 mbtowc(wchar_t *pwc,char *s,size_t n) 
.................... { 
....................    *pwc=*s; 
....................    return 1; 
.................... } 
....................  
.................... int8 wctomb(char *s,wchar_t wchar) 
.................... { 
....................    *s=wchar; 
....................    return 1; 
.................... } 
....................  
.................... size_t mbstowcs(wchar_t *pwcs,char *s,size_t n) 
.................... { 
....................    strncpy(pwcs,s,n); 
....................    return strlen(pwcs); 
.................... } 
....................  
.................... size_t wcstombs(char *s,wchar_t *pwcs,size_t n) 
.................... { 
....................    strncpy(s,pwcs,n); 
....................    return strlen(s); 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // The random number implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... unsigned int32 _Randseed; 
....................  
.................... unsigned int16 rand(void) 
.................... { 
....................    _Randseed = _Randseed * 1103515245 + 12345; 
....................    return ((unsigned int16)(_Randseed >> 16) % RAND_MAX); 
.................... } 
....................  
.................... void srand(unsigned int32 seed) 
.................... { 
....................    _Randseed = seed; 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #if !defined(__PCD__) 
.................... typedef signed int8 (*_Cmpfun)(char * p1,char * p2);  
.................... #else  
.................... typedef signed int16 (*_Cmpfun)(char * p1,char * p2);  
.................... #endif 
....................  
....................  
....................  
.................... void qsort(char * qdata, unsigned int qitems, unsigned int qsize, _Cmpfun cmp) { 
....................    unsigned int m,j,i,l; 
....................    int1 done; 
....................    unsigned int8 t[16]; 
....................  
....................    m = qitems/2; 
....................    while( m > 0 ) { 
....................      for(j=0; j<(qitems-m); ++j) { 
....................         i = j; 
....................         do 
....................         { 
....................            done=1; 
....................            l = i+m; 
....................            if( (*cmp)(qdata+i*qsize, qdata+l*qsize) > 0 ) { 
....................               memcpy(t, qdata+i*qsize, qsize); 
....................               memcpy(qdata+i*qsize, qdata+l*qsize, qsize); 
....................               memcpy(qdata+l*qsize, t, qsize); 
....................               if(m <= i) 
....................                 i -= m; 
....................                 done = 0; 
....................            } 
....................         } while(!done); 
....................      } 
....................      m = m/2; 
....................    } 
.................... } 
....................  
....................  
.................... char *bsearch(char *key, char *base, size_t num, size_t width,_Cmpfun cmp) 
.................... { 
....................    char *p, *q; 
....................    size_t n; 
....................    size_t pivot; 
....................    signed int val; 
....................  
....................    p = base; 
....................    n = num; 
....................  
....................    while (n > 0) 
....................    { 
....................       pivot = n >> 1; 
....................       q = p + width * pivot; 
....................  
....................       val = (*cmp)(key, q); 
....................  
....................       if (val < 0) 
....................          n = pivot; 
....................       else if (val == 0) 
....................          return ((char *)q); 
....................       else { 
....................          p = q + width; 
....................          n -= pivot + 1; 
....................       } 
....................    } 
....................  
....................    return NULL;      // There's no match 
.................... } 
....................  
....................  
.................... #endif 
....................  
.................... #include <lcd.c> 
.................... /////////////////////////////////////////////////////////////////////////////// 
.................... ////                             LCD.C                                     //// 
.................... ////                 Driver for common LCD modules                         //// 
.................... ////                                                                       //// 
.................... ////  lcd_init()   Must be called before any other function.               //// 
.................... ////                                                                       //// 
.................... ////  lcd_putc(c)  Will display c on the next position of the LCD.         //// 
.................... ////                 \a  Set cursor position to upper left                 //// 
.................... ////                 \f  Clear display, set cursor to upper left           //// 
.................... ////                 \n  Go to start of second line                        //// 
.................... ////                 \b  Move back one position                            //// 
.................... ////              If LCD_EXTENDED_NEWLINE is defined, the \n character     //// 
.................... ////              will erase all remanining characters on the current      //// 
.................... ////              line, and move the cursor to the beginning of the next   //// 
.................... ////              line.                                                    //// 
.................... ////              If LCD_EXTENDED_NEWLINE is defined, the \r character     //// 
.................... ////              will move the cursor to the start of the current         //// 
.................... ////              line.                                                    //// 
.................... ////                                                                       //// 
.................... ////  lcd_gotoxy(x,y) Set write position on LCD (upper left is 1,1)        //// 
.................... ////                                                                       //// 
.................... ////  lcd_getc(x,y)   Returns character at position x,y on LCD             //// 
.................... ////                                                                       //// 
.................... ////  lcd_cursor_on(int1 on)   Turn the cursor on (on=TRUE) or off         //// 
.................... ////              (on=FALSE).                                              //// 
.................... ////                                                                       //// 
.................... ////  lcd_set_cgram_char(w, *p)   Write a custom character to the CGRAM.   //// 
.................... ////                                                                       //// 
.................... ////                                                                       //// 
.................... ////  CONFIGURATION                                                        //// 
.................... ////  The LCD can be configured in one of two ways: a.) port access or     //// 
.................... ////  b.) pin access.  Port access requires the entire 7 bit interface     //// 
.................... ////  connected to one GPIO port, and the data bits (D4:D7 of the LCD)     //// 
.................... ////  connected to sequential pins on the GPIO.  Pin access                //// 
.................... ////  has no requirements, all 7 bits of the control interface can         //// 
.................... ////  can be connected to any GPIO using several ports.                    //// 
.................... ////                                                                       //// 
.................... ////  To use port access, #define LCD_DATA_PORT to the SFR location of     //// 
.................... ////  of the GPIO port that holds the interface, -AND- edit LCD_PIN_MAP    //// 
.................... ////  of this file to configure the pin order.  If you are using a         //// 
.................... ////  baseline PIC (PCB), then LCD_OUTPUT_MAP and LCD_INPUT_MAP also must  //// 
.................... ////  be defined.                                                          //// 
.................... ////                                                                       //// 
.................... ////  Example of port access:                                              //// 
.................... ////     #define LCD_DATA_PORT getenv("SFR:PORTD")                         //// 
.................... ////                                                                       //// 
.................... ////  To use pin access, the following pins must be defined:               //// 
.................... ////     LCD_ENABLE_PIN                                                    //// 
.................... ////     LCD_RS_PIN                                                        //// 
.................... ////     LCD_RW_PIN                                                        //// 
.................... ////     LCD_DATA4                                                         //// 
.................... ////     LCD_DATA5                                                         //// 
.................... ////     LCD_DATA6                                                         //// 
.................... ////     LCD_DATA7                                                         //// 
.................... ////                                                                       //// 
.................... ////  Example of pin access:                                               //// 
.................... ////     #define LCD_ENABLE_PIN  PIN_E0                                    //// 
.................... ////     #define LCD_RS_PIN      PIN_E1                                    //// 
.................... ////     #define LCD_RW_PIN      PIN_E2                                    //// 
.................... ////     #define LCD_DATA4       PIN_D4                                    //// 
.................... ////     #define LCD_DATA5       PIN_D5                                    //// 
.................... ////     #define LCD_DATA6       PIN_D6                                    //// 
.................... ////     #define LCD_DATA7       PIN_D7                                    //// 
.................... ////                                                                       //// 
.................... /////////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2010 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef __LCD_C__ 
.................... #define __LCD_C__ 
....................  
.................... // define the pinout. 
.................... // only required if port access is being used. 
.................... typedef struct   
.................... {                            // This structure is overlayed 
....................    int1 enable;           // on to an I/O port to gain 
....................    int1 rs;               // access to the LCD pins. 
....................    int1 rw;               // The bits are allocated from 
....................    int1 unused;           // low order up.  ENABLE will 
....................    unsigned int     data : 4;         // be LSB pin of that port. 
....................   #if defined(__PCD__)       // The port used will be LCD_DATA_PORT. 
....................    unsigned int    reserved: 8; 
....................   #endif 
.................... } LCD_PIN_MAP; 
....................  
.................... // this is to improve compatability with previous LCD drivers that accepted 
.................... // a define labeled 'use_portb_lcd' that configured the LCD onto port B. 
.................... #if ((defined(use_portb_lcd)) && (use_portb_lcd==TRUE)) 
....................  #define LCD_DATA_PORT getenv("SFR:PORTB") 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
....................    // these definitions only need to be modified for baseline PICs. 
....................    // all other PICs use LCD_PIN_MAP or individual LCD_xxx pin definitions. 
.................... /*                                    EN, RS,   RW,   UNUSED,  DATA  */ 
....................  const LCD_PIN_MAP LCD_OUTPUT_MAP =  {0,  0,    0,    0,       0}; 
....................  const LCD_PIN_MAP LCD_INPUT_MAP =   {0,  0,    0,    0,       0xF}; 
.................... #endif 
....................  
.................... ////////////////////// END CONFIGURATION /////////////////////////////////// 
....................  
.................... #ifndef LCD_ENABLE_PIN 
....................    #define lcd_output_enable(x) lcdlat.enable=x 
....................    #define lcd_enable_tris()   lcdtris.enable=0 
.................... #else 
....................    #define lcd_output_enable(x) output_bit(LCD_ENABLE_PIN, x) 
....................    #define lcd_enable_tris()  output_drive(LCD_ENABLE_PIN) 
.................... #endif 
....................  
.................... #ifndef LCD_RS_PIN 
....................    #define lcd_output_rs(x) lcdlat.rs=x 
....................    #define lcd_rs_tris()   lcdtris.rs=0 
.................... #else 
....................    #define lcd_output_rs(x) output_bit(LCD_RS_PIN, x) 
....................    #define lcd_rs_tris()  output_drive(LCD_RS_PIN) 
.................... #endif 
....................  
.................... #ifndef LCD_RW_PIN 
....................    #define lcd_output_rw(x) lcdlat.rw=x 
....................    #define lcd_rw_tris()   lcdtris.rw=0 
.................... #else 
....................    #define lcd_output_rw(x) output_bit(LCD_RW_PIN, x) 
....................    #define lcd_rw_tris()  output_drive(LCD_RW_PIN) 
.................... #endif 
....................  
.................... // original version of this library incorrectly labeled LCD_DATA0 as LCD_DATA4, 
.................... // LCD_DATA1 as LCD_DATA5, and so on.  this block of code makes the driver 
.................... // compatible with any code written for the original library 
.................... #if (defined(LCD_DATA0) && defined(LCD_DATA1) && defined(LCD_DATA2) && defined(LCD_DATA3) && !defined(LCD_DATA4) && !defined(LCD_DATA5) && !defined(LCD_DATA6) && !defined(LCD_DATA7)) 
....................    #define  LCD_DATA4    LCD_DATA0 
....................    #define  LCD_DATA5    LCD_DATA1 
....................    #define  LCD_DATA6    LCD_DATA2 
....................    #define  LCD_DATA7    LCD_DATA3 
.................... #endif 
....................  
.................... #ifndef LCD_DATA4 
.................... #ifndef LCD_DATA_PORT 
....................    #if defined(__PCB__) 
....................       #define LCD_DATA_PORT      0x06     //portb 
....................       #define set_tris_lcd(x)   set_tris_b(x) 
....................    #else 
....................      #if defined(PIN_D0) 
....................       #define LCD_DATA_PORT      getenv("SFR:PORTD")     //portd 
....................      #else 
....................       #define LCD_DATA_PORT      getenv("SFR:PORTB")     //portb 
....................      #endif 
....................    #endif    
.................... #endif 
....................  
.................... #if defined(__PCB__) 
....................    LCD_PIN_MAP lcd, lcdlat; 
....................    #byte lcd = LCD_DATA_PORT 
....................    #byte lcdlat = LCD_DATA_PORT 
.................... #elif defined(__PCM__) 
....................    LCD_PIN_MAP lcd, lcdlat, lcdtris; 
....................    #byte lcd = LCD_DATA_PORT 
....................    #byte lcdlat = LCD_DATA_PORT 
....................    #byte lcdtris = LCD_DATA_PORT+0x80 
.................... #elif defined(__PCH__) 
....................    LCD_PIN_MAP lcd, lcdlat, lcdtris; 
....................    #byte lcd = LCD_DATA_PORT 
....................    #byte lcdlat = LCD_DATA_PORT+9 
....................    #byte lcdtris = LCD_DATA_PORT+0x12 
.................... #elif defined(__PCD__) 
....................    LCD_PIN_MAP lcd, lcdlat, lcdtris; 
....................    #word lcd = LCD_DATA_PORT 
....................    #word lcdlat = LCD_DATA_PORT+2 
....................    #word lcdtris = LCD_DATA_PORT-0x02 
.................... #endif 
.................... #endif   //LCD_DATA4 not defined 
....................  
.................... #ifndef LCD_TYPE 
....................    #define LCD_TYPE 2           // 0=5x7, 1=5x10, 2=2 lines 
.................... #endif 
....................  
.................... #ifndef LCD_LINE_TWO 
....................    #define LCD_LINE_TWO 0x40    // LCD RAM address for the second line 
.................... #endif 
....................  
.................... #ifndef LCD_LINE_LENGTH 
....................    #define LCD_LINE_LENGTH 20 
.................... #endif 
....................  
.................... unsigned int8 lcd_read_nibble(void); 
....................  
.................... unsigned int8 lcd_read_byte(void) 
.................... { 
....................    unsigned int8 low,high; 
....................  
....................  #if defined(__PCB__) 
....................    set_tris_lcd(LCD_INPUT_MAP); 
....................  #else 
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7)) 
....................    output_float(LCD_DATA4); 
....................    output_float(LCD_DATA5); 
....................    output_float(LCD_DATA6); 
....................    output_float(LCD_DATA7); 
....................   #else 
....................    lcdtris.data = 0xF; 
*
010B:  MOVLW  0F
010C:  BSF    03.5
010D:  ANDWF  06,W
010E:  IORLW  F0
010F:  MOVWF  06
....................   #endif 
....................  #endif 
....................          
....................    lcd_output_rw(1); 
0110:  BCF    03.5
0111:  BSF    06.2
....................    delay_cycles(1); 
0112:  NOP
....................    lcd_output_enable(1); 
0113:  BSF    06.0
....................    delay_cycles(1); 
0114:  NOP
....................    high = lcd_read_nibble(); 
0115:  CALL   0FF
0116:  MOVF   78,W
0117:  BSF    03.6
0118:  MOVWF  2C
....................        
....................    lcd_output_enable(0); 
0119:  BCF    03.6
011A:  BCF    06.0
....................    delay_cycles(1); 
011B:  NOP
....................    lcd_output_enable(1); 
011C:  BSF    06.0
....................    delay_us(1); 
011D:  GOTO   11E
....................    low = lcd_read_nibble(); 
011E:  CALL   0FF
011F:  MOVF   78,W
0120:  BSF    03.6
0121:  MOVWF  2B
....................        
....................    lcd_output_enable(0); 
0122:  BCF    03.6
0123:  BCF    06.0
....................  
....................  #if defined(__PCB__) 
....................    set_tris_lcd(LCD_OUTPUT_MAP); 
....................  #else 
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7)) 
....................    output_drive(LCD_DATA4); 
....................    output_drive(LCD_DATA5); 
....................    output_drive(LCD_DATA6); 
....................    output_drive(LCD_DATA7); 
....................   #else 
....................    lcdtris.data = 0x0; 
0124:  MOVLW  0F
0125:  BSF    03.5
0126:  ANDWF  06,W
0127:  MOVWF  06
....................   #endif 
....................  #endif 
....................  
....................    return( (high<<4) | low); 
0128:  BCF    03.5
0129:  BSF    03.6
012A:  SWAPF  2C,W
012B:  MOVWF  77
012C:  MOVLW  F0
012D:  ANDWF  77,F
012E:  MOVF   77,W
012F:  IORWF  2B,W
0130:  MOVWF  78
.................... } 
....................  
.................... unsigned int8 lcd_read_nibble(void) 
.................... { 
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7)) 
....................    unsigned int8 n = 0x00; 
....................  
....................    /* Read the data port */ 
....................    n |= input(LCD_DATA4); 
....................    n |= input(LCD_DATA5) << 1; 
....................    n |= input(LCD_DATA6) << 2; 
....................    n |= input(LCD_DATA7) << 3; 
....................     
....................    return(n); 
....................   #else 
....................    return(lcd.data); 
*
00FF:  MOVF   06,W
0100:  MOVWF  77
0101:  SWAPF  06,W
0102:  ANDLW  0F
0103:  MOVWF  78
....................   #endif 
0104:  RETURN
.................... } 
....................  
.................... void lcd_send_nibble(unsigned int8 n) 
.................... { 
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7)) 
....................    /* Write to the data port */ 
....................    output_bit(LCD_DATA4, bit_test(n, 0)); 
....................    output_bit(LCD_DATA5, bit_test(n, 1)); 
....................    output_bit(LCD_DATA6, bit_test(n, 2)); 
....................    output_bit(LCD_DATA7, bit_test(n, 3)); 
....................   #else       
....................    lcdlat.data = n; 
*
00F0:  BSF    03.6
00F1:  SWAPF  2C,W
00F2:  ANDLW  F0
00F3:  MOVWF  77
00F4:  MOVLW  0F
00F5:  BCF    03.6
00F6:  ANDWF  06,W
00F7:  IORWF  77,W
00F8:  MOVWF  06
....................   #endif 
....................        
....................    delay_cycles(1); 
00F9:  NOP
....................    lcd_output_enable(1); 
00FA:  BSF    06.0
....................    delay_us(2); 
00FB:  GOTO   0FC
00FC:  GOTO   0FD
....................    lcd_output_enable(0); 
00FD:  BCF    06.0
00FE:  RETURN
.................... } 
....................  
.................... void lcd_send_byte(unsigned int8 address, unsigned int8 n) 
.................... { 
....................   #if defined(__PCB__) 
....................    set_tris_lcd(LCD_OUTPUT_MAP); 
....................   #else 
....................    lcd_enable_tris(); 
*
0105:  BSF    03.5
0106:  BCF    06.0
....................    lcd_rs_tris(); 
0107:  BCF    06.1
....................    lcd_rw_tris(); 
0108:  BCF    06.2
....................   #endif 
....................  
....................    lcd_output_rs(0); 
0109:  BCF    03.5
010A:  BCF    06.1
....................    while ( bit_test(lcd_read_byte(),7) ) ; 
*
0131:  MOVF   78,W
0132:  MOVWF  2B
0133:  BTFSS  2B.7
0134:  GOTO   137
0135:  BCF    03.6
0136:  GOTO   10B
....................    lcd_output_rs(address); 
0137:  BTFSC  29.0
0138:  GOTO   13C
0139:  BCF    03.6
013A:  BCF    06.1
013B:  BSF    03.6
013C:  BTFSS  29.0
013D:  GOTO   141
013E:  BCF    03.6
013F:  BSF    06.1
0140:  BSF    03.6
....................    delay_cycles(1); 
0141:  NOP
....................    lcd_output_rw(0); 
0142:  BCF    03.6
0143:  BCF    06.2
....................    delay_cycles(1); 
0144:  NOP
....................    lcd_output_enable(0); 
0145:  BCF    06.0
....................    lcd_send_nibble(n >> 4); 
0146:  BSF    03.6
0147:  SWAPF  2A,W
0148:  MOVWF  2B
0149:  MOVLW  0F
014A:  ANDWF  2B,F
014B:  MOVF   2B,W
014C:  MOVWF  2C
014D:  BCF    03.6
014E:  CALL   0F0
....................    lcd_send_nibble(n & 0xf); 
014F:  BSF    03.6
0150:  MOVF   2A,W
0151:  ANDLW  0F
0152:  MOVWF  2B
0153:  MOVWF  2C
0154:  BCF    03.6
0155:  CALL   0F0
0156:  RETURN
.................... } 
....................  
.................... #if defined(LCD_EXTENDED_NEWLINE) 
.................... unsigned int8 g_LcdX, g_LcdY; 
.................... #endif 
....................  
.................... void lcd_init(void)  
.................... { 
....................    unsigned int8 i; 
....................    unsigned int8 LCD_INIT_STRING[4] = {0x20 | (LCD_TYPE << 2), 0xc, 1, 6}; 
0157:  MOVLW  28
0158:  BSF    03.6
0159:  MOVWF  1A
015A:  MOVLW  0C
015B:  MOVWF  1B
015C:  MOVLW  01
015D:  MOVWF  1C
015E:  MOVLW  06
015F:  MOVWF  1D
....................                              // These bytes need to be sent to the LCD 
....................                              // to start it up. 
....................     
....................  
....................    lcd_output_enable(0); 
0160:  BCF    03.6
0161:  BCF    06.0
....................    lcd_output_rs(0); 
0162:  BCF    06.1
....................    lcd_output_rw(0); 
0163:  BCF    06.2
....................  
....................  #if defined(__PCB__) 
....................    set_tris_lcd(LCD_OUTPUT_MAP); 
....................  #else 
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7)) 
....................    output_drive(LCD_DATA4); 
....................    output_drive(LCD_DATA5); 
....................    output_drive(LCD_DATA6); 
....................    output_drive(LCD_DATA7); 
....................   #else 
....................    lcdtris.data = 0x0; 
0164:  MOVLW  0F
0165:  BSF    03.5
0166:  ANDWF  06,W
0167:  MOVWF  06
....................   #endif 
....................    lcd_enable_tris(); 
0168:  BCF    06.0
....................    lcd_rs_tris(); 
0169:  BCF    06.1
....................    lcd_rw_tris(); 
016A:  BCF    06.2
....................  #endif 
....................      
....................    delay_ms(15); 
016B:  MOVLW  0F
016C:  BCF    03.5
016D:  BSF    03.6
016E:  MOVWF  25
016F:  BCF    03.6
0170:  CALL   0DC
....................    for(i=1;i<=3;++i) 
0171:  MOVLW  01
0172:  BSF    03.6
0173:  MOVWF  19
0174:  MOVF   19,W
0175:  SUBLW  03
0176:  BTFSS  03.0
0177:  GOTO   184
....................    { 
....................        lcd_send_nibble(3); 
0178:  MOVLW  03
0179:  MOVWF  2C
017A:  BCF    03.6
017B:  CALL   0F0
....................        delay_ms(5); 
017C:  MOVLW  05
017D:  BSF    03.6
017E:  MOVWF  25
017F:  BCF    03.6
0180:  CALL   0DC
0181:  BSF    03.6
0182:  INCF   19,F
0183:  GOTO   174
....................    } 
....................     
....................    lcd_send_nibble(2); 
0184:  MOVLW  02
0185:  MOVWF  2C
0186:  BCF    03.6
0187:  CALL   0F0
....................    delay_ms(5); 
0188:  MOVLW  05
0189:  BSF    03.6
018A:  MOVWF  25
018B:  BCF    03.6
018C:  CALL   0DC
....................    for(i=0;i<=3;++i) 
018D:  BSF    03.6
018E:  CLRF   19
018F:  MOVF   19,W
0190:  SUBLW  03
0191:  BTFSS  03.0
0192:  GOTO   1A1
....................       lcd_send_byte(0,LCD_INIT_STRING[i]); 
0193:  MOVLW  1A
0194:  ADDWF  19,W
0195:  MOVWF  04
0196:  BSF    03.7
0197:  MOVF   00,W
0198:  MOVWF  1E
0199:  CLRF   29
019A:  MOVF   1E,W
019B:  MOVWF  2A
019C:  BCF    03.6
019D:  CALL   105
....................  
....................   #if defined(LCD_EXTENDED_NEWLINE) 
019E:  BSF    03.6
019F:  INCF   19,F
01A0:  GOTO   18F
01A1:  BCF    03.6
01A2:  BCF    0A.3
01A3:  BCF    0A.4
01A4:  GOTO   49D (RETURN)
....................    g_LcdX = 0; 
....................    g_LcdY = 0; 
....................   #endif 
.................... } 
....................  
.................... void lcd_gotoxy(unsigned int8 x, unsigned int8 y) 
.................... { 
....................    unsigned int8 address; 
....................     
....................    if(y!=1) 
*
01F7:  BSF    03.6
01F8:  DECFSZ 26,W
01F9:  GOTO   1FB
01FA:  GOTO   1FE
....................       address=LCD_LINE_TWO; 
01FB:  MOVLW  40
01FC:  MOVWF  27
01FD:  GOTO   1FF
....................    else 
....................       address=0; 
01FE:  CLRF   27
....................       
....................    address+=x-1; 
01FF:  MOVLW  01
0200:  SUBWF  25,W
0201:  ADDWF  27,F
....................    lcd_send_byte(0,0x80|address); 
0202:  MOVF   27,W
0203:  IORLW  80
0204:  MOVWF  28
0205:  CLRF   29
0206:  MOVF   28,W
0207:  MOVWF  2A
0208:  BCF    03.6
0209:  CALL   105
....................  
....................   #if defined(LCD_EXTENDED_NEWLINE) 
020A:  RETURN
....................    g_LcdX = x - 1; 
....................    g_LcdY = y - 1; 
....................   #endif 
.................... } 
....................  
.................... void lcd_putc(char c) 
.................... { 
....................    switch (c) 
020B:  BSF    03.6
020C:  MOVF   24,W
020D:  XORLW  07
020E:  BCF    03.6
020F:  BTFSC  03.2
0210:  GOTO   21B
0211:  XORLW  0B
0212:  BTFSC  03.2
0213:  GOTO   222
0214:  XORLW  06
0215:  BTFSC  03.2
0216:  GOTO   22E
0217:  XORLW  02
0218:  BTFSC  03.2
0219:  GOTO   236
021A:  GOTO   23D
....................    { 
....................       case '\a'   :  lcd_gotoxy(1,1);     break; 
021B:  MOVLW  01
021C:  BSF    03.6
021D:  MOVWF  25
021E:  MOVWF  26
021F:  BCF    03.6
0220:  CALL   1F7
0221:  GOTO   244
....................  
....................       case '\f'   :  lcd_send_byte(0,1); 
0222:  BSF    03.6
0223:  CLRF   29
0224:  MOVLW  01
0225:  MOVWF  2A
0226:  BCF    03.6
0227:  CALL   105
....................                      delay_ms(2); 
0228:  MOVLW  02
0229:  BSF    03.6
022A:  MOVWF  25
022B:  BCF    03.6
022C:  CALL   0DC
....................                     #if defined(LCD_EXTENDED_NEWLINE) 
....................                      g_LcdX = 0; 
....................                      g_LcdY = 0; 
....................                     #endif 
....................                      break; 
022D:  GOTO   244
....................  
....................      #if defined(LCD_EXTENDED_NEWLINE) 
....................       case '\r'   :  lcd_gotoxy(1, g_LcdY+1);   break; 
....................       case '\n'   : 
....................          while (g_LcdX++ < LCD_LINE_LENGTH) 
....................          { 
....................             lcd_send_byte(1, ' '); 
....................          } 
....................          lcd_gotoxy(1, g_LcdY+2); 
....................          break; 
....................      #else 
....................       case '\n'   : lcd_gotoxy(1,2);        break; 
022E:  MOVLW  01
022F:  BSF    03.6
0230:  MOVWF  25
0231:  MOVLW  02
0232:  MOVWF  26
0233:  BCF    03.6
0234:  CALL   1F7
0235:  GOTO   244
....................      #endif 
....................       
....................       case '\b'   : lcd_send_byte(0,0x10);  break; 
0236:  BSF    03.6
0237:  CLRF   29
0238:  MOVLW  10
0239:  MOVWF  2A
023A:  BCF    03.6
023B:  CALL   105
023C:  GOTO   244
....................       
....................      #if defined(LCD_EXTENDED_NEWLINE) 
....................       default     :  
....................          if (g_LcdX < LCD_LINE_LENGTH) 
....................          { 
....................             lcd_send_byte(1, c); 
....................             g_LcdX++; 
....................          } 
....................          break; 
....................      #else 
....................       default     : lcd_send_byte(1,c);     break; 
023D:  MOVLW  01
023E:  BSF    03.6
023F:  MOVWF  29
0240:  MOVF   24,W
0241:  MOVWF  2A
0242:  BCF    03.6
0243:  CALL   105
....................      #endif 
....................    } 
0244:  RETURN
.................... } 
....................   
.................... char lcd_getc(unsigned int8 x, unsigned int8 y) 
.................... { 
....................    char value; 
....................  
....................    lcd_gotoxy(x,y); 
....................    while ( bit_test(lcd_read_byte(),7) ); // wait until busy flag is low 
....................    lcd_output_rs(1); 
....................    value = lcd_read_byte(); 
....................    lcd_output_rs(0); 
....................     
....................    return(value); 
.................... } 
....................  
.................... // write a custom character to the ram 
.................... // which is 0-7 and specifies which character array we are modifying. 
.................... // ptr points to an array of 8 bytes, where each byte is the next row of 
.................... //    pixels.  only bits 0-4 are used.  the last row is the cursor row, and 
.................... //    usually you will want to leave this byte 0x00. 
.................... void lcd_set_cgram_char(unsigned int8 which, unsigned int8 *ptr) 
.................... { 
....................    unsigned int i; 
....................  
....................    which <<= 3; 
....................    which &= 0x38; 
....................  
....................    lcd_send_byte(0, 0x40 | which);  //set cgram address 
....................  
....................    for(i=0; i<8; i++) 
....................    { 
....................       lcd_send_byte(1, *ptr++); 
....................    } 
....................    
....................    #if defined(LCD_EXTENDED_NEWLINE) 
....................     lcd_gotoxy(g_LcdX+1, g_LcdY+1);  //set ddram address 
....................    #endif 
.................... } 
....................  
.................... void lcd_cursor_on(int1 on) 
.................... { 
....................    if (on) 
....................    { 
....................       lcd_send_byte(0,0x0F);           //turn LCD cursor ON 
....................    } 
....................    else 
....................    { 
....................       lcd_send_byte(0,0x0C);           //turn LCD cursor OFF 
....................    } 
.................... } 
....................  
.................... #endif 
....................  
....................  
....................  
.................... int16 START_TIME = 65059; 
....................  
.................... //!//Happy Birthday 
.................... int16 arr[25] = { 
.................... 65059,65059,65111,65059,65179,65157,65059,65059,65111,65059,65218,65179, 
.................... 65059,65059,65306,65252,65179,65157,65111, 
.................... 65268,65268,65252,65179,65218,65179 
.................... }; 
*
03F2:  MOVLW  23
03F3:  MOVWF  33
03F4:  MOVLW  FE
03F5:  MOVWF  34
03F6:  MOVLW  23
03F7:  MOVWF  35
03F8:  MOVLW  FE
03F9:  MOVWF  36
03FA:  MOVLW  57
03FB:  MOVWF  37
03FC:  MOVLW  FE
03FD:  MOVWF  38
03FE:  MOVLW  23
03FF:  MOVWF  39
0400:  MOVLW  FE
0401:  MOVWF  3A
0402:  MOVLW  9B
0403:  MOVWF  3B
0404:  MOVLW  FE
0405:  MOVWF  3C
0406:  MOVLW  85
0407:  MOVWF  3D
0408:  MOVLW  FE
0409:  MOVWF  3E
040A:  MOVLW  23
040B:  MOVWF  3F
040C:  MOVLW  FE
040D:  MOVWF  40
040E:  MOVLW  23
040F:  MOVWF  41
0410:  MOVLW  FE
0411:  MOVWF  42
0412:  MOVLW  57
0413:  MOVWF  43
0414:  MOVLW  FE
0415:  MOVWF  44
0416:  MOVLW  23
0417:  MOVWF  45
0418:  MOVLW  FE
0419:  MOVWF  46
041A:  MOVLW  C2
041B:  MOVWF  47
041C:  MOVLW  FE
041D:  MOVWF  48
041E:  MOVLW  9B
041F:  MOVWF  49
0420:  MOVLW  FE
0421:  MOVWF  4A
0422:  MOVLW  23
0423:  MOVWF  4B
0424:  MOVLW  FE
0425:  MOVWF  4C
0426:  MOVLW  23
0427:  MOVWF  4D
0428:  MOVLW  FE
0429:  MOVWF  4E
042A:  MOVLW  1A
042B:  MOVWF  4F
042C:  MOVLW  FF
042D:  MOVWF  50
042E:  MOVLW  E4
042F:  MOVWF  51
0430:  MOVLW  FE
0431:  MOVWF  52
0432:  MOVLW  9B
0433:  MOVWF  53
0434:  MOVLW  FE
0435:  MOVWF  54
0436:  MOVLW  85
0437:  MOVWF  55
0438:  MOVLW  FE
0439:  MOVWF  56
043A:  MOVLW  57
043B:  MOVWF  57
043C:  MOVLW  FE
043D:  MOVWF  58
043E:  MOVLW  F4
043F:  MOVWF  59
0440:  MOVLW  FE
0441:  MOVWF  5A
0442:  MOVLW  F4
0443:  MOVWF  5B
0444:  MOVLW  FE
0445:  MOVWF  5C
0446:  MOVLW  E4
0447:  MOVWF  5D
0448:  MOVLW  FE
0449:  MOVWF  5E
044A:  MOVLW  9B
044B:  MOVWF  5F
044C:  MOVLW  FE
044D:  MOVWF  60
044E:  MOVLW  C2
044F:  MOVWF  61
0450:  MOVLW  FE
0451:  MOVWF  62
0452:  MOVLW  9B
0453:  MOVWF  63
0454:  MOVLW  FE
0455:  MOVWF  64
.................... int16 time[25] = { 
.................... 100,80,140,120,120,140,100,80,140,120,120,140,100,80,140,140,120,120,120,100,80,140,120,120,120 
.................... }; 
0456:  MOVLW  64
0457:  BSF    03.5
0458:  MOVWF  20
0459:  CLRF   21
045A:  MOVLW  50
045B:  MOVWF  22
045C:  CLRF   23
045D:  MOVLW  8C
045E:  MOVWF  24
045F:  CLRF   25
0460:  MOVLW  78
0461:  MOVWF  26
0462:  CLRF   27
0463:  MOVWF  28
0464:  CLRF   29
0465:  MOVLW  8C
0466:  MOVWF  2A
0467:  CLRF   2B
0468:  MOVLW  64
0469:  MOVWF  2C
046A:  CLRF   2D
046B:  MOVLW  50
046C:  MOVWF  2E
046D:  CLRF   2F
046E:  MOVLW  8C
046F:  MOVWF  30
0470:  CLRF   31
0471:  MOVLW  78
0472:  MOVWF  32
0473:  CLRF   33
0474:  MOVWF  34
0475:  CLRF   35
0476:  MOVLW  8C
0477:  MOVWF  36
0478:  CLRF   37
0479:  MOVLW  64
047A:  MOVWF  38
047B:  CLRF   39
047C:  MOVLW  50
047D:  MOVWF  3A
047E:  CLRF   3B
047F:  MOVLW  8C
0480:  MOVWF  3C
0481:  CLRF   3D
0482:  MOVWF  3E
0483:  CLRF   3F
0484:  MOVLW  78
0485:  MOVWF  40
0486:  CLRF   41
0487:  MOVWF  42
0488:  CLRF   43
0489:  MOVWF  44
048A:  CLRF   45
048B:  MOVLW  64
048C:  MOVWF  46
048D:  CLRF   47
048E:  MOVLW  50
048F:  MOVWF  48
0490:  CLRF   49
0491:  MOVLW  8C
0492:  MOVWF  4A
0493:  CLRF   4B
0494:  MOVLW  78
0495:  MOVWF  4C
0496:  CLRF   4D
0497:  MOVWF  4E
0498:  CLRF   4F
0499:  MOVWF  50
049A:  CLRF   51
....................  
.................... #INT_TIMER1 
.................... void timer1_isr(){ 
....................    set_timer1(START_TIME); 
*
008F:  CLRF   0E
0090:  MOVF   32,W
0091:  MOVWF  0F
0092:  MOVF   31,W
0093:  MOVWF  0E
....................    output_toggle(PIN_B6); 
0094:  BSF    03.5
0095:  BCF    06.6
0096:  MOVLW  40
0097:  BCF    03.5
0098:  XORWF  06,F
0099:  BCF    0C.0
009A:  BCF    0A.3
009B:  BCF    0A.4
009C:  GOTO   02D
.................... } 
....................  
.................... //lcd display function 
.................... void lcd_Show(long f){ 
....................       lcd_gotoxy(5, 2);           // Go to column 5 row 2 
*
03A6:  MOVLW  05
03A7:  BSF    03.6
03A8:  MOVWF  25
03A9:  MOVLW  02
03AA:  MOVWF  26
03AB:  BCF    03.6
03AC:  CALL   1F7
....................       printf(lcd_putc,"%lu",f); 
03AD:  MOVLW  10
03AE:  MOVWF  04
03AF:  BSF    03.6
03B0:  MOVF   1A,W
03B1:  MOVWF  1C
03B2:  MOVF   19,W
03B3:  MOVWF  1B
03B4:  BCF    03.6
03B5:  CALL   245
....................       lcd_gotoxy(12,2); 
03B6:  MOVLW  0C
03B7:  BSF    03.6
03B8:  MOVWF  25
03B9:  MOVLW  02
03BA:  MOVWF  26
03BB:  BCF    03.6
03BC:  CALL   1F7
....................       lcd_putc("Hz"); 
03BD:  MOVLW  9D
03BE:  BSF    03.6
03BF:  MOVWF  0D
03C0:  MOVLW  00
03C1:  MOVWF  0F
03C2:  BCF    03.6
03C3:  CALL   2AC
03C4:  RETURN
.................... } 
....................  
.................... //calculate given frequency to timer 
.................... int16 convertTimer(long f){ 
....................    return 65536 - (1000000/(4*f)); 
*
031C:  BSF    03.6
031D:  RLF    19,W
031E:  MOVWF  79
031F:  RLF    1A,W
0320:  MOVWF  7A
0321:  RLF    79,F
0322:  RLF    7A,F
0323:  MOVLW  FC
0324:  ANDWF  79,F
0325:  MOVF   79,W
0326:  MOVWF  1B
0327:  MOVF   7A,W
0328:  MOVWF  1C
0329:  BCF    03.1
032A:  CLRF   20
032B:  MOVLW  0F
032C:  MOVWF  1F
032D:  MOVLW  42
032E:  MOVWF  1E
032F:  MOVLW  40
0330:  MOVWF  1D
0331:  CLRF   24
0332:  CLRF   23
0333:  MOVF   1C,W
0334:  MOVWF  22
0335:  MOVF   1B,W
0336:  MOVWF  21
*
0385:  MOVF   77,W
0386:  SUBLW  00
0387:  MOVWF  77
0388:  MOVF   78,W
0389:  BTFSS  03.0
038A:  INCFSZ 78,W
038B:  GOTO   38E
038C:  MOVLW  00
038D:  GOTO   38F
038E:  SUBLW  00
038F:  MOVWF  78
0390:  MOVF   79,W
0391:  BTFSS  03.0
0392:  INCFSZ 79,W
0393:  GOTO   396
0394:  MOVLW  01
0395:  GOTO   397
0396:  SUBLW  01
0397:  MOVWF  79
0398:  MOVF   7A,W
0399:  BTFSS  03.0
039A:  INCFSZ 7A,W
039B:  GOTO   39E
039C:  MOVLW  00
039D:  GOTO   39F
039E:  SUBLW  00
039F:  MOVWF  7A
03A0:  MOVF   78,W
03A1:  MOVWF  79
03A2:  MOVF   77,W
03A3:  MOVWF  78
03A4:  BCF    03.6
03A5:  RETURN
.................... } 
....................  
.................... void main() 
*
03C5:  MOVF   03,W
03C6:  ANDLW  1F
03C7:  MOVWF  03
03C8:  MOVLW  71
03C9:  BSF    03.5
03CA:  MOVWF  0F
03CB:  CLRF   10
03CC:  MOVF   0F,W
03CD:  BSF    03.6
03CE:  BCF    07.3
03CF:  MOVLW  0C
03D0:  BCF    03.6
03D1:  MOVWF  19
03D2:  MOVLW  A2
03D3:  MOVWF  18
03D4:  MOVLW  90
03D5:  BCF    03.5
03D6:  MOVWF  18
03D7:  MOVLW  FE
03D8:  MOVWF  32
03D9:  MOVLW  23
03DA:  MOVWF  31
03DB:  CLRF   66
03DC:  CLRF   65
03DD:  MOVLW  FF
03DE:  MOVWF  67
03DF:  BSF    03.5
03E0:  BSF    03.6
03E1:  MOVF   09,W
03E2:  ANDLW  C0
03E3:  MOVWF  09
03E4:  BCF    03.6
03E5:  BCF    1F.4
03E6:  BCF    1F.5
03E7:  MOVLW  00
03E8:  BSF    03.6
03E9:  MOVWF  08
03EA:  BCF    03.5
03EB:  CLRF   07
03EC:  CLRF   08
03ED:  CLRF   09
03EE:  BCF    03.7
.................... { 
....................    lcd_init(); 
*
049B:  BCF    03.5
049C:  GOTO   157
....................    //initial code for setup timer for interrupt 
....................    setup_timer_1(T1_INTERNAL | T1_DIV_BY_4); 
049D:  MOVLW  25
049E:  MOVWF  10
....................    set_timer1(START_TIME); 
049F:  CLRF   0E
04A0:  MOVF   32,W
04A1:  MOVWF  0F
04A2:  MOVF   31,W
04A3:  MOVWF  0E
....................    enable_interrupts(INT_TIMER1); 
04A4:  BSF    03.5
04A5:  BSF    0C.0
....................    enable_interrupts(GLOBAL); 
04A6:  MOVLW  C0
04A7:  BCF    03.5
04A8:  IORWF  0B,F
....................    //-----------------------------------------------------// 
....................    //var decaration 
....................    int lastButton = -1; 
....................    long inputFeq = 500;  
....................    char topText [11] = "CURRENT_FEQ"; 
*
04B0:  MOVLW  43
04B1:  MOVWF  55
04B2:  MOVLW  55
04B3:  MOVWF  56
04B4:  MOVLW  52
04B5:  MOVWF  57
04B6:  MOVWF  58
04B7:  MOVLW  45
04B8:  MOVWF  59
04B9:  MOVLW  4E
04BA:  MOVWF  5A
04BB:  MOVLW  54
04BC:  MOVWF  5B
04BD:  MOVLW  5F
04BE:  MOVWF  5C
04BF:  MOVLW  46
04C0:  MOVWF  5D
04C1:  MOVLW  45
04C2:  MOVWF  5E
04C3:  MOVLW  51
04C4:  MOVWF  5F
....................    //-----------------------------------------------------// 
.................... //!   long default_feq [6] = {1043, 1175, 1319, 1399, 1565, 1764}; 
....................    int16 d_but1 = 65306; 
....................    int16 d_but2 = 65333; 
....................    int16 d_but3 = 65356; 
....................    int16 d_but4 = 65367; 
....................    int16 d_but5 = 65386; 
....................    int16 d_but6 = 65404; 
.................... //!   long current_feq [6]; 
.................... //    copy arr from defalut -> current for initialize value 
....................    int16 c_but1 = d_but1; 
....................    int16 c_but2 = d_but2; 
....................    int16 c_but3 = d_but3; 
....................    int16 c_but4 = d_but4; 
....................    int16 c_but5 = d_but5; 
....................    int16 c_but6 = d_but6; 
....................    //-----------------------------------------------------// 
....................    boolean setIsPressed = !input(PIN_B7); 
*
04A9:  MOVLW  FF
04AA:  BSF    03.5
04AB:  MOVWF  52
04AC:  MOVLW  01
04AD:  MOVWF  54
04AE:  MOVLW  F4
04AF:  MOVWF  53
*
04C5:  MOVLW  FF
04C6:  MOVWF  61
04C7:  MOVLW  1A
04C8:  MOVWF  60
04C9:  MOVLW  FF
04CA:  MOVWF  63
04CB:  MOVLW  35
04CC:  MOVWF  62
04CD:  MOVLW  FF
04CE:  MOVWF  65
04CF:  MOVLW  4C
04D0:  MOVWF  64
04D1:  MOVLW  FF
04D2:  MOVWF  67
04D3:  MOVLW  57
04D4:  MOVWF  66
04D5:  MOVLW  FF
04D6:  MOVWF  69
04D7:  MOVLW  6A
04D8:  MOVWF  68
04D9:  MOVLW  FF
04DA:  MOVWF  6B
04DB:  MOVLW  7C
04DC:  MOVWF  6A
04DD:  MOVF   61,W
04DE:  MOVWF  6D
04DF:  MOVF   60,W
04E0:  MOVWF  6C
04E1:  MOVF   63,W
04E2:  MOVWF  6F
04E3:  MOVF   62,W
04E4:  MOVWF  6E
04E5:  MOVF   65,W
04E6:  BCF    03.5
04E7:  BSF    03.6
04E8:  MOVWF  11
04E9:  BSF    03.5
04EA:  BCF    03.6
04EB:  MOVF   64,W
04EC:  BCF    03.5
04ED:  BSF    03.6
04EE:  MOVWF  10
04EF:  BSF    03.5
04F0:  BCF    03.6
04F1:  MOVF   67,W
04F2:  BCF    03.5
04F3:  BSF    03.6
04F4:  MOVWF  13
04F5:  BSF    03.5
04F6:  BCF    03.6
04F7:  MOVF   66,W
04F8:  BCF    03.5
04F9:  BSF    03.6
04FA:  MOVWF  12
04FB:  BSF    03.5
04FC:  BCF    03.6
04FD:  MOVF   69,W
04FE:  BCF    03.5
04FF:  BSF    03.6
0500:  MOVWF  15
0501:  BSF    03.5
0502:  BCF    03.6
0503:  MOVF   68,W
0504:  BCF    03.5
0505:  BSF    03.6
0506:  MOVWF  14
0507:  BSF    03.5
0508:  BCF    03.6
0509:  MOVF   6B,W
050A:  BCF    03.5
050B:  BSF    03.6
050C:  MOVWF  17
050D:  BSF    03.5
050E:  BCF    03.6
050F:  MOVF   6A,W
0510:  BCF    03.5
0511:  BSF    03.6
0512:  MOVWF  16
0513:  BSF    03.5
0514:  BCF    03.6
0515:  BSF    06.7
0516:  BCF    03.5
0517:  BSF    03.6
0518:  BCF    18.0
0519:  BCF    03.6
051A:  BTFSC  06.7
051B:  GOTO   51F
051C:  BSF    03.6
051D:  BSF    18.0
051E:  BCF    03.6
....................    While(1){ 
....................       if(!input(PIN_B3)){ 
051F:  BSF    03.5
0520:  BSF    06.3
0521:  BCF    03.5
0522:  BTFSC  06.3
0523:  GOTO   52C
....................          printf("1 pressed\n"); 
0524:  MOVLW  9F
0525:  BSF    03.6
0526:  MOVWF  0D
0527:  MOVLW  00
0528:  MOVWF  0F
0529:  BCF    03.6
052A:  CALL   1A5
....................       } 
052B:  GOTO   538
....................       else if(!input(PIN_B2)){ 
052C:  BSF    03.5
052D:  BSF    06.2
052E:  BCF    03.5
052F:  BTFSC  06.2
0530:  GOTO   538
....................          printf("2 pressed\n"); 
0531:  MOVLW  A5
0532:  BSF    03.6
0533:  MOVWF  0D
0534:  MOVLW  00
0535:  MOVWF  0F
0536:  BCF    03.6
0537:  CALL   1A5
....................       } 
....................       lcd_putc('\f'); 
0538:  MOVLW  0C
0539:  BSF    03.6
053A:  MOVWF  24
053B:  BCF    03.6
053C:  CALL   20B
....................       lcd_gotoxy(4, 1);           // Go to column 4 row 1 
053D:  MOVLW  04
053E:  BSF    03.6
053F:  MOVWF  25
0540:  MOVLW  01
0541:  MOVWF  26
0542:  BCF    03.6
0543:  CALL   1F7
....................       lcd_putc(topText); 
0544:  MOVLW  D5
0545:  BSF    03.6
0546:  MOVWF  24
0547:  BCF    03.6
0548:  CALL   20B
....................       lcd_gotoxy(5, 2);           // Go to column 7 row 2 
0549:  MOVLW  05
054A:  BSF    03.6
054B:  MOVWF  25
054C:  MOVLW  02
054D:  MOVWF  26
054E:  BCF    03.6
054F:  CALL   1F7
....................       printf(lcd_putc,"%lu",inputFeq);   // Write num with 5 numbers max 
0550:  MOVLW  10
0551:  MOVWF  04
0552:  BSF    03.5
0553:  MOVF   54,W
0554:  BCF    03.5
0555:  BSF    03.6
0556:  MOVWF  1C
0557:  BSF    03.5
0558:  BCF    03.6
0559:  MOVF   53,W
055A:  BCF    03.5
055B:  BSF    03.6
055C:  MOVWF  1B
055D:  BCF    03.6
055E:  CALL   245
....................       if (!input(PIN_C2)){//reset 
055F:  BSF    67.2
0560:  MOVF   67,W
0561:  BSF    03.5
0562:  MOVWF  07
0563:  BCF    03.5
0564:  BTFSC  07.2
0565:  GOTO   585
....................          inputFeq = 500; 
0566:  MOVLW  01
0567:  BSF    03.5
0568:  MOVWF  54
0569:  MOVLW  F4
056A:  MOVWF  53
....................          lcd_putc('\f'); 
056B:  MOVLW  0C
056C:  BCF    03.5
056D:  BSF    03.6
056E:  MOVWF  24
056F:  BCF    03.6
0570:  CALL   20B
....................          topText = "FRQ_RESET"; 
0571:  BSF    03.6
0572:  CLRF   19
0573:  CLRF   1A
0574:  MOVLW  D5
0575:  MOVWF  04
0576:  BCF    03.7
0577:  MOVF   19,W
0578:  ADDWF  04,F
0579:  MOVF   1A,W
057A:  BCF    03.6
057B:  CALL   051
057C:  MOVWF  00
057D:  IORLW  00
057E:  BTFSC  03.2
057F:  GOTO   585
0580:  BSF    03.6
0581:  INCF   1A,F
0582:  INCF   19,F
0583:  GOTO   574
0584:  BCF    03.6
....................       } 
....................       if (!input(PIN_B5)){//inc 
0585:  BSF    03.5
0586:  BSF    06.5
0587:  BCF    03.5
0588:  BTFSC  06.5
0589:  GOTO   5B2
....................          if(inputFeq < 25000){ 
058A:  BSF    03.5
058B:  MOVF   54,W
058C:  SUBLW  61
058D:  BTFSS  03.0
058E:  GOTO   599
058F:  BTFSS  03.2
0590:  GOTO   595
0591:  MOVF   53,W
0592:  SUBLW  A7
0593:  BTFSS  03.0
0594:  GOTO   599
....................             inputFeq++; 
0595:  INCF   53,F
0596:  BTFSC  03.2
0597:  INCF   54,F
....................          } 
0598:  GOTO   59D
....................          else { 
....................             inputFeq = 25000; 
0599:  MOVLW  61
059A:  MOVWF  54
059B:  MOVLW  A8
059C:  MOVWF  53
....................              
....................          } 
....................          topText = "CURRENT_FEQ"; 
059D:  BCF    03.5
059E:  BSF    03.6
059F:  CLRF   19
05A0:  CLRF   1A
05A1:  MOVLW  D5
05A2:  MOVWF  04
05A3:  BCF    03.7
05A4:  MOVF   19,W
05A5:  ADDWF  04,F
05A6:  MOVF   1A,W
05A7:  BCF    03.6
05A8:  CALL   05F
05A9:  MOVWF  00
05AA:  IORLW  00
05AB:  BTFSC  03.2
05AC:  GOTO   5B2
05AD:  BSF    03.6
05AE:  INCF   1A,F
05AF:  INCF   19,F
05B0:  GOTO   5A1
05B1:  BCF    03.6
....................       } 
....................       if (!input(PIN_B4)){//dec 
05B2:  BSF    03.5
05B3:  BSF    06.4
05B4:  BCF    03.5
05B5:  BTFSC  06.4
05B6:  GOTO   5E1
....................          if(inputFeq >500){ 
05B7:  BSF    03.5
05B8:  MOVF   54,W
05B9:  SUBLW  00
05BA:  BTFSC  03.0
05BB:  GOTO   5C8
05BC:  XORLW  FF
05BD:  BTFSS  03.2
05BE:  GOTO   5C3
05BF:  MOVF   53,W
05C0:  SUBLW  F4
05C1:  BTFSC  03.0
05C2:  GOTO   5C8
....................             inputFeq--; 
05C3:  MOVF   53,W
05C4:  BTFSC  03.2
05C5:  DECF   54,F
05C6:  DECF   53,F
....................              
....................          } 
05C7:  GOTO   5CC
....................          else { 
....................             inputFeq = 500; 
05C8:  MOVLW  01
05C9:  MOVWF  54
05CA:  MOVLW  F4
05CB:  MOVWF  53
....................          } 
....................          topText = "CURRENT_FEQ"; 
05CC:  BCF    03.5
05CD:  BSF    03.6
05CE:  CLRF   19
05CF:  CLRF   1A
05D0:  MOVLW  D5
05D1:  MOVWF  04
05D2:  BCF    03.7
05D3:  MOVF   19,W
05D4:  ADDWF  04,F
05D5:  MOVF   1A,W
05D6:  BCF    03.6
05D7:  CALL   05F
05D8:  MOVWF  00
05D9:  IORLW  00
05DA:  BTFSC  03.2
05DB:  GOTO   5E1
05DC:  BSF    03.6
05DD:  INCF   1A,F
05DE:  INCF   19,F
05DF:  GOTO   5D0
05E0:  BCF    03.6
....................       } 
....................       lcd_gotoxy(12,2); 
05E1:  MOVLW  0C
05E2:  BSF    03.6
05E3:  MOVWF  25
05E4:  MOVLW  02
05E5:  MOVWF  26
05E6:  BCF    03.6
05E7:  CALL   1F7
....................       lcd_putc("Hz"); 
05E8:  MOVLW  AB
05E9:  BSF    03.6
05EA:  MOVWF  0D
05EB:  MOVLW  00
05EC:  MOVWF  0F
05ED:  BCF    03.6
05EE:  CALL   2AC
....................       printf(setIsPressed ? "true" : "false"); 
05EF:  BSF    03.6
05F0:  BTFSS  18.0
05F1:  GOTO   5F6
05F2:  MOVLW  00
05F3:  MOVWF  7A
05F4:  MOVLW  AD
05F5:  GOTO   5F9
05F6:  MOVLW  00
05F7:  MOVWF  7A
05F8:  MOVLW  B2
05F9:  MOVWF  19
05FA:  MOVWF  04
05FB:  BCF    03.7
05FC:  BTFSC  1A.0
05FD:  BSF    03.7
05FE:  BCF    03.6
05FF:  GOTO   2FC
....................       if(setIsPressed){ 
0600:  BSF    03.6
0601:  BTFSS  18.0
0602:  GOTO   68A
....................          switch(lastButton) 
0603:  MOVLW  01
0604:  BSF    03.5
0605:  BCF    03.6
0606:  SUBWF  52,W
0607:  ADDLW  FA
0608:  BTFSC  03.0
0609:  GOTO   688
060A:  ADDLW  06
060B:  BCF    03.5
060C:  GOTO   79A
....................          { 
....................          case 1: c_but1 = convertTimer(inputFeq); break; 
060D:  BSF    03.5
060E:  MOVF   54,W
060F:  BCF    03.5
0610:  BSF    03.6
0611:  MOVWF  1A
0612:  BSF    03.5
0613:  BCF    03.6
0614:  MOVF   53,W
0615:  BCF    03.5
0616:  BSF    03.6
0617:  MOVWF  19
0618:  BCF    03.6
0619:  CALL   31C
061A:  MOVF   79,W
061B:  BSF    03.5
061C:  MOVWF  6D
061D:  MOVF   78,W
061E:  MOVWF  6C
061F:  GOTO   688
....................          case 2: c_but2 = convertTimer(inputFeq); break; 
0620:  BSF    03.5
0621:  MOVF   54,W
0622:  BCF    03.5
0623:  BSF    03.6
0624:  MOVWF  1A
0625:  BSF    03.5
0626:  BCF    03.6
0627:  MOVF   53,W
0628:  BCF    03.5
0629:  BSF    03.6
062A:  MOVWF  19
062B:  BCF    03.6
062C:  CALL   31C
062D:  MOVF   79,W
062E:  BSF    03.5
062F:  MOVWF  6F
0630:  MOVF   78,W
0631:  MOVWF  6E
0632:  GOTO   688
....................          case 3: c_but3 = convertTimer(inputFeq); break; 
0633:  BSF    03.5
0634:  MOVF   54,W
0635:  BCF    03.5
0636:  BSF    03.6
0637:  MOVWF  1A
0638:  BSF    03.5
0639:  BCF    03.6
063A:  MOVF   53,W
063B:  BCF    03.5
063C:  BSF    03.6
063D:  MOVWF  19
063E:  BCF    03.6
063F:  CALL   31C
0640:  MOVF   79,W
0641:  BSF    03.6
0642:  MOVWF  11
0643:  MOVF   78,W
0644:  MOVWF  10
0645:  BSF    03.5
0646:  BCF    03.6
0647:  GOTO   688
....................          case 4: c_but4 = convertTimer(inputFeq); break; 
0648:  BSF    03.5
0649:  MOVF   54,W
064A:  BCF    03.5
064B:  BSF    03.6
064C:  MOVWF  1A
064D:  BSF    03.5
064E:  BCF    03.6
064F:  MOVF   53,W
0650:  BCF    03.5
0651:  BSF    03.6
0652:  MOVWF  19
0653:  BCF    03.6
0654:  CALL   31C
0655:  MOVF   79,W
0656:  BSF    03.6
0657:  MOVWF  13
0658:  MOVF   78,W
0659:  MOVWF  12
065A:  BSF    03.5
065B:  BCF    03.6
065C:  GOTO   688
....................          case 5: c_but5 = convertTimer(inputFeq); break; 
065D:  BSF    03.5
065E:  MOVF   54,W
065F:  BCF    03.5
0660:  BSF    03.6
0661:  MOVWF  1A
0662:  BSF    03.5
0663:  BCF    03.6
0664:  MOVF   53,W
0665:  BCF    03.5
0666:  BSF    03.6
0667:  MOVWF  19
0668:  BCF    03.6
0669:  CALL   31C
066A:  MOVF   79,W
066B:  BSF    03.6
066C:  MOVWF  15
066D:  MOVF   78,W
066E:  MOVWF  14
066F:  BSF    03.5
0670:  BCF    03.6
0671:  GOTO   688
....................          case 6: c_but6 = convertTimer(inputFeq); break; 
0672:  BSF    03.5
0673:  MOVF   54,W
0674:  BCF    03.5
0675:  BSF    03.6
0676:  MOVWF  1A
0677:  BSF    03.5
0678:  BCF    03.6
0679:  MOVF   53,W
067A:  BCF    03.5
067B:  BSF    03.6
067C:  MOVWF  19
067D:  BCF    03.6
067E:  CALL   31C
067F:  MOVF   79,W
0680:  BSF    03.6
0681:  MOVWF  17
0682:  MOVF   78,W
0683:  MOVWF  16
0684:  BSF    03.5
0685:  BCF    03.6
0686:  GOTO   688
0687:  BSF    03.5
0688:  BCF    03.5
0689:  BSF    03.6
....................          } 
....................       } 
....................       if(!input(PIN_B3)){ 
068A:  BSF    03.5
068B:  BCF    03.6
068C:  BSF    06.3
068D:  BCF    03.5
068E:  BTFSC  06.3
068F:  GOTO   6D9
....................          lastButton = 1; 
0690:  MOVLW  01
0691:  BSF    03.5
0692:  MOVWF  52
....................          printf("1 pressed\n"); 
0693:  MOVLW  B8
0694:  BCF    03.5
0695:  BSF    03.6
0696:  MOVWF  0D
0697:  MOVLW  00
0698:  MOVWF  0F
0699:  BCF    03.6
069A:  CALL   1A5
....................          START_TIME  = c_but1; 
069B:  BSF    03.5
069C:  MOVF   6D,W
069D:  BCF    03.5
069E:  MOVWF  32
069F:  BSF    03.5
06A0:  MOVF   6C,W
06A1:  BCF    03.5
06A2:  MOVWF  31
....................          enable_interrupts(INT_TIMER1); 
06A3:  BSF    03.5
06A4:  BSF    0C.0
....................          lcd_putc('\f'); 
06A5:  MOVLW  0C
06A6:  BCF    03.5
06A7:  BSF    03.6
06A8:  MOVWF  24
06A9:  BCF    03.6
06AA:  CALL   20B
....................          lcd_gotoxy(2, 1);           // Go to column 4 row 1 
06AB:  MOVLW  02
06AC:  BSF    03.6
06AD:  MOVWF  25
06AE:  MOVLW  01
06AF:  MOVWF  26
06B0:  BCF    03.6
06B1:  CALL   1F7
....................          topText = "BT1_FEQ_SET"; 
06B2:  BSF    03.6
06B3:  CLRF   19
06B4:  CLRF   1A
06B5:  MOVLW  D5
06B6:  MOVWF  04
06B7:  BCF    03.7
06B8:  MOVF   19,W
06B9:  ADDWF  04,F
06BA:  MOVF   1A,W
06BB:  BCF    03.6
06BC:  CALL   06F
06BD:  MOVWF  00
06BE:  IORLW  00
06BF:  BTFSC  03.2
06C0:  GOTO   6C6
06C1:  BSF    03.6
06C2:  INCF   1A,F
06C3:  INCF   19,F
06C4:  GOTO   6B5
06C5:  BCF    03.6
....................          lcd_putc(topText); 
06C6:  MOVLW  D5
06C7:  BSF    03.6
06C8:  MOVWF  24
06C9:  BCF    03.6
06CA:  CALL   20B
....................          lcd_Show(inputFeq); 
06CB:  BSF    03.5
06CC:  MOVF   54,W
06CD:  BCF    03.5
06CE:  BSF    03.6
06CF:  MOVWF  1A
06D0:  BSF    03.5
06D1:  BCF    03.6
06D2:  MOVF   53,W
06D3:  BCF    03.5
06D4:  BSF    03.6
06D5:  MOVWF  19
06D6:  BCF    03.6
06D7:  CALL   3A6
....................       } 
06D8:  GOTO   798
....................       else if(!input(PIN_B2)){ 
06D9:  BSF    03.5
06DA:  BSF    06.2
06DB:  BCF    03.5
06DC:  BTFSC  06.2
06DD:  GOTO   725
....................          lastButton = 2; 
06DE:  MOVLW  02
06DF:  BSF    03.5
06E0:  MOVWF  52
....................          START_TIME  = c_but2; 
06E1:  MOVF   6F,W
06E2:  BCF    03.5
06E3:  MOVWF  32
06E4:  BSF    03.5
06E5:  MOVF   6E,W
06E6:  BCF    03.5
06E7:  MOVWF  31
....................          enable_interrupts(INT_TIMER1); 
06E8:  BSF    03.5
06E9:  BSF    0C.0
....................          printf("2 pressed\n"); 
06EA:  MOVLW  BE
06EB:  BCF    03.5
06EC:  BSF    03.6
06ED:  MOVWF  0D
06EE:  MOVLW  00
06EF:  MOVWF  0F
06F0:  BCF    03.6
06F1:  CALL   1A5
....................          lcd_putc('\f'); 
06F2:  MOVLW  0C
06F3:  BSF    03.6
06F4:  MOVWF  24
06F5:  BCF    03.6
06F6:  CALL   20B
....................          lcd_gotoxy(2, 1);           // Go to column 4 row 1 
06F7:  MOVLW  02
06F8:  BSF    03.6
06F9:  MOVWF  25
06FA:  MOVLW  01
06FB:  MOVWF  26
06FC:  BCF    03.6
06FD:  CALL   1F7
....................          topText = "BT2_FEQ_SET"; 
06FE:  BSF    03.6
06FF:  CLRF   19
0700:  CLRF   1A
0701:  MOVLW  D5
0702:  MOVWF  04
0703:  BCF    03.7
0704:  MOVF   19,W
0705:  ADDWF  04,F
0706:  MOVF   1A,W
0707:  BCF    03.6
0708:  CALL   07F
0709:  MOVWF  00
070A:  IORLW  00
070B:  BTFSC  03.2
070C:  GOTO   712
070D:  BSF    03.6
070E:  INCF   1A,F
070F:  INCF   19,F
0710:  GOTO   701
0711:  BCF    03.6
....................          lcd_putc(topText); 
0712:  MOVLW  D5
0713:  BSF    03.6
0714:  MOVWF  24
0715:  BCF    03.6
0716:  CALL   20B
....................          lcd_Show(inputFeq); 
0717:  BSF    03.5
0718:  MOVF   54,W
0719:  BCF    03.5
071A:  BSF    03.6
071B:  MOVWF  1A
071C:  BSF    03.5
071D:  BCF    03.6
071E:  MOVF   53,W
071F:  BCF    03.5
0720:  BSF    03.6
0721:  MOVWF  19
0722:  BCF    03.6
0723:  CALL   3A6
....................       } 
0724:  GOTO   798
....................       else if(!input(PIN_B1)){ 
0725:  BSF    03.5
0726:  BSF    06.1
0727:  BCF    03.5
0728:  BTFSC  06.1
0729:  GOTO   741
....................          lastButton = 3; 
072A:  MOVLW  03
072B:  BSF    03.5
072C:  MOVWF  52
....................          START_TIME  = c_but3; 
072D:  BCF    03.5
072E:  BSF    03.6
072F:  MOVF   11,W
0730:  BCF    03.6
0731:  MOVWF  32
0732:  BSF    03.6
0733:  MOVF   10,W
0734:  BCF    03.6
0735:  MOVWF  31
....................          enable_interrupts(INT_TIMER1); 
0736:  BSF    03.5
0737:  BSF    0C.0
....................           printf("3 pressed\n"); 
0738:  MOVLW  C4
0739:  BCF    03.5
073A:  BSF    03.6
073B:  MOVWF  0D
073C:  MOVLW  00
073D:  MOVWF  0F
073E:  BCF    03.6
073F:  CALL   1A5
....................       } 
0740:  GOTO   798
....................       else if(!input(PIN_B0)){ 
0741:  BSF    03.5
0742:  BSF    06.0
0743:  BCF    03.5
0744:  BTFSC  06.0
0745:  GOTO   75D
....................          lastButton = 4; 
0746:  MOVLW  04
0747:  BSF    03.5
0748:  MOVWF  52
....................          START_TIME  = c_but4; 
0749:  BCF    03.5
074A:  BSF    03.6
074B:  MOVF   13,W
074C:  BCF    03.6
074D:  MOVWF  32
074E:  BSF    03.6
074F:  MOVF   12,W
0750:  BCF    03.6
0751:  MOVWF  31
....................          enable_interrupts(INT_TIMER1); 
0752:  BSF    03.5
0753:  BSF    0C.0
....................           printf("4 pressed\n"); 
0754:  MOVLW  CA
0755:  BCF    03.5
0756:  BSF    03.6
0757:  MOVWF  0D
0758:  MOVLW  00
0759:  MOVWF  0F
075A:  BCF    03.6
075B:  CALL   1A5
....................       } 
075C:  GOTO   798
....................       else if(!input(PIN_C5)){ 
075D:  BSF    67.5
075E:  MOVF   67,W
075F:  BSF    03.5
0760:  MOVWF  07
0761:  BCF    03.5
0762:  BTFSC  07.5
0763:  GOTO   77B
....................          lastButton = 5; 
0764:  MOVLW  05
0765:  BSF    03.5
0766:  MOVWF  52
....................          START_TIME  = c_but5; 
0767:  BCF    03.5
0768:  BSF    03.6
0769:  MOVF   15,W
076A:  BCF    03.6
076B:  MOVWF  32
076C:  BSF    03.6
076D:  MOVF   14,W
076E:  BCF    03.6
076F:  MOVWF  31
....................          enable_interrupts(INT_TIMER1); 
0770:  BSF    03.5
0771:  BSF    0C.0
....................           printf("5 pressed\n"); 
0772:  MOVLW  D0
0773:  BCF    03.5
0774:  BSF    03.6
0775:  MOVWF  0D
0776:  MOVLW  00
0777:  MOVWF  0F
0778:  BCF    03.6
0779:  CALL   1A5
....................       } 
077A:  GOTO   798
....................       else if(!input(PIN_C4)){ 
077B:  BSF    67.4
077C:  MOVF   67,W
077D:  BSF    03.5
077E:  MOVWF  07
077F:  BCF    03.5
0780:  BTFSC  07.4
0781:  GOTO   798
....................          lastButton = 6; 
0782:  MOVLW  06
0783:  BSF    03.5
0784:  MOVWF  52
....................          START_TIME  = c_but6; 
0785:  BCF    03.5
0786:  BSF    03.6
0787:  MOVF   17,W
0788:  BCF    03.6
0789:  MOVWF  32
078A:  BSF    03.6
078B:  MOVF   16,W
078C:  BCF    03.6
078D:  MOVWF  31
....................          enable_interrupts(INT_TIMER1); 
078E:  BSF    03.5
078F:  BSF    0C.0
....................          printf("6 pressed\n"); 
0790:  MOVLW  D6
0791:  BCF    03.5
0792:  BSF    03.6
0793:  MOVWF  0D
0794:  MOVLW  00
0795:  MOVWF  0F
0796:  BCF    03.6
0797:  CALL   1A5
....................       } 
0798:  GOTO   51F
....................        
....................    }   
.................... } 
....................  
0799:  SLEEP

Configuration Fuses:
   Word  1: 2FC4   INTRC_IO NOWDT PUT NOMCLR NOPROTECT NOCPD BROWNOUT IESO FCMEN NOLVP NODEBUG
   Word  2: 3FFF   BORV40 NOWRT
