CCS PCM C Compiler, Version 5.074, 32906               11-มี.ค.-21 22:44

               Filename:   D:\WORK\em_lab\micro_project\main_module.lst

               ROM used:   2505 words (31%)
                           Largest free fragment is 2048
               RAM used:   67 (18%) at main() level
                           88 (24%) worst case
               Stack used: 7 locations (6 in main + 1 for interrupts)
               Stack size: 8

*
0000:  MOVLW  08
0001:  MOVWF  0A
0002:  GOTO   000
0003:  NOP
0004:  MOVWF  7F
0005:  SWAPF  03,W
0006:  CLRF   03
0007:  MOVWF  21
0008:  MOVF   0A,W
0009:  MOVWF  20
000A:  CLRF   0A
000B:  MOVF   04,W
000C:  MOVWF  22
000D:  MOVF   77,W
000E:  MOVWF  23
000F:  MOVF   78,W
0010:  MOVWF  24
0011:  MOVF   79,W
0012:  MOVWF  25
0013:  MOVF   7A,W
0014:  MOVWF  26
0015:  BSF    03.6
0016:  MOVF   0D,W
0017:  BCF    03.6
0018:  MOVWF  27
0019:  BSF    03.6
001A:  MOVF   0F,W
001B:  BCF    03.6
001C:  MOVWF  28
001D:  BSF    03.6
001E:  MOVF   0C,W
001F:  BCF    03.6
0020:  MOVWF  29
0021:  BSF    03.6
0022:  MOVF   0E,W
0023:  BCF    03.6
0024:  MOVWF  2A
0025:  BCF    03.7
0026:  BCF    03.5
0027:  MOVLW  8C
0028:  MOVWF  04
0029:  BTFSS  00.0
002A:  GOTO   02D
002B:  BTFSC  0C.0
002C:  GOTO   04E
002D:  MOVF   22,W
002E:  MOVWF  04
002F:  MOVF   23,W
0030:  MOVWF  77
0031:  MOVF   24,W
0032:  MOVWF  78
0033:  MOVF   25,W
0034:  MOVWF  79
0035:  MOVF   26,W
0036:  MOVWF  7A
0037:  MOVF   27,W
0038:  BSF    03.6
0039:  MOVWF  0D
003A:  BCF    03.6
003B:  MOVF   28,W
003C:  BSF    03.6
003D:  MOVWF  0F
003E:  BCF    03.6
003F:  MOVF   29,W
0040:  BSF    03.6
0041:  MOVWF  0C
0042:  BCF    03.6
0043:  MOVF   2A,W
0044:  BSF    03.6
0045:  MOVWF  0E
0046:  BCF    03.6
0047:  MOVF   20,W
0048:  MOVWF  0A
0049:  SWAPF  21,W
004A:  MOVWF  03
004B:  SWAPF  7F,F
004C:  SWAPF  7F,W
004D:  RETFIE
004E:  BCF    0A.3
004F:  BCF    0A.4
0050:  GOTO   051
.................... #include <16F886.h> 
.................... //////////// Standard Header file for the PIC16F886 device //////////////// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996, 2014 Custom Computer Services          //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... #device PIC16F886 
*
005F:  DATA 48,3D
0060:  DATA 00,00
0061:  DATA D7,22
0062:  DATA CC,21
0063:  DATA CF,26
0064:  DATA 45,00
0065:  DATA C3,2C
0066:  DATA C2,26
0067:  DATA C3,2C
0068:  DATA D3,29
0069:  DATA C2,29
006A:  DATA 53,27
006B:  DATA D4,26
006C:  DATA CD,21
006D:  DATA 00,01
006E:  DATA 42,2A
006F:  DATA B1,2F
0070:  DATA C6,22
0071:  DATA 51,00
0072:  DATA 48,3D
0073:  DATA 00,01
0074:  DATA 42,2A
0075:  DATA B2,2F
0076:  DATA C6,22
0077:  DATA 51,00
0078:  DATA 48,3D
0079:  DATA 00,01
007A:  DATA 42,2A
007B:  DATA B3,2F
007C:  DATA C6,22
007D:  DATA 51,00
007E:  DATA 48,3D
007F:  DATA 00,01
0080:  DATA 42,2A
0081:  DATA B4,2F
0082:  DATA C6,22
0083:  DATA 51,00
0084:  DATA 48,3D
0085:  DATA 00,01
0086:  DATA 42,2A
0087:  DATA B5,2F
0088:  DATA C6,22
0089:  DATA 51,00
008A:  DATA 48,3D
008B:  DATA 00,01
008C:  DATA 42,2A
008D:  DATA B6,2F
008E:  DATA C6,22
008F:  DATA 51,00
0090:  DATA 48,3D
0091:  DATA 00,01
0092:  DATA C6,22
0093:  DATA D1,2F
0094:  DATA D2,22
0095:  DATA D3,22
0096:  DATA 54,00
0097:  DATA 48,3D
0098:  DATA 00,01
0099:  DATA 42,2A
009A:  DATA B1,2F
009B:  DATA C6,22
009C:  DATA D1,2F
009D:  DATA D3,22
009E:  DATA 54,00
009F:  DATA 48,3D
00A0:  DATA 00,01
00A1:  DATA 42,2A
00A2:  DATA B2,2F
00A3:  DATA C6,22
00A4:  DATA D1,2F
00A5:  DATA D3,22
00A6:  DATA 54,00
00A7:  DATA 48,3D
00A8:  DATA 00,01
00A9:  DATA 42,2A
00AA:  DATA B3,2F
00AB:  DATA C6,22
00AC:  DATA D1,2F
00AD:  DATA D3,22
00AE:  DATA 54,00
00AF:  DATA 48,3D
00B0:  DATA 00,01
00B1:  DATA 42,2A
00B2:  DATA B4,2F
00B3:  DATA C6,22
00B4:  DATA D1,2F
00B5:  DATA D3,22
00B6:  DATA 54,00
00B7:  DATA 48,3D
00B8:  DATA 00,01
00B9:  DATA 42,2A
00BA:  DATA B5,2F
00BB:  DATA C6,22
00BC:  DATA D1,2F
00BD:  DATA D3,22
00BE:  DATA 54,00
00BF:  DATA 48,3D
00C0:  DATA 00,01
00C1:  DATA 42,2A
00C2:  DATA B6,2F
00C3:  DATA C6,22
00C4:  DATA D1,2F
00C5:  DATA D3,22
00C6:  DATA 54,00
00C7:  DATA 48,3D
00C8:  DATA 00,01
00C9:  DATA C3,2A
00CA:  DATA 52,29
00CB:  DATA 45,27
00CC:  DATA D4,2F
00CD:  DATA C6,22
00CE:  DATA 51,00
00CF:  DATA 48,3D
00D0:  DATA 00,01
00D1:  DATA F2,32
00D2:  DATA F3,32
00D3:  DATA 74,10
00D4:  DATA 70,39
00D5:  DATA E5,39
00D6:  DATA F3,32
00D7:  DATA 64,05
00D8:  DATA 00,00
00D9:  DATA 69,37
00DA:  DATA 63,10
00DB:  DATA 70,39
00DC:  DATA E5,39
00DD:  DATA F3,32
00DE:  DATA 64,05
00DF:  DATA 00,01
00E0:  DATA E4,32
00E1:  DATA 63,10
00E2:  DATA 70,39
00E3:  DATA E5,39
00E4:  DATA F3,32
00E5:  DATA 64,05
00E6:  DATA 00,01
00E7:  DATA F3,32
00E8:  DATA 74,10
00E9:  DATA 70,39
00EA:  DATA E5,39
00EB:  DATA F3,32
00EC:  DATA 64,05
00ED:  DATA 00,01
00EE:  DATA F3,32
00EF:  DATA 74,10
00F0:  DATA 70,39
00F1:  DATA E5,39
00F2:  DATA F3,32
00F3:  DATA 64,05
00F4:  DATA 00,01
00F5:  DATA F3,32
00F6:  DATA 74,10
00F7:  DATA 70,39
00F8:  DATA E5,39
00F9:  DATA F3,32
00FA:  DATA 64,05
00FB:  DATA 00,01
00FC:  DATA F3,32
00FD:  DATA 74,10
00FE:  DATA 70,39
00FF:  DATA E5,39
0100:  DATA F3,32
0101:  DATA 64,05
0102:  DATA 00,01
0103:  DATA F3,32
0104:  DATA 74,10
0105:  DATA 70,39
0106:  DATA E5,39
0107:  DATA F3,32
0108:  DATA 64,05
0109:  DATA 00,01
010A:  DATA F3,32
010B:  DATA 74,10
010C:  DATA 70,39
010D:  DATA E5,39
010E:  DATA F3,32
010F:  DATA 64,05
0110:  DATA 00,01
0111:  DATA 31,10
0112:  DATA 70,39
0113:  DATA E5,39
0114:  DATA F3,32
0115:  DATA 64,05
0116:  DATA 00,01
0117:  DATA 32,10
0118:  DATA 70,39
0119:  DATA E5,39
011A:  DATA F3,32
011B:  DATA 64,05
011C:  DATA 00,01
011D:  DATA 33,10
011E:  DATA 70,39
011F:  DATA E5,39
0120:  DATA F3,32
0121:  DATA 64,05
0122:  DATA 00,01
0123:  DATA 34,10
0124:  DATA 70,39
0125:  DATA E5,39
0126:  DATA F3,32
0127:  DATA 64,05
0128:  DATA 00,01
0129:  DATA 35,10
012A:  DATA 70,39
012B:  DATA E5,39
012C:  DATA F3,32
012D:  DATA 64,05
012E:  DATA 00,01
012F:  DATA 36,10
0130:  DATA 70,39
0131:  DATA E5,39
0132:  DATA F3,32
0133:  DATA 64,05
0134:  DATA 00,00
*
021A:  MOVF   0B,W
021B:  MOVWF  60
021C:  BCF    0B.7
021D:  BSF    03.5
021E:  BSF    03.6
021F:  BSF    0C.7
0220:  BSF    0C.0
0221:  NOP
0222:  NOP
0223:  BCF    03.5
0224:  BCF    03.6
0225:  BTFSC  60.7
0226:  BSF    0B.7
0227:  BSF    03.6
0228:  MOVF   0C,W
0229:  ANDLW  7F
022A:  BTFSC  03.2
022B:  GOTO   26E
022C:  BCF    03.6
022D:  MOVWF  60
022E:  BSF    03.6
022F:  MOVF   0D,W
0230:  BCF    03.6
0231:  MOVWF  61
0232:  BSF    03.6
0233:  MOVF   0F,W
0234:  BCF    03.6
0235:  MOVWF  62
0236:  MOVF   60,W
0237:  MOVWF  69
0238:  CALL   1EE
0239:  MOVF   61,W
023A:  BSF    03.6
023B:  MOVWF  0D
023C:  BCF    03.6
023D:  MOVF   62,W
023E:  BSF    03.6
023F:  MOVWF  0F
0240:  BCF    03.6
0241:  MOVF   0B,W
0242:  MOVWF  63
0243:  BCF    0B.7
0244:  BSF    03.5
0245:  BSF    03.6
0246:  BSF    0C.7
0247:  BSF    0C.0
0248:  NOP
0249:  NOP
024A:  BCF    03.5
024B:  BCF    03.6
024C:  BTFSC  63.7
024D:  BSF    0B.7
024E:  BSF    03.6
024F:  RLF    0C,W
0250:  RLF    0E,W
0251:  ANDLW  7F
0252:  BTFSC  03.2
0253:  GOTO   26E
0254:  BCF    03.6
0255:  MOVWF  60
0256:  BSF    03.6
0257:  MOVF   0D,W
0258:  BCF    03.6
0259:  MOVWF  61
025A:  BSF    03.6
025B:  MOVF   0F,W
025C:  BCF    03.6
025D:  MOVWF  62
025E:  MOVF   60,W
025F:  MOVWF  69
0260:  CALL   1EE
0261:  MOVF   61,W
0262:  BSF    03.6
0263:  MOVWF  0D
0264:  BCF    03.6
0265:  MOVF   62,W
0266:  BSF    03.6
0267:  MOVWF  0F
0268:  INCF   0D,F
0269:  BTFSC  03.2
026A:  INCF   0F,F
026B:  BCF    03.6
026C:  GOTO   21A
026D:  BSF    03.6
026E:  BCF    03.6
026F:  RETURN
0270:  CLRF   68
0271:  MOVF   04,W
0272:  MOVWF  67
0273:  BCF    68.0
0274:  BTFSC  03.7
0275:  BSF    68.0
0276:  SWAPF  61,W
0277:  IORLW  F0
0278:  MOVWF  63
0279:  ADDWF  63,F
027A:  ADDLW  E2
027B:  MOVWF  64
027C:  ADDLW  32
027D:  MOVWF  66
027E:  MOVF   61,W
027F:  ANDLW  0F
0280:  ADDWF  64,F
0281:  ADDWF  64,F
0282:  ADDWF  66,F
0283:  ADDLW  E9
0284:  MOVWF  65
0285:  ADDWF  65,F
0286:  ADDWF  65,F
0287:  SWAPF  60,W
0288:  ANDLW  0F
0289:  ADDWF  65,F
028A:  ADDWF  66,F
028B:  RLF    65,F
028C:  RLF    66,F
028D:  COMF   66,F
028E:  RLF    66,F
028F:  MOVF   60,W
0290:  ANDLW  0F
0291:  ADDWF  66,F
0292:  RLF    63,F
0293:  MOVLW  07
0294:  MOVWF  62
0295:  MOVLW  0A
0296:  ADDWF  66,F
0297:  DECF   65,F
0298:  BTFSS  03.0
0299:  GOTO   296
029A:  ADDWF  65,F
029B:  DECF   64,F
029C:  BTFSS  03.0
029D:  GOTO   29A
029E:  ADDWF  64,F
029F:  DECF   63,F
02A0:  BTFSS  03.0
02A1:  GOTO   29E
02A2:  ADDWF  63,F
02A3:  DECF   62,F
02A4:  BTFSS  03.0
02A5:  GOTO   2A2
02A6:  MOVLW  62
02A7:  MOVWF  04
02A8:  BCF    03.7
02A9:  MOVLW  07
02AA:  ANDWF  67,W
02AB:  BCF    67.6
02AC:  ADDWF  04,F
02AD:  MOVLW  66
02AE:  SUBWF  04,W
02AF:  BTFSC  03.2
02B0:  BSF    67.6
02B1:  MOVF   00,W
02B2:  MOVWF  77
02B3:  BTFSS  03.2
02B4:  GOTO   2BD
02B5:  BTFSC  67.6
02B6:  GOTO   2BD
02B7:  BTFSC  67.4
02B8:  GOTO   2CF
02B9:  BTFSC  67.3
02BA:  GOTO   2BD
02BB:  MOVLW  20
02BC:  GOTO   2C0
02BD:  BSF    67.3
02BE:  BCF    67.4
02BF:  MOVLW  30
02C0:  ADDWF  77,F
02C1:  CLRF   61
02C2:  MOVF   04,W
02C3:  MOVWF  60
02C4:  BCF    61.0
02C5:  BTFSC  03.7
02C6:  BSF    61.0
02C7:  MOVF   77,W
02C8:  MOVWF  69
02C9:  CALL   1EE
02CA:  MOVF   60,W
02CB:  MOVWF  04
02CC:  BCF    03.7
02CD:  BTFSC  61.0
02CE:  BSF    03.7
02CF:  INCF   04,F
02D0:  BTFSS  67.6
02D1:  GOTO   2AD
02D2:  RETURN
*
02EC:  MOVF   0B,W
02ED:  MOVWF  5E
02EE:  BCF    0B.7
02EF:  BSF    03.5
02F0:  BSF    03.6
02F1:  BSF    0C.7
02F2:  BSF    0C.0
02F3:  NOP
02F4:  NOP
02F5:  BCF    03.5
02F6:  BCF    03.6
02F7:  BTFSC  5E.7
02F8:  BSF    0B.7
02F9:  BSF    03.6
02FA:  MOVF   0C,W
02FB:  ANDLW  7F
02FC:  BTFSC  03.2
02FD:  GOTO   342
02FE:  BCF    03.6
02FF:  MOVWF  5E
0300:  BSF    03.6
0301:  MOVF   0D,W
0302:  BCF    03.6
0303:  MOVWF  5F
0304:  BSF    03.6
0305:  MOVF   0F,W
0306:  BCF    03.6
0307:  MOVWF  60
0308:  MOVF   5E,W
0309:  BTFSS  0C.4
030A:  GOTO   309
030B:  MOVWF  19
030C:  MOVF   5F,W
030D:  BSF    03.6
030E:  MOVWF  0D
030F:  BCF    03.6
0310:  MOVF   60,W
0311:  BSF    03.6
0312:  MOVWF  0F
0313:  BCF    03.6
0314:  MOVF   0B,W
0315:  MOVWF  61
0316:  BCF    0B.7
0317:  BSF    03.5
0318:  BSF    03.6
0319:  BSF    0C.7
031A:  BSF    0C.0
031B:  NOP
031C:  NOP
031D:  BCF    03.5
031E:  BCF    03.6
031F:  BTFSC  61.7
0320:  BSF    0B.7
0321:  BSF    03.6
0322:  RLF    0C,W
0323:  RLF    0E,W
0324:  ANDLW  7F
0325:  BTFSC  03.2
0326:  GOTO   342
0327:  BCF    03.6
0328:  MOVWF  5E
0329:  BSF    03.6
032A:  MOVF   0D,W
032B:  BCF    03.6
032C:  MOVWF  5F
032D:  BSF    03.6
032E:  MOVF   0F,W
032F:  BCF    03.6
0330:  MOVWF  60
0331:  MOVF   5E,W
0332:  BTFSS  0C.4
0333:  GOTO   332
0334:  MOVWF  19
0335:  MOVF   5F,W
0336:  BSF    03.6
0337:  MOVWF  0D
0338:  BCF    03.6
0339:  MOVF   60,W
033A:  BSF    03.6
033B:  MOVWF  0F
033C:  INCF   0D,F
033D:  BTFSC  03.2
033E:  INCF   0F,F
033F:  BCF    03.6
0340:  GOTO   2EC
0341:  BSF    03.6
0342:  BCF    03.6
0343:  RETURN
*
035E:  BTFSC  03.1
035F:  GOTO   363
0360:  MOVLW  6A
0361:  MOVWF  04
0362:  BCF    03.7
0363:  CLRF   77
0364:  CLRF   78
0365:  CLRF   79
0366:  CLRF   7A
0367:  CLRF   6A
0368:  CLRF   6B
0369:  CLRF   6C
036A:  CLRF   6D
036B:  MOVF   69,W
036C:  IORWF  68,W
036D:  IORWF  67,W
036E:  IORWF  66,W
036F:  BTFSC  03.2
0370:  GOTO   3A1
0371:  MOVLW  20
0372:  MOVWF  6E
0373:  BCF    03.0
0374:  RLF    62,F
0375:  RLF    63,F
0376:  RLF    64,F
0377:  RLF    65,F
0378:  RLF    6A,F
0379:  RLF    6B,F
037A:  RLF    6C,F
037B:  RLF    6D,F
037C:  MOVF   69,W
037D:  SUBWF  6D,W
037E:  BTFSS  03.2
037F:  GOTO   38A
0380:  MOVF   68,W
0381:  SUBWF  6C,W
0382:  BTFSS  03.2
0383:  GOTO   38A
0384:  MOVF   67,W
0385:  SUBWF  6B,W
0386:  BTFSS  03.2
0387:  GOTO   38A
0388:  MOVF   66,W
0389:  SUBWF  6A,W
038A:  BTFSS  03.0
038B:  GOTO   39B
038C:  MOVF   66,W
038D:  SUBWF  6A,F
038E:  MOVF   67,W
038F:  BTFSS  03.0
0390:  INCFSZ 67,W
0391:  SUBWF  6B,F
0392:  MOVF   68,W
0393:  BTFSS  03.0
0394:  INCFSZ 68,W
0395:  SUBWF  6C,F
0396:  MOVF   69,W
0397:  BTFSS  03.0
0398:  INCFSZ 69,W
0399:  SUBWF  6D,F
039A:  BSF    03.0
039B:  RLF    77,F
039C:  RLF    78,F
039D:  RLF    79,F
039E:  RLF    7A,F
039F:  DECFSZ 6E,F
03A0:  GOTO   373
03A1:  MOVF   6A,W
03A2:  MOVWF  00
03A3:  INCF   04,F
03A4:  MOVF   6B,W
03A5:  MOVWF  00
03A6:  INCF   04,F
03A7:  MOVF   6C,W
03A8:  MOVWF  00
03A9:  INCF   04,F
03AA:  MOVF   6D,W
03AB:  MOVWF  00
*
0DF3:  BSF    0A.0
0DF4:  BCF    0A.1
0DF5:  BSF    0A.2
0DF6:  ADDWF  02,F
0DF7:  GOTO   494
0DF8:  GOTO   4AF
0DF9:  GOTO   4CA
0DFA:  GOTO   4E5
0DFB:  GOTO   500
0DFC:  GOTO   51B
....................  
.................... #list 
....................  
.................... #device ADC=10 *=16 
....................  
.................... #FUSES NOWDT                    //No Watch Dog Timer 
.................... #FUSES PUT                      //Power Up Timer 
.................... #FUSES NOMCLR                   //Master Clear pin not enabled 
.................... #FUSES NOPROTECT                //Code not protected from reading 
.................... #FUSES NOCPD                    //No EE protection 
.................... #FUSES BROWNOUT                 //Brownout reset 
.................... #FUSES IESO                     //Internal External Switch Over mode enabled 
.................... #FUSES FCMEN                    //Fail-safe clock monitor enabled 
.................... #FUSES NOLVP                    //No low voltage prgming, B3(PIC16) or B5(PIC18) used for I/O 
.................... #FUSES NODEBUG                  //No Debug mode for ICD 
.................... #FUSES NOWRT                    //Program memory not write protected 
.................... #FUSES BORV40                   //Brownout reset at 4.0V 
.................... #FUSES RESERVED                 //Used to set the reserved FUSE bits 
.................... #FUSES INTRC_IO  
....................  
.................... #use delay(clock=8M) 
*
0135:  MOVLW  6A
0136:  MOVWF  04
0137:  BCF    03.7
0138:  MOVF   00,W
0139:  BTFSC  03.2
013A:  GOTO   148
013B:  MOVLW  02
013C:  MOVWF  78
013D:  CLRF   77
013E:  DECFSZ 77,F
013F:  GOTO   13E
0140:  DECFSZ 78,F
0141:  GOTO   13D
0142:  MOVLW  97
0143:  MOVWF  77
0144:  DECFSZ 77,F
0145:  GOTO   144
0146:  DECFSZ 00,F
0147:  GOTO   13B
0148:  RETURN
....................  
.................... #use rs232(baud=9600,parity=N,xmit=PIN_C6,rcv=PIN_C7,bits=8) 
....................  
.................... #define RUN_BUTTON   PIN_B7 
.................... #define _FLEX_LCD216_H  //  LCD Type 16x2 
.................... //#define _FLEX_LCD416_H  //  LCD Type 16x4 
.................... // Assign MCU's pin to LCD 
.................... #define LCD_DB4   PIN_A0 
.................... #define LCD_DB5   PIN_A1 
.................... #define LCD_DB6   PIN_A2 
.................... #define LCD_DB7   PIN_A3 
.................... #define LCD_RS    PIN_C1 
.................... #define LCD_E     PIN_A5 
....................  
.................... #include <stdio.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDIO 
.................... #define _STDIO 
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) || defined(__PCM__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *memmove(void *s1,void *s2,size_t n) 
.................... { 
....................    unsigned char *sc1; 
....................    unsigned char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *strncpy(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................   unsigned char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... unsigned char *strcat(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... unsigned char *strncat(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,void *s2,size_t n) 
.................... { 
.................... unsigned char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1, returns number of chars written ot s1. 
....................    if s1 is NULL and n is 0, then it returns the length of s2.*/ 
.................... size_t strxfrm(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char c; 
....................    unsigned int8 n1; 
....................     
....................    if (!s1 && !n) 
....................       n = -1; //find length 
....................  
....................    n1 = 0; 
....................     
....................    for (; n1 < n; n1++) 
....................    { 
....................       c = *s2++; 
....................       if (!c) 
....................          break; 
....................       if (s1) 
....................          *s1++ = c; 
....................    } 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... unsigned char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    unsigned char uc; 
....................    unsigned char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... unsigned char *strchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... unsigned char *strpbrk(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... unsigned char *strrchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... unsigned char *strstr(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... size_t strlen(unsigned char *s) 
.................... { 
....................    unsigned char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... unsigned char *strtok(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *beg, *end; 
....................    static char *save; 
*
082A:  BCF    03.6
082B:  CLRF   2B
082C:  CLRF   2C
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................       return(0); 
....................        
....................    end = strpbrk(beg, s2); 
....................    if (end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................       save = end; 
....................    } 
....................    else 
....................       save = beg + strlen(beg); 
....................     
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... unsigned char * strerror(unsigned int8 errnum) 
.................... { 
.................... static unsigned char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strlwr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strupr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
.................... #ifndef getc 
.................... #define getc getch 
.................... #define getchar getch 
.................... #define puts(s) {printf(s); putchar(13); putchar(10);} 
.................... #define putc putchar 
.................... #endif 
.................... /* maps error number to an error message. Writes a sequence of characters to 
.................... stderr stream thus: if s is not null then string pointed to by s follwed by 
.................... a colon (:) and a space and the appropriate error message returned by strerror 
.................... function with argument errno 
....................  
.................... Returns: no value 
.................... */ 
....................  
.................... #ifdef _ERRNO 
.................... void perror(char *s) 
.................... { 
....................   if(s) 
....................   fprintf(STDERR,"%s: ",s); 
....................   fprintf(STDERR,"%s\r\n",strerror(errno)); 
.................... } 
.................... #endif 
.................... #endif 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... #include <ctype.h> 
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *memmove(void *s1,void *s2,size_t n) 
.................... { 
....................    unsigned char *sc1; 
....................    unsigned char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *strncpy(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................   unsigned char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... unsigned char *strcat(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... unsigned char *strncat(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,void *s2,size_t n) 
.................... { 
.................... unsigned char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1, returns number of chars written ot s1. 
....................    if s1 is NULL and n is 0, then it returns the length of s2.*/ 
.................... size_t strxfrm(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char c; 
....................    unsigned int8 n1; 
....................     
....................    if (!s1 && !n) 
....................       n = -1; //find length 
....................  
....................    n1 = 0; 
....................     
....................    for (; n1 < n; n1++) 
....................    { 
....................       c = *s2++; 
....................       if (!c) 
....................          break; 
....................       if (s1) 
....................          *s1++ = c; 
....................    } 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... unsigned char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    unsigned char uc; 
....................    unsigned char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... unsigned char *strchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... unsigned char *strpbrk(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... unsigned char *strrchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... unsigned char *strstr(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... size_t strlen(unsigned char *s) 
.................... { 
....................    unsigned char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... unsigned char *strtok(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................       return(0); 
....................        
....................    end = strpbrk(beg, s2); 
....................    if (end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................       save = end; 
....................    } 
....................    else 
....................       save = beg + strlen(beg); 
....................     
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... unsigned char * strerror(unsigned int8 errnum) 
.................... { 
.................... static unsigned char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strlwr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strupr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
.................... #include <stdlib.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2007 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
....................  
.................... #ifndef _STDLIB 
.................... #define _STDLIB 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Definitions and types 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #ifndef RAND_MAX 
.................... #define RAND_MAX  32767    // The value of which is the maximum value 
....................                            // ... returned by the rand function 
.................... #endif 
....................  
....................  
.................... #IF (sizeof(int16*)>1) 
.................... #DEFINE LONG_POINTERS 1 
.................... #ELSE  
.................... #DEFINE LONG_POINTERS 0 
.................... #ENDIF 
....................  
.................... typedef struct { 
....................    signed int quot; 
....................    signed int rem; 
.................... } div_t; 
....................  
.................... typedef struct { 
....................    signed long quot; 
....................    signed long rem; 
.................... } ldiv_t; 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) || defined(__PCM__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // String conversion functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Standard template: signed int  atoi(char * s) 
....................  * converts the initial portion of the string s to a signed int 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed int atoi(char *s); 
....................  
.................... /* Syntax: signed int32  atoi32(char * s) 
....................    converts the initial portion of the string s to a signed int32 
....................    returns the converted value if any, 0 otherwise*/ 
.................... #if (sizeof(long)==4) 
....................  #define atoi32(s) atol(s) 
.................... #else  
....................  signed int32 atoi32(char *s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
.................... /* Syntax: signed int48  atoi48(char * s) 
....................    converts the initial portion of the string s to a signed int48 
....................    returns the converted value if any, 0 otherwise*/ 
....................     
.................... signed int48 atoi48(char *s); 
....................  
.................... /* Syntax: signed int64  atoi64(char * s) 
....................    converts the initial portion of the string s to a signed int64 
....................    returns the converted value if any, 0 otherwise*/ 
.................... signed int64 atoi64(char *s); 
.................... #endif 
....................  
.................... /* Syntax: char *  itoa(signed int32 num, int8 base, char * s) 
....................    converts the signed int32 to a string and 
....................    returns the converted value if any, 0 otherwise*/ 
.................... char * itoa(signed int32 num, unsigned int base, char * s); 
....................  
.................... /* Standard template: signed int16  atol(char * s) 
....................  * converts the initial portion of the string s to a signed int16 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed long atol(char *s); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base  to a signed long. 
....................  * Returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... signed long strtol(char *s,char *endptr, signed int base); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base to a unsigned long. 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... unsigned long strtoul(char *s,char *endptr, signed int base); 
....................  
.................... /* Standart template: float strtof(char * s,char *endptr) 
....................                       float48 strtof48(char *s,char *endptr); 
....................                       float64 strtod(char *s,char *endptr); 
....................  * converts the initial portion of the string s to a float32, float48 or float64, 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null                    
.................... */ 
.................... float strtof(char *s,char **endptr); 
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s,char **endptr); 
.................... float64 strtod(char *s,char **endptr); 
.................... #else 
.................... //provided for compatibility 
.................... #define strtof48(s, e) strtof(s, e) 
.................... #define strtod(s, e) strtof(s, e) 
.................... #endif 
....................  
.................... /* Standard template: float32 atof(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof(s)   strtof(s, (char*)0) 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
....................  
.................... /* Standard template: float48 atof48(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof48(s) strtof48(s, 0) 
....................  
.................... /* Standard template: float64 atof64(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof64(s) strtod(s, 0) 
.................... #endif 
....................  
.................... /* Standard template: float32 atoe(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  * also handles E format numbers 
....................  */ 
.................... #if !defined(__PCD__) 
.................... float atoe(char * s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s); 
.................... #endif 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Pseudo-random sequence generation functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The rand function computes a sequence of pseudo-random integers in 
....................  * the range 0 to RAND_MAX 
....................  * 
....................  * Parameters: 
....................  *       (none) 
....................  * 
....................  * Returns: 
....................  *       The pseudo-random integer 
....................  */ 
.................... unsigned int16 rand(void); 
....................  
.................... /* The srand function uses the argument as a seed for a new sequence of 
....................  * pseudo-random numbers to be returned by subsequent calls to rand. 
....................  * 
....................  * Parameters: 
....................  *       [in] seed: The seed value to start from. You might need to pass 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  * 
....................  * Remarks 
....................  *          The srand function sets the starting point for generating 
....................  *       a series of pseudorandom integers. To reinitialize the 
....................  *       generator, use 1 as the seed argument. Any other value for 
....................  *       seed sets the generator to a random starting point. rand 
....................  *       retrieves the pseudorandom numbers that are generated. 
....................  *       Calling rand before any call to srand generates the same 
....................  *       sequence as calling srand with seed passed as 1. 
....................  *          Usually, you need to pass a time here from outer source 
....................  *       so that the numbers will be different every time you run. 
....................  */ 
.................... void srand(unsigned int32 seed); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Memory management functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Comming soon 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Communication with the environment 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The function returns 0 always 
....................  */ 
.................... signed int8 system(char *string); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Performs a binary search of a sorted array.. 
....................  * 
....................  * Parameters: 
....................  *       [in] key: Object to search for 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       bsearch returns a pointer to an occurrence of key in the array pointed 
....................  *       to by base. If key is not found, the function returns NULL. If the 
....................  *       array is not in order or contains duplicate records with identical keys, 
....................  *       the result is unpredictable. 
....................  */ 
.................... //void *bsearch(const void *key, const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... /* Performs the shell-metzner sort (not the quick sort algorithm). The contents 
....................  * of the array are sorted into ascending order according to a comparison 
....................  * function pointed to by compar. 
....................  * 
....................  * Parameters: 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  */ 
.................... //void *qsort(const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Integer arithmetic functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #define labs abs 
....................  
.................... div_t div(signed int numer, signed int denom); 
.................... ldiv_t ldiv(signed long numer, signed long denom); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte character functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte string functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Internal implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) || defined(__PCM__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... #include <ctype.h> 
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *memmove(void *s1,void *s2,size_t n) 
.................... { 
....................    unsigned char *sc1; 
....................    unsigned char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *strncpy(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................   unsigned char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... unsigned char *strcat(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... unsigned char *strncat(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,void *s2,size_t n) 
.................... { 
.................... unsigned char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1, returns number of chars written ot s1. 
....................    if s1 is NULL and n is 0, then it returns the length of s2.*/ 
.................... size_t strxfrm(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char c; 
....................    unsigned int8 n1; 
....................     
....................    if (!s1 && !n) 
....................       n = -1; //find length 
....................  
....................    n1 = 0; 
....................     
....................    for (; n1 < n; n1++) 
....................    { 
....................       c = *s2++; 
....................       if (!c) 
....................          break; 
....................       if (s1) 
....................          *s1++ = c; 
....................    } 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... unsigned char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    unsigned char uc; 
....................    unsigned char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... unsigned char *strchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... unsigned char *strpbrk(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... unsigned char *strrchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... unsigned char *strstr(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... size_t strlen(unsigned char *s) 
.................... { 
....................    unsigned char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... unsigned char *strtok(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................       return(0); 
....................        
....................    end = strpbrk(beg, s2); 
....................    if (end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................       save = end; 
....................    } 
....................    else 
....................       save = beg + strlen(beg); 
....................     
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... unsigned char * strerror(unsigned int8 errnum) 
.................... { 
.................... static unsigned char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strlwr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strupr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
.................... div_t div(signed int numer, signed int denom) 
.................... { 
....................    div_t val; 
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... ldiv_t ldiv(signed long numer, signed long denom) 
.................... { 
....................    ldiv_t val; 
....................  
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s) 
.................... { 
....................    float32 pow10 = 1.0; 
....................    float32 result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float32 exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if !defined(__PCD__) 
.................... float atoe(char * s) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... signed int atoi(char *s) 
.................... { 
....................    signed int result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    // Omit all preceeding alpha characters 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................  
....................       // Check for hexa number 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c<='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++]; 
....................             c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (sign == 1 && base == 10) 
....................        result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed long atol(char *s) 
.................... { 
....................    signed long result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... /* A fast routine to multiply by 10 
....................  */ 
.................... signed int32 mult_with10(int32 num) 
.................... { 
....................    return ( (num << 1) + (num << 3) ); 
.................... } 
....................  
.................... #if sizeof(long)==2 
.................... signed int32 atoi32(char *s) 
.................... { 
....................    signed int32 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
....................  
.................... signed int48 atoi48(char *s) 
.................... { 
....................    signed int48 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed int64 atoi64(char *s) 
.................... { 
....................    signed int64 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... char * itoa(signed int32 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int32 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #if defined(__PCD__) 
....................  
.................... char * itoa(signed int48 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int48 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... char * itoa(signed int64 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int64 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................       
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1;         
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................              
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #endif 
....................  
.................... float strtof(char *s, char **endptr) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s, char **endptr) 
.................... { 
....................    float48 pow10 = 1.0; 
....................    float48 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float48)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float48)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... float64 strtod(char *s, char **endptr) 
.................... { 
....................    float64 pow10 = 1.0; 
....................    float64 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float64)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float64)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... unsigned long strtoul(char *s, char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    unsigned long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if(sign=='-' || base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtoulGO; 
....................  
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(; sd!=0; ) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtoulGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................          } 
....................    return 0; 
....................    } 
....................    if (endptr) 
....................    { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................          #ELSE 
....................          *((char *)endptr)=sc;  
....................          #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
....................  
.................... signed long strtol(char *s,char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    signed long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if (base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtolGO; 
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................  
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(;sd!=0;) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtolGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................       } 
....................    return 0; 
....................    } 
....................    if(sign=='-') 
....................       x  =-x; 
....................    if (endptr) 
....................    { 
....................         #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................         #ELSE 
....................         *((char *)endptr)=sc; 
....................         #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
.................... signed int8 system(char *string) 
.................... { 
....................    return 0; 
.................... } 
....................  
.................... size_t mblen(char *s,size_t n) 
.................... { 
....................    return strlen(s); 
.................... } 
....................  
.................... int8 mbtowc(wchar_t *pwc,char *s,size_t n) 
.................... { 
....................    *pwc=*s; 
....................    return 1; 
.................... } 
....................  
.................... int8 wctomb(char *s,wchar_t wchar) 
.................... { 
....................    *s=wchar; 
....................    return 1; 
.................... } 
....................  
.................... size_t mbstowcs(wchar_t *pwcs,char *s,size_t n) 
.................... { 
....................    strncpy(pwcs,s,n); 
....................    return strlen(pwcs); 
.................... } 
....................  
.................... size_t wcstombs(char *s,wchar_t *pwcs,size_t n) 
.................... { 
....................    strncpy(s,pwcs,n); 
....................    return strlen(s); 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // The random number implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... unsigned int32 _Randseed; 
....................  
.................... unsigned int16 rand(void) 
.................... { 
....................    _Randseed = _Randseed * 1103515245 + 12345; 
....................    return ((unsigned int16)(_Randseed >> 16) % RAND_MAX); 
.................... } 
....................  
.................... void srand(unsigned int32 seed) 
.................... { 
....................    _Randseed = seed; 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #if !defined(__PCD__) 
.................... typedef signed int8 (*_Cmpfun)(char * p1,char * p2);  
.................... #else  
.................... typedef signed int16 (*_Cmpfun)(char * p1,char * p2);  
.................... #endif 
....................  
....................  
....................  
.................... void qsort(char * qdata, unsigned int qitems, unsigned int qsize, _Cmpfun cmp) { 
....................    unsigned int m,j,i,l; 
....................    int1 done; 
....................    unsigned int8 t[16]; 
....................  
....................    m = qitems/2; 
....................    while( m > 0 ) { 
....................      for(j=0; j<(qitems-m); ++j) { 
....................         i = j; 
....................         do 
....................         { 
....................            done=1; 
....................            l = i+m; 
....................            if( (*cmp)(qdata+i*qsize, qdata+l*qsize) > 0 ) { 
....................               memcpy(t, qdata+i*qsize, qsize); 
....................               memcpy(qdata+i*qsize, qdata+l*qsize, qsize); 
....................               memcpy(qdata+l*qsize, t, qsize); 
....................               if(m <= i) 
....................                 i -= m; 
....................                 done = 0; 
....................            } 
....................         } while(!done); 
....................      } 
....................      m = m/2; 
....................    } 
.................... } 
....................  
....................  
.................... char *bsearch(char *key, char *base, size_t num, size_t width,_Cmpfun cmp) 
.................... { 
....................    char *p, *q; 
....................    size_t n; 
....................    size_t pivot; 
....................    signed int val; 
....................  
....................    p = base; 
....................    n = num; 
....................  
....................    while (n > 0) 
....................    { 
....................       pivot = n >> 1; 
....................       q = p + width * pivot; 
....................  
....................       val = (*cmp)(key, q); 
....................  
....................       if (val < 0) 
....................          n = pivot; 
....................       else if (val == 0) 
....................          return ((char *)q); 
....................       else { 
....................          p = q + width; 
....................          n -= pivot + 1; 
....................       } 
....................    } 
....................  
....................    return NULL;      // There's no match 
.................... } 
....................  
....................  
.................... #endif 
....................  
.................... #include <lcd.c> 
.................... /////////////////////////////////////////////////////////////////////////////// 
.................... ////                             LCD.C                                     //// 
.................... ////                 Driver for common LCD modules                         //// 
.................... ////                                                                       //// 
.................... ////  lcd_init()   Must be called before any other function.               //// 
.................... ////                                                                       //// 
.................... ////  lcd_putc(c)  Will display c on the next position of the LCD.         //// 
.................... ////                 \a  Set cursor position to upper left                 //// 
.................... ////                 \f  Clear display, set cursor to upper left           //// 
.................... ////                 \n  Go to start of second line                        //// 
.................... ////                 \b  Move back one position                            //// 
.................... ////              If LCD_EXTENDED_NEWLINE is defined, the \n character     //// 
.................... ////              will erase all remanining characters on the current      //// 
.................... ////              line, and move the cursor to the beginning of the next   //// 
.................... ////              line.                                                    //// 
.................... ////              If LCD_EXTENDED_NEWLINE is defined, the \r character     //// 
.................... ////              will move the cursor to the start of the current         //// 
.................... ////              line.                                                    //// 
.................... ////                                                                       //// 
.................... ////  lcd_gotoxy(x,y) Set write position on LCD (upper left is 1,1)        //// 
.................... ////                                                                       //// 
.................... ////  lcd_getc(x,y)   Returns character at position x,y on LCD             //// 
.................... ////                                                                       //// 
.................... ////  lcd_cursor_on(int1 on)   Turn the cursor on (on=TRUE) or off         //// 
.................... ////              (on=FALSE).                                              //// 
.................... ////                                                                       //// 
.................... ////  lcd_set_cgram_char(w, *p)   Write a custom character to the CGRAM.   //// 
.................... ////                                                                       //// 
.................... ////                                                                       //// 
.................... ////  CONFIGURATION                                                        //// 
.................... ////  The LCD can be configured in one of two ways: a.) port access or     //// 
.................... ////  b.) pin access.  Port access requires the entire 7 bit interface     //// 
.................... ////  connected to one GPIO port, and the data bits (D4:D7 of the LCD)     //// 
.................... ////  connected to sequential pins on the GPIO.  Pin access                //// 
.................... ////  has no requirements, all 7 bits of the control interface can         //// 
.................... ////  can be connected to any GPIO using several ports.                    //// 
.................... ////                                                                       //// 
.................... ////  To use port access, #define LCD_DATA_PORT to the SFR location of     //// 
.................... ////  of the GPIO port that holds the interface, -AND- edit LCD_PIN_MAP    //// 
.................... ////  of this file to configure the pin order.  If you are using a         //// 
.................... ////  baseline PIC (PCB), then LCD_OUTPUT_MAP and LCD_INPUT_MAP also must  //// 
.................... ////  be defined.                                                          //// 
.................... ////                                                                       //// 
.................... ////  Example of port access:                                              //// 
.................... ////     #define LCD_DATA_PORT getenv("SFR:PORTD")                         //// 
.................... ////                                                                       //// 
.................... ////  To use pin access, the following pins must be defined:               //// 
.................... ////     LCD_ENABLE_PIN                                                    //// 
.................... ////     LCD_RS_PIN                                                        //// 
.................... ////     LCD_RW_PIN                                                        //// 
.................... ////     LCD_DATA4                                                         //// 
.................... ////     LCD_DATA5                                                         //// 
.................... ////     LCD_DATA6                                                         //// 
.................... ////     LCD_DATA7                                                         //// 
.................... ////                                                                       //// 
.................... ////  Example of pin access:                                               //// 
.................... ////     #define LCD_ENABLE_PIN  PIN_E0                                    //// 
.................... ////     #define LCD_RS_PIN      PIN_E1                                    //// 
.................... ////     #define LCD_RW_PIN      PIN_E2                                    //// 
.................... ////     #define LCD_DATA4       PIN_D4                                    //// 
.................... ////     #define LCD_DATA5       PIN_D5                                    //// 
.................... ////     #define LCD_DATA6       PIN_D6                                    //// 
.................... ////     #define LCD_DATA7       PIN_D7                                    //// 
.................... ////                                                                       //// 
.................... /////////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2010 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef __LCD_C__ 
.................... #define __LCD_C__ 
....................  
.................... // define the pinout. 
.................... // only required if port access is being used. 
.................... typedef struct   
.................... {                            // This structure is overlayed 
....................    int1 enable;           // on to an I/O port to gain 
....................    int1 rs;               // access to the LCD pins. 
....................    int1 rw;               // The bits are allocated from 
....................    int1 unused;           // low order up.  ENABLE will 
....................    unsigned int     data : 4;         // be LSB pin of that port. 
....................   #if defined(__PCD__)       // The port used will be LCD_DATA_PORT. 
....................    unsigned int    reserved: 8; 
....................   #endif 
.................... } LCD_PIN_MAP; 
....................  
.................... // this is to improve compatability with previous LCD drivers that accepted 
.................... // a define labeled 'use_portb_lcd' that configured the LCD onto port B. 
.................... #if ((defined(use_portb_lcd)) && (use_portb_lcd==TRUE)) 
....................  #define LCD_DATA_PORT getenv("SFR:PORTB") 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
....................    // these definitions only need to be modified for baseline PICs. 
....................    // all other PICs use LCD_PIN_MAP or individual LCD_xxx pin definitions. 
.................... /*                                    EN, RS,   RW,   UNUSED,  DATA  */ 
....................  const LCD_PIN_MAP LCD_OUTPUT_MAP =  {0,  0,    0,    0,       0}; 
....................  const LCD_PIN_MAP LCD_INPUT_MAP =   {0,  0,    0,    0,       0xF}; 
.................... #endif 
....................  
.................... ////////////////////// END CONFIGURATION /////////////////////////////////// 
....................  
.................... #ifndef LCD_ENABLE_PIN 
....................    #define lcd_output_enable(x) lcdlat.enable=x 
....................    #define lcd_enable_tris()   lcdtris.enable=0 
.................... #else 
....................    #define lcd_output_enable(x) output_bit(LCD_ENABLE_PIN, x) 
....................    #define lcd_enable_tris()  output_drive(LCD_ENABLE_PIN) 
.................... #endif 
....................  
.................... #ifndef LCD_RS_PIN 
....................    #define lcd_output_rs(x) lcdlat.rs=x 
....................    #define lcd_rs_tris()   lcdtris.rs=0 
.................... #else 
....................    #define lcd_output_rs(x) output_bit(LCD_RS_PIN, x) 
....................    #define lcd_rs_tris()  output_drive(LCD_RS_PIN) 
.................... #endif 
....................  
.................... #ifndef LCD_RW_PIN 
....................    #define lcd_output_rw(x) lcdlat.rw=x 
....................    #define lcd_rw_tris()   lcdtris.rw=0 
.................... #else 
....................    #define lcd_output_rw(x) output_bit(LCD_RW_PIN, x) 
....................    #define lcd_rw_tris()  output_drive(LCD_RW_PIN) 
.................... #endif 
....................  
.................... // original version of this library incorrectly labeled LCD_DATA0 as LCD_DATA4, 
.................... // LCD_DATA1 as LCD_DATA5, and so on.  this block of code makes the driver 
.................... // compatible with any code written for the original library 
.................... #if (defined(LCD_DATA0) && defined(LCD_DATA1) && defined(LCD_DATA2) && defined(LCD_DATA3) && !defined(LCD_DATA4) && !defined(LCD_DATA5) && !defined(LCD_DATA6) && !defined(LCD_DATA7)) 
....................    #define  LCD_DATA4    LCD_DATA0 
....................    #define  LCD_DATA5    LCD_DATA1 
....................    #define  LCD_DATA6    LCD_DATA2 
....................    #define  LCD_DATA7    LCD_DATA3 
.................... #endif 
....................  
.................... #ifndef LCD_DATA4 
.................... #ifndef LCD_DATA_PORT 
....................    #if defined(__PCB__) 
....................       #define LCD_DATA_PORT      0x06     //portb 
....................       #define set_tris_lcd(x)   set_tris_b(x) 
....................    #else 
....................      #if defined(PIN_D0) 
....................       #define LCD_DATA_PORT      getenv("SFR:PORTD")     //portd 
....................      #else 
....................       #define LCD_DATA_PORT      getenv("SFR:PORTB")     //portb 
....................      #endif 
....................    #endif    
.................... #endif 
....................  
.................... #if defined(__PCB__) 
....................    LCD_PIN_MAP lcd, lcdlat; 
....................    #byte lcd = LCD_DATA_PORT 
....................    #byte lcdlat = LCD_DATA_PORT 
.................... #elif defined(__PCM__) 
....................    LCD_PIN_MAP lcd, lcdlat, lcdtris; 
....................    #byte lcd = LCD_DATA_PORT 
....................    #byte lcdlat = LCD_DATA_PORT 
....................    #byte lcdtris = LCD_DATA_PORT+0x80 
.................... #elif defined(__PCH__) 
....................    LCD_PIN_MAP lcd, lcdlat, lcdtris; 
....................    #byte lcd = LCD_DATA_PORT 
....................    #byte lcdlat = LCD_DATA_PORT+9 
....................    #byte lcdtris = LCD_DATA_PORT+0x12 
.................... #elif defined(__PCD__) 
....................    LCD_PIN_MAP lcd, lcdlat, lcdtris; 
....................    #word lcd = LCD_DATA_PORT 
....................    #word lcdlat = LCD_DATA_PORT+2 
....................    #word lcdtris = LCD_DATA_PORT-0x02 
.................... #endif 
.................... #endif   //LCD_DATA4 not defined 
....................  
.................... #ifndef LCD_TYPE 
....................    #define LCD_TYPE 2           // 0=5x7, 1=5x10, 2=2 lines 
.................... #endif 
....................  
.................... #ifndef LCD_LINE_TWO 
....................    #define LCD_LINE_TWO 0x40    // LCD RAM address for the second line 
.................... #endif 
....................  
.................... #ifndef LCD_LINE_LENGTH 
....................    #define LCD_LINE_LENGTH 20 
.................... #endif 
....................  
.................... unsigned int8 lcd_read_nibble(void); 
....................  
.................... unsigned int8 lcd_read_byte(void) 
.................... { 
....................    unsigned int8 low,high; 
....................  
....................  #if defined(__PCB__) 
....................    set_tris_lcd(LCD_INPUT_MAP); 
....................  #else 
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7)) 
....................    output_float(LCD_DATA4); 
....................    output_float(LCD_DATA5); 
....................    output_float(LCD_DATA6); 
....................    output_float(LCD_DATA7); 
....................   #else 
....................    lcdtris.data = 0xF; 
*
0162:  MOVLW  0F
0163:  BSF    03.5
0164:  ANDWF  06,W
0165:  IORLW  F0
0166:  MOVWF  06
....................   #endif 
....................  #endif 
....................          
....................    lcd_output_rw(1); 
0167:  BCF    03.5
0168:  BSF    06.2
....................    delay_cycles(1); 
0169:  NOP
....................    lcd_output_enable(1); 
016A:  BSF    06.0
....................    delay_cycles(1); 
016B:  NOP
....................    high = lcd_read_nibble(); 
016C:  CALL   156
016D:  MOVF   78,W
016E:  MOVWF  71
....................        
....................    lcd_output_enable(0); 
016F:  BCF    06.0
....................    delay_cycles(1); 
0170:  NOP
....................    lcd_output_enable(1); 
0171:  BSF    06.0
....................    delay_us(1); 
0172:  GOTO   173
....................    low = lcd_read_nibble(); 
0173:  CALL   156
0174:  MOVF   78,W
0175:  MOVWF  70
....................        
....................    lcd_output_enable(0); 
0176:  BCF    06.0
....................  
....................  #if defined(__PCB__) 
....................    set_tris_lcd(LCD_OUTPUT_MAP); 
....................  #else 
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7)) 
....................    output_drive(LCD_DATA4); 
....................    output_drive(LCD_DATA5); 
....................    output_drive(LCD_DATA6); 
....................    output_drive(LCD_DATA7); 
....................   #else 
....................    lcdtris.data = 0x0; 
0177:  MOVLW  0F
0178:  BSF    03.5
0179:  ANDWF  06,W
017A:  MOVWF  06
....................   #endif 
....................  #endif 
....................  
....................    return( (high<<4) | low); 
017B:  SWAPF  71,W
017C:  MOVWF  77
017D:  MOVLW  F0
017E:  ANDWF  77,F
017F:  MOVF   77,W
0180:  IORWF  70,W
0181:  MOVWF  78
.................... } 
....................  
.................... unsigned int8 lcd_read_nibble(void) 
.................... { 
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7)) 
....................    unsigned int8 n = 0x00; 
....................  
....................    /* Read the data port */ 
....................    n |= input(LCD_DATA4); 
....................    n |= input(LCD_DATA5) << 1; 
....................    n |= input(LCD_DATA6) << 2; 
....................    n |= input(LCD_DATA7) << 3; 
....................     
....................    return(n); 
....................   #else 
....................    return(lcd.data); 
*
0156:  MOVF   06,W
0157:  MOVWF  77
0158:  SWAPF  06,W
0159:  ANDLW  0F
015A:  MOVWF  78
....................   #endif 
015B:  RETURN
.................... } 
....................  
.................... void lcd_send_nibble(unsigned int8 n) 
.................... { 
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7)) 
....................    /* Write to the data port */ 
....................    output_bit(LCD_DATA4, bit_test(n, 0)); 
....................    output_bit(LCD_DATA5, bit_test(n, 1)); 
....................    output_bit(LCD_DATA6, bit_test(n, 2)); 
....................    output_bit(LCD_DATA7, bit_test(n, 3)); 
....................   #else       
....................    lcdlat.data = n; 
*
0149:  SWAPF  71,W
014A:  ANDLW  F0
014B:  MOVWF  77
014C:  MOVLW  0F
014D:  ANDWF  06,W
014E:  IORWF  77,W
014F:  MOVWF  06
....................   #endif 
....................        
....................    delay_cycles(1); 
0150:  NOP
....................    lcd_output_enable(1); 
0151:  BSF    06.0
....................    delay_us(2); 
0152:  GOTO   153
0153:  GOTO   154
....................    lcd_output_enable(0); 
0154:  BCF    06.0
0155:  RETURN
.................... } 
....................  
.................... void lcd_send_byte(unsigned int8 address, unsigned int8 n) 
.................... { 
....................   #if defined(__PCB__) 
....................    set_tris_lcd(LCD_OUTPUT_MAP); 
....................   #else 
....................    lcd_enable_tris(); 
*
015C:  BSF    03.5
015D:  BCF    06.0
....................    lcd_rs_tris(); 
015E:  BCF    06.1
....................    lcd_rw_tris(); 
015F:  BCF    06.2
....................   #endif 
....................  
....................    lcd_output_rs(0); 
0160:  BCF    03.5
0161:  BCF    06.1
....................    while ( bit_test(lcd_read_byte(),7) ) ; 
*
0182:  MOVF   78,W
0183:  MOVWF  70
0184:  BTFSS  70.7
0185:  GOTO   188
0186:  BCF    03.5
0187:  GOTO   162
....................    lcd_output_rs(address); 
0188:  BCF    03.5
0189:  BTFSS  6E.0
018A:  BCF    06.1
018B:  BTFSC  6E.0
018C:  BSF    06.1
....................    delay_cycles(1); 
018D:  NOP
....................    lcd_output_rw(0); 
018E:  BCF    06.2
....................    delay_cycles(1); 
018F:  NOP
....................    lcd_output_enable(0); 
0190:  BCF    06.0
....................    lcd_send_nibble(n >> 4); 
0191:  SWAPF  6F,W
0192:  MOVWF  70
0193:  MOVLW  0F
0194:  ANDWF  70,F
0195:  MOVF   70,W
0196:  MOVWF  71
0197:  CALL   149
....................    lcd_send_nibble(n & 0xf); 
0198:  MOVF   6F,W
0199:  ANDLW  0F
019A:  MOVWF  70
019B:  MOVWF  71
019C:  CALL   149
019D:  RETURN
.................... } 
....................  
.................... #if defined(LCD_EXTENDED_NEWLINE) 
.................... unsigned int8 g_LcdX, g_LcdY; 
.................... #endif 
....................  
.................... void lcd_init(void)  
.................... { 
....................    unsigned int8 i; 
....................    unsigned int8 LCD_INIT_STRING[4] = {0x20 | (LCD_TYPE << 2), 0xc, 1, 6}; 
019E:  MOVLW  28
019F:  MOVWF  5F
01A0:  MOVLW  0C
01A1:  MOVWF  60
01A2:  MOVLW  01
01A3:  MOVWF  61
01A4:  MOVLW  06
01A5:  MOVWF  62
....................                              // These bytes need to be sent to the LCD 
....................                              // to start it up. 
....................     
....................  
....................    lcd_output_enable(0); 
01A6:  BCF    06.0
....................    lcd_output_rs(0); 
01A7:  BCF    06.1
....................    lcd_output_rw(0); 
01A8:  BCF    06.2
....................  
....................  #if defined(__PCB__) 
....................    set_tris_lcd(LCD_OUTPUT_MAP); 
....................  #else 
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7)) 
....................    output_drive(LCD_DATA4); 
....................    output_drive(LCD_DATA5); 
....................    output_drive(LCD_DATA6); 
....................    output_drive(LCD_DATA7); 
....................   #else 
....................    lcdtris.data = 0x0; 
01A9:  MOVLW  0F
01AA:  BSF    03.5
01AB:  ANDWF  06,W
01AC:  MOVWF  06
....................   #endif 
....................    lcd_enable_tris(); 
01AD:  BCF    06.0
....................    lcd_rs_tris(); 
01AE:  BCF    06.1
....................    lcd_rw_tris(); 
01AF:  BCF    06.2
....................  #endif 
....................      
....................    delay_ms(15); 
01B0:  MOVLW  0F
01B1:  BCF    03.5
01B2:  MOVWF  6A
01B3:  CALL   135
....................    for(i=1;i<=3;++i) 
01B4:  MOVLW  01
01B5:  MOVWF  5E
01B6:  MOVF   5E,W
01B7:  SUBLW  03
01B8:  BTFSS  03.0
01B9:  GOTO   1C2
....................    { 
....................        lcd_send_nibble(3); 
01BA:  MOVLW  03
01BB:  MOVWF  71
01BC:  CALL   149
....................        delay_ms(5); 
01BD:  MOVLW  05
01BE:  MOVWF  6A
01BF:  CALL   135
01C0:  INCF   5E,F
01C1:  GOTO   1B6
....................    } 
....................     
....................    lcd_send_nibble(2); 
01C2:  MOVLW  02
01C3:  MOVWF  71
01C4:  CALL   149
....................    delay_ms(5); 
01C5:  MOVLW  05
01C6:  MOVWF  6A
01C7:  CALL   135
....................    for(i=0;i<=3;++i) 
01C8:  CLRF   5E
01C9:  MOVF   5E,W
01CA:  SUBLW  03
01CB:  BTFSS  03.0
01CC:  GOTO   1D9
....................       lcd_send_byte(0,LCD_INIT_STRING[i]); 
01CD:  MOVLW  5F
01CE:  ADDWF  5E,W
01CF:  MOVWF  04
01D0:  BCF    03.7
01D1:  MOVF   00,W
01D2:  MOVWF  63
01D3:  CLRF   6E
01D4:  MOVF   63,W
01D5:  MOVWF  6F
01D6:  CALL   15C
....................  
....................   #if defined(LCD_EXTENDED_NEWLINE) 
01D7:  INCF   5E,F
01D8:  GOTO   1C9
01D9:  BSF    0A.3
01DA:  BCF    0A.4
01DB:  GOTO   02F (RETURN)
....................    g_LcdX = 0; 
....................    g_LcdY = 0; 
....................   #endif 
.................... } 
....................  
.................... void lcd_gotoxy(unsigned int8 x, unsigned int8 y) 
.................... { 
....................    unsigned int8 address; 
....................     
....................    if(y!=1) 
01DC:  DECFSZ 6B,W
01DD:  GOTO   1DF
01DE:  GOTO   1E2
....................       address=LCD_LINE_TWO; 
01DF:  MOVLW  40
01E0:  MOVWF  6C
01E1:  GOTO   1E3
....................    else 
....................       address=0; 
01E2:  CLRF   6C
....................       
....................    address+=x-1; 
01E3:  MOVLW  01
01E4:  SUBWF  6A,W
01E5:  ADDWF  6C,F
....................    lcd_send_byte(0,0x80|address); 
01E6:  MOVF   6C,W
01E7:  IORLW  80
01E8:  MOVWF  6D
01E9:  CLRF   6E
01EA:  MOVF   6D,W
01EB:  MOVWF  6F
01EC:  CALL   15C
....................  
....................   #if defined(LCD_EXTENDED_NEWLINE) 
01ED:  RETURN
....................    g_LcdX = x - 1; 
....................    g_LcdY = y - 1; 
....................   #endif 
.................... } 
....................  
.................... void lcd_putc(char c) 
.................... { 
....................    switch (c) 
01EE:  MOVF   69,W
01EF:  XORLW  07
01F0:  BTFSC  03.2
01F1:  GOTO   1FC
01F2:  XORLW  0B
01F3:  BTFSC  03.2
01F4:  GOTO   201
01F5:  XORLW  06
01F6:  BTFSC  03.2
01F7:  GOTO   209
01F8:  XORLW  02
01F9:  BTFSC  03.2
01FA:  GOTO   20F
01FB:  GOTO   214
....................    { 
....................       case '\a'   :  lcd_gotoxy(1,1);     break; 
01FC:  MOVLW  01
01FD:  MOVWF  6A
01FE:  MOVWF  6B
01FF:  CALL   1DC
0200:  GOTO   219
....................  
....................       case '\f'   :  lcd_send_byte(0,1); 
0201:  CLRF   6E
0202:  MOVLW  01
0203:  MOVWF  6F
0204:  CALL   15C
....................                      delay_ms(2); 
0205:  MOVLW  02
0206:  MOVWF  6A
0207:  CALL   135
....................                     #if defined(LCD_EXTENDED_NEWLINE) 
....................                      g_LcdX = 0; 
....................                      g_LcdY = 0; 
....................                     #endif 
....................                      break; 
0208:  GOTO   219
....................  
....................      #if defined(LCD_EXTENDED_NEWLINE) 
....................       case '\r'   :  lcd_gotoxy(1, g_LcdY+1);   break; 
....................       case '\n'   : 
....................          while (g_LcdX++ < LCD_LINE_LENGTH) 
....................          { 
....................             lcd_send_byte(1, ' '); 
....................          } 
....................          lcd_gotoxy(1, g_LcdY+2); 
....................          break; 
....................      #else 
....................       case '\n'   : lcd_gotoxy(1,2);        break; 
0209:  MOVLW  01
020A:  MOVWF  6A
020B:  MOVLW  02
020C:  MOVWF  6B
020D:  CALL   1DC
020E:  GOTO   219
....................      #endif 
....................       
....................       case '\b'   : lcd_send_byte(0,0x10);  break; 
020F:  CLRF   6E
0210:  MOVLW  10
0211:  MOVWF  6F
0212:  CALL   15C
0213:  GOTO   219
....................       
....................      #if defined(LCD_EXTENDED_NEWLINE) 
....................       default     :  
....................          if (g_LcdX < LCD_LINE_LENGTH) 
....................          { 
....................             lcd_send_byte(1, c); 
....................             g_LcdX++; 
....................          } 
....................          break; 
....................      #else 
....................       default     : lcd_send_byte(1,c);     break; 
0214:  MOVLW  01
0215:  MOVWF  6E
0216:  MOVF   69,W
0217:  MOVWF  6F
0218:  CALL   15C
....................      #endif 
....................    } 
0219:  RETURN
.................... } 
....................   
.................... char lcd_getc(unsigned int8 x, unsigned int8 y) 
.................... { 
....................    char value; 
....................  
....................    lcd_gotoxy(x,y); 
....................    while ( bit_test(lcd_read_byte(),7) ); // wait until busy flag is low 
....................    lcd_output_rs(1); 
....................    value = lcd_read_byte(); 
....................    lcd_output_rs(0); 
....................     
....................    return(value); 
.................... } 
....................  
.................... // write a custom character to the ram 
.................... // which is 0-7 and specifies which character array we are modifying. 
.................... // ptr points to an array of 8 bytes, where each byte is the next row of 
.................... //    pixels.  only bits 0-4 are used.  the last row is the cursor row, and 
.................... //    usually you will want to leave this byte 0x00. 
.................... void lcd_set_cgram_char(unsigned int8 which, unsigned int8 *ptr) 
.................... { 
....................    unsigned int i; 
....................  
....................    which <<= 3; 
....................    which &= 0x38; 
....................  
....................    lcd_send_byte(0, 0x40 | which);  //set cgram address 
....................  
....................    for(i=0; i<8; i++) 
....................    { 
....................       lcd_send_byte(1, *ptr++); 
....................    } 
....................    
....................    #if defined(LCD_EXTENDED_NEWLINE) 
....................     lcd_gotoxy(g_LcdX+1, g_LcdY+1);  //set ddram address 
....................    #endif 
.................... } 
....................  
.................... void lcd_cursor_on(int1 on) 
.................... { 
....................    if (on) 
....................    { 
....................       lcd_send_byte(0,0x0F);           //turn LCD cursor ON 
....................    } 
....................    else 
....................    { 
....................       lcd_send_byte(0,0x0C);           //turn LCD cursor OFF 
....................    } 
.................... } 
....................  
.................... #endif 
....................  
....................  
....................  
.................... int16 START_TIME = 65059; 
....................  
.................... //!//Happy Birthday 
.................... // int16 arr[25] = { 
.................... // 65059,65059,65111,65059,65179,65157,65059,65059,65111,65059,65218,65179, 
.................... // 65059,65059,65306,65252,65179,65157,65111, 
.................... // 65268,65268,65252,65179,65218,65179 
.................... // }; 
.................... // int16 time[25] = { 
.................... // 100,80,140,120,120,140,100,80,140,120,120,140,100,80,140,140,120,120,120,100,80,140,120,120,120 
.................... // }; 
....................  
.................... #INT_TIMER1 
.................... void timer1_isr(){ 
....................    set_timer1(START_TIME); 
*
0051:  CLRF   0E
0052:  MOVF   32,W
0053:  MOVWF  0F
0054:  MOVF   31,W
0055:  MOVWF  0E
....................    output_toggle(PIN_B6); 
0056:  BSF    03.5
0057:  BCF    06.6
0058:  MOVLW  40
0059:  BCF    03.5
005A:  XORWF  06,F
005B:  BCF    0C.0
005C:  BCF    0A.3
005D:  BCF    0A.4
005E:  GOTO   02D
.................... } 
....................  
.................... //lcd display function 
.................... void lcd_Show(long f){ 
....................       lcd_gotoxy(5, 2);           // Go to column 5 row 2 
*
02D3:  MOVLW  05
02D4:  MOVWF  6A
02D5:  MOVLW  02
02D6:  MOVWF  6B
02D7:  CALL   1DC
....................       printf(lcd_putc,"%lu",f); 
02D8:  MOVLW  10
02D9:  MOVWF  04
02DA:  MOVF   5F,W
02DB:  MOVWF  61
02DC:  MOVF   5E,W
02DD:  MOVWF  60
02DE:  CALL   270
....................       lcd_gotoxy(12,2); 
02DF:  MOVLW  0C
02E0:  MOVWF  6A
02E1:  MOVLW  02
02E2:  MOVWF  6B
02E3:  CALL   1DC
....................       lcd_putc("Hz"); 
02E4:  MOVLW  5F
02E5:  BSF    03.6
02E6:  MOVWF  0D
02E7:  MOVLW  00
02E8:  MOVWF  0F
02E9:  BCF    03.6
02EA:  CALL   21A
02EB:  RETURN
.................... } 
....................  
.................... //calculate given frequency to timer 
.................... int16 convertTimer(long f){ 
....................    return 65536 - (1000000/(4*f)); 
*
0344:  RLF    5E,W
0345:  MOVWF  79
0346:  RLF    5F,W
0347:  MOVWF  7A
0348:  RLF    79,F
0349:  RLF    7A,F
034A:  MOVLW  FC
034B:  ANDWF  79,F
034C:  MOVF   79,W
034D:  MOVWF  60
034E:  MOVF   7A,W
034F:  MOVWF  61
0350:  BCF    03.1
0351:  CLRF   65
0352:  MOVLW  0F
0353:  MOVWF  64
0354:  MOVLW  42
0355:  MOVWF  63
0356:  MOVLW  40
0357:  MOVWF  62
0358:  CLRF   69
0359:  CLRF   68
035A:  MOVF   61,W
035B:  MOVWF  67
035C:  MOVF   60,W
035D:  MOVWF  66
*
03AC:  MOVF   77,W
03AD:  SUBLW  00
03AE:  MOVWF  77
03AF:  MOVF   78,W
03B0:  BTFSS  03.0
03B1:  INCFSZ 78,W
03B2:  GOTO   3B5
03B3:  MOVLW  00
03B4:  GOTO   3B6
03B5:  SUBLW  00
03B6:  MOVWF  78
03B7:  MOVF   79,W
03B8:  BTFSS  03.0
03B9:  INCFSZ 79,W
03BA:  GOTO   3BD
03BB:  MOVLW  01
03BC:  GOTO   3BE
03BD:  SUBLW  01
03BE:  MOVWF  79
03BF:  MOVF   7A,W
03C0:  BTFSS  03.0
03C1:  INCFSZ 7A,W
03C2:  GOTO   3C5
03C3:  MOVLW  00
03C4:  GOTO   3C6
03C5:  SUBLW  00
03C6:  MOVWF  7A
03C7:  MOVF   78,W
03C8:  MOVWF  79
03C9:  MOVF   77,W
03CA:  MOVWF  78
03CB:  RETURN
.................... } 
....................  
.................... void main() 
*
0800:  MOVF   03,W
0801:  ANDLW  1F
0802:  MOVWF  03
0803:  MOVLW  71
0804:  BSF    03.5
0805:  MOVWF  0F
0806:  CLRF   10
0807:  MOVF   0F,W
0808:  BSF    03.6
0809:  BCF    07.3
080A:  MOVLW  0C
080B:  BCF    03.6
080C:  MOVWF  19
080D:  MOVLW  A2
080E:  MOVWF  18
080F:  MOVLW  90
0810:  BCF    03.5
0811:  MOVWF  18
0812:  MOVLW  FE
0813:  MOVWF  32
0814:  MOVLW  23
0815:  MOVWF  31
0816:  CLRF   34
0817:  CLRF   33
0818:  MOVLW  FF
0819:  MOVWF  35
081A:  BSF    03.5
081B:  BSF    03.6
081C:  MOVF   09,W
081D:  ANDLW  C0
081E:  MOVWF  09
081F:  BCF    03.6
0820:  BCF    1F.4
0821:  BCF    1F.5
0822:  MOVLW  00
0823:  BSF    03.6
0824:  MOVWF  08
0825:  BCF    03.5
0826:  CLRF   07
0827:  CLRF   08
0828:  CLRF   09
0829:  BCF    03.7
.................... { 
....................    lcd_init(); 
*
082D:  BCF    0A.3
082E:  GOTO   19E
082F:  BSF    0A.3
....................    //initial code for setup timer for interrupt 
....................    lcd_putc('\f'); 
0830:  MOVLW  0C
0831:  MOVWF  69
0832:  BCF    0A.3
0833:  CALL   1EE
0834:  BSF    0A.3
....................    lcd_gotoxy(5, 1);  
0835:  MOVLW  05
0836:  MOVWF  6A
0837:  MOVLW  01
0838:  MOVWF  6B
0839:  BCF    0A.3
083A:  CALL   1DC
083B:  BSF    0A.3
....................    lcd_putc("WELCOME");  
083C:  MOVLW  61
083D:  BSF    03.6
083E:  MOVWF  0D
083F:  MOVLW  00
0840:  MOVWF  0F
0841:  BCF    0A.3
0842:  BCF    03.6
0843:  CALL   21A
0844:  BSF    0A.3
....................    lcd_gotoxy(1, 2);            
0845:  MOVLW  01
0846:  MOVWF  6A
0847:  MOVLW  02
0848:  MOVWF  6B
0849:  BCF    0A.3
084A:  CALL   1DC
084B:  BSF    0A.3
....................    lcd_putc("CYBMCYSSBSSNTMMC");    
084C:  MOVLW  65
084D:  BSF    03.6
084E:  MOVWF  0D
084F:  MOVLW  00
0850:  MOVWF  0F
0851:  BCF    0A.3
0852:  BCF    03.6
0853:  CALL   21A
0854:  BSF    0A.3
....................    setup_timer_1(T1_INTERNAL | T1_DIV_BY_4); 
0855:  MOVLW  25
0856:  MOVWF  10
....................    set_timer1(START_TIME); 
0857:  CLRF   0E
0858:  MOVF   32,W
0859:  MOVWF  0F
085A:  MOVF   31,W
085B:  MOVWF  0E
....................    enable_interrupts(INT_TIMER1); 
085C:  BSF    03.5
085D:  BSF    0C.0
....................    enable_interrupts(GLOBAL); 
085E:  MOVLW  C0
085F:  BCF    03.5
0860:  IORWF  0B,F
....................    //-----------------------------------------------------// 
....................    //var decaration 
....................    int lastButton = -1; 
....................    long inputFeq = 500;  
....................    int fakePointer = -1; 
....................    //-----------------------------------------------------// 
.................... //!   long default_feq [6] = {1043, 1175, 1319, 1399, 1565, 1764}; 
....................    int16 d_but1 = 65306; 
....................    int16 d_but2 = 65333; 
....................    int16 d_but3 = 65356; 
....................    int16 d_but4 = 65367; 
....................    int16 d_but5 = 65386; 
....................    int16 d_but6 = 65404; 
.................... //!   long current_feq [6]; 
.................... //    copy arr from defalut -> current for initialize value 
....................    int16 c_but1 = d_but1; 
....................    int16 c_but2 = d_but2; 
....................    int16 c_but3 = d_but3; 
....................    int16 c_but4 = d_but4; 
....................    int16 c_but5 = d_but5; 
....................    int16 c_but6 = d_but6; 
....................     
....................    int16 c_feq_but1 = 1043; 
....................    int16 c_feq_but2 = 1175; 
....................    int16 c_feq_but3 = 1319; 
....................    int16 c_feq_but4 = 1399; 
....................    int16 c_feq_but5 = 1565; 
....................    int16 c_feq_but6 = 1764; 
0861:  MOVLW  FF
0862:  MOVWF  36
0863:  MOVLW  01
0864:  MOVWF  38
0865:  MOVLW  F4
0866:  MOVWF  37
0867:  MOVLW  FF
0868:  MOVWF  39
0869:  MOVWF  3B
086A:  MOVLW  1A
086B:  MOVWF  3A
086C:  MOVLW  FF
086D:  MOVWF  3D
086E:  MOVLW  35
086F:  MOVWF  3C
0870:  MOVLW  FF
0871:  MOVWF  3F
0872:  MOVLW  4C
0873:  MOVWF  3E
0874:  MOVLW  FF
0875:  MOVWF  41
0876:  MOVLW  57
0877:  MOVWF  40
0878:  MOVLW  FF
0879:  MOVWF  43
087A:  MOVLW  6A
087B:  MOVWF  42
087C:  MOVLW  FF
087D:  MOVWF  45
087E:  MOVLW  7C
087F:  MOVWF  44
0880:  MOVF   3B,W
0881:  MOVWF  47
0882:  MOVF   3A,W
0883:  MOVWF  46
0884:  MOVF   3D,W
0885:  MOVWF  49
0886:  MOVF   3C,W
0887:  MOVWF  48
0888:  MOVF   3F,W
0889:  MOVWF  4B
088A:  MOVF   3E,W
088B:  MOVWF  4A
088C:  MOVF   41,W
088D:  MOVWF  4D
088E:  MOVF   40,W
088F:  MOVWF  4C
0890:  MOVF   43,W
0891:  MOVWF  4F
0892:  MOVF   42,W
0893:  MOVWF  4E
0894:  MOVF   45,W
0895:  MOVWF  51
0896:  MOVF   44,W
0897:  MOVWF  50
0898:  MOVLW  04
0899:  MOVWF  53
089A:  MOVLW  13
089B:  MOVWF  52
089C:  MOVLW  04
089D:  MOVWF  55
089E:  MOVLW  97
089F:  MOVWF  54
08A0:  MOVLW  05
08A1:  MOVWF  57
08A2:  MOVLW  27
08A3:  MOVWF  56
08A4:  MOVLW  05
08A5:  MOVWF  59
08A6:  MOVLW  77
08A7:  MOVWF  58
08A8:  MOVLW  06
08A9:  MOVWF  5B
08AA:  MOVLW  1D
08AB:  MOVWF  5A
08AC:  MOVLW  06
08AD:  MOVWF  5D
08AE:  MOVLW  E4
08AF:  MOVWF  5C
....................    //-----------------------------------------------------// 
....................    While(1){ 
....................       switch(fakePointer){ 
08B0:  MOVF   39,W
08B1:  XORLW  01
08B2:  BTFSC  03.2
08B3:  GOTO   0DC
08B4:  XORLW  03
08B5:  BTFSC  03.2
08B6:  GOTO   114
08B7:  XORLW  01
08B8:  BTFSC  03.2
08B9:  GOTO   153
08BA:  XORLW  07
08BB:  BTFSC  03.2
08BC:  GOTO   18B
08BD:  XORLW  01
08BE:  BTFSC  03.2
08BF:  GOTO   1C3
08C0:  XORLW  03
08C1:  BTFSC  03.2
08C2:  GOTO   1FB
08C3:  XORLW  01
08C4:  BTFSC  03.2
08C5:  GOTO   233
08C6:  XORLW  0C
08C7:  BTFSC  03.2
08C8:  GOTO   29B
08C9:  XORLW  07
08CA:  BTFSC  03.2
08CB:  GOTO   2D3
08CC:  XORLW  01
08CD:  BTFSC  03.2
08CE:  GOTO   30B
08CF:  XORLW  03
08D0:  BTFSC  03.2
08D1:  GOTO   343
08D2:  XORLW  01
08D3:  BTFSC  03.2
08D4:  GOTO   37B
08D5:  XORLW  1F
08D6:  BTFSC  03.2
08D7:  GOTO   3B3
08D8:  XORLW  73
08D9:  BTFSC  03.2
08DA:  GOTO   3EB
08DB:  GOTO   427
....................             case 1:  lcd_putc('\f'); 
08DC:  MOVLW  0C
08DD:  MOVWF  69
08DE:  BCF    0A.3
08DF:  CALL   1EE
08E0:  BSF    0A.3
....................                      lcd_gotoxy(5, 1);  
08E1:  MOVLW  05
08E2:  MOVWF  6A
08E3:  MOVLW  01
08E4:  MOVWF  6B
08E5:  BCF    0A.3
08E6:  CALL   1DC
08E7:  BSF    0A.3
....................                      lcd_putc("BT1_FEQ");  
08E8:  MOVLW  6E
08E9:  BSF    03.6
08EA:  MOVWF  0D
08EB:  MOVLW  00
08EC:  MOVWF  0F
08ED:  BCF    0A.3
08EE:  BCF    03.6
08EF:  CALL   21A
08F0:  BSF    0A.3
....................                      lcd_gotoxy(5, 2);           // Go to column 7 row 2 
08F1:  MOVLW  05
08F2:  MOVWF  6A
08F3:  MOVLW  02
08F4:  MOVWF  6B
08F5:  BCF    0A.3
08F6:  CALL   1DC
08F7:  BSF    0A.3
....................                      printf(lcd_putc,"%lu",c_feq_but1);   // Write num with 5 numbers max 
08F8:  MOVLW  10
08F9:  MOVWF  04
08FA:  MOVF   53,W
08FB:  MOVWF  61
08FC:  MOVF   52,W
08FD:  MOVWF  60
08FE:  BCF    0A.3
08FF:  CALL   270
0900:  BSF    0A.3
....................                      lcd_gotoxy(12,2); 
0901:  MOVLW  0C
0902:  MOVWF  6A
0903:  MOVLW  02
0904:  MOVWF  6B
0905:  BCF    0A.3
0906:  CALL   1DC
0907:  BSF    0A.3
....................                      lcd_putc("Hz"); 
0908:  MOVLW  72
0909:  BSF    03.6
090A:  MOVWF  0D
090B:  MOVLW  00
090C:  MOVWF  0F
090D:  BCF    0A.3
090E:  BCF    03.6
090F:  CALL   21A
0910:  BSF    0A.3
....................                      fakePointer = -1; 
0911:  MOVLW  FF
0912:  MOVWF  39
....................                      break; 
0913:  GOTO   427
....................             case 2:  lcd_putc('\f'); 
0914:  MOVLW  0C
0915:  MOVWF  69
0916:  BCF    0A.3
0917:  CALL   1EE
0918:  BSF    0A.3
....................                      lcd_gotoxy(5, 1);  
0919:  MOVLW  05
091A:  MOVWF  6A
091B:  MOVLW  01
091C:  MOVWF  6B
091D:  BCF    0A.3
091E:  CALL   1DC
091F:  BSF    0A.3
....................                      lcd_putc("BT2_FEQ");  
0920:  MOVLW  74
0921:  BSF    03.6
0922:  MOVWF  0D
0923:  MOVLW  00
0924:  MOVWF  0F
0925:  BCF    0A.3
0926:  BCF    03.6
0927:  CALL   21A
0928:  BSF    0A.3
....................                      lcd_gotoxy(5, 2);           // Go to column 7 row 2 
0929:  MOVLW  05
092A:  MOVWF  6A
092B:  MOVLW  02
092C:  MOVWF  6B
092D:  BCF    0A.3
092E:  CALL   1DC
092F:  BSF    0A.3
....................                      printf(lcd_putc,"%lu",c_feq_but2);   // Write num with 5 numbers max 
0930:  MOVLW  10
0931:  MOVWF  04
0932:  MOVF   55,W
0933:  MOVWF  61
0934:  MOVF   54,W
0935:  MOVWF  60
0936:  BCF    0A.3
0937:  CALL   270
0938:  BSF    0A.3
....................                      lcd_gotoxy(12,2); 
0939:  MOVLW  0C
093A:  MOVWF  6A
093B:  MOVLW  02
093C:  MOVWF  6B
093D:  BCF    0A.3
093E:  CALL   1DC
093F:  BSF    0A.3
....................                      lcd_putc("Hz"); 
0940:  MOVLW  78
0941:  BSF    03.6
0942:  MOVWF  0D
0943:  MOVLW  00
0944:  MOVWF  0F
0945:  BCF    0A.3
0946:  BCF    03.6
0947:  CALL   21A
0948:  BSF    0A.3
....................                      fakePointer = -1; 
0949:  MOVLW  FF
094A:  MOVWF  39
....................                      lcd_Show(c_feq_but2); 
094B:  MOVF   55,W
094C:  MOVWF  5F
094D:  MOVF   54,W
094E:  MOVWF  5E
094F:  BCF    0A.3
0950:  CALL   2D3
0951:  BSF    0A.3
....................                      break; 
0952:  GOTO   427
....................             case 3:  lcd_putc('\f'); 
0953:  MOVLW  0C
0954:  MOVWF  69
0955:  BCF    0A.3
0956:  CALL   1EE
0957:  BSF    0A.3
....................                      lcd_gotoxy(5, 1);  
0958:  MOVLW  05
0959:  MOVWF  6A
095A:  MOVLW  01
095B:  MOVWF  6B
095C:  BCF    0A.3
095D:  CALL   1DC
095E:  BSF    0A.3
....................                      lcd_putc("BT3_FEQ");  
095F:  MOVLW  7A
0960:  BSF    03.6
0961:  MOVWF  0D
0962:  MOVLW  00
0963:  MOVWF  0F
0964:  BCF    0A.3
0965:  BCF    03.6
0966:  CALL   21A
0967:  BSF    0A.3
....................                      lcd_gotoxy(5, 2);           // Go to column 7 row 2 
0968:  MOVLW  05
0969:  MOVWF  6A
096A:  MOVLW  02
096B:  MOVWF  6B
096C:  BCF    0A.3
096D:  CALL   1DC
096E:  BSF    0A.3
....................                      printf(lcd_putc,"%lu",c_feq_but3);   // Write num with 5 numbers max 
096F:  MOVLW  10
0970:  MOVWF  04
0971:  MOVF   57,W
0972:  MOVWF  61
0973:  MOVF   56,W
0974:  MOVWF  60
0975:  BCF    0A.3
0976:  CALL   270
0977:  BSF    0A.3
....................                      lcd_gotoxy(12,2); 
0978:  MOVLW  0C
0979:  MOVWF  6A
097A:  MOVLW  02
097B:  MOVWF  6B
097C:  BCF    0A.3
097D:  CALL   1DC
097E:  BSF    0A.3
....................                      lcd_putc("Hz"); 
097F:  MOVLW  7E
0980:  BSF    03.6
0981:  MOVWF  0D
0982:  MOVLW  00
0983:  MOVWF  0F
0984:  BCF    0A.3
0985:  BCF    03.6
0986:  CALL   21A
0987:  BSF    0A.3
....................                      fakePointer = -1; 
0988:  MOVLW  FF
0989:  MOVWF  39
....................                      break; 
098A:  GOTO   427
....................             case 4:  lcd_putc('\f'); 
098B:  MOVLW  0C
098C:  MOVWF  69
098D:  BCF    0A.3
098E:  CALL   1EE
098F:  BSF    0A.3
....................                      lcd_gotoxy(5, 1);  
0990:  MOVLW  05
0991:  MOVWF  6A
0992:  MOVLW  01
0993:  MOVWF  6B
0994:  BCF    0A.3
0995:  CALL   1DC
0996:  BSF    0A.3
....................                      lcd_putc("BT4_FEQ");  
0997:  MOVLW  80
0998:  BSF    03.6
0999:  MOVWF  0D
099A:  MOVLW  00
099B:  MOVWF  0F
099C:  BCF    0A.3
099D:  BCF    03.6
099E:  CALL   21A
099F:  BSF    0A.3
....................                      lcd_gotoxy(5, 2);           // Go to column 7 row 2 
09A0:  MOVLW  05
09A1:  MOVWF  6A
09A2:  MOVLW  02
09A3:  MOVWF  6B
09A4:  BCF    0A.3
09A5:  CALL   1DC
09A6:  BSF    0A.3
....................                      printf(lcd_putc,"%lu",c_feq_but4);   // Write num with 5 numbers max 
09A7:  MOVLW  10
09A8:  MOVWF  04
09A9:  MOVF   59,W
09AA:  MOVWF  61
09AB:  MOVF   58,W
09AC:  MOVWF  60
09AD:  BCF    0A.3
09AE:  CALL   270
09AF:  BSF    0A.3
....................                      lcd_gotoxy(12,2); 
09B0:  MOVLW  0C
09B1:  MOVWF  6A
09B2:  MOVLW  02
09B3:  MOVWF  6B
09B4:  BCF    0A.3
09B5:  CALL   1DC
09B6:  BSF    0A.3
....................                      lcd_putc("Hz"); 
09B7:  MOVLW  84
09B8:  BSF    03.6
09B9:  MOVWF  0D
09BA:  MOVLW  00
09BB:  MOVWF  0F
09BC:  BCF    0A.3
09BD:  BCF    03.6
09BE:  CALL   21A
09BF:  BSF    0A.3
....................                      fakePointer = -1; 
09C0:  MOVLW  FF
09C1:  MOVWF  39
....................                      break; 
09C2:  GOTO   427
....................             case 5:  lcd_putc('\f'); 
09C3:  MOVLW  0C
09C4:  MOVWF  69
09C5:  BCF    0A.3
09C6:  CALL   1EE
09C7:  BSF    0A.3
....................                      lcd_gotoxy(5, 1);  
09C8:  MOVLW  05
09C9:  MOVWF  6A
09CA:  MOVLW  01
09CB:  MOVWF  6B
09CC:  BCF    0A.3
09CD:  CALL   1DC
09CE:  BSF    0A.3
....................                      lcd_putc("BT5_FEQ");  
09CF:  MOVLW  86
09D0:  BSF    03.6
09D1:  MOVWF  0D
09D2:  MOVLW  00
09D3:  MOVWF  0F
09D4:  BCF    0A.3
09D5:  BCF    03.6
09D6:  CALL   21A
09D7:  BSF    0A.3
....................                      lcd_gotoxy(5, 2);           // Go to column 7 row 2 
09D8:  MOVLW  05
09D9:  MOVWF  6A
09DA:  MOVLW  02
09DB:  MOVWF  6B
09DC:  BCF    0A.3
09DD:  CALL   1DC
09DE:  BSF    0A.3
....................                      printf(lcd_putc,"%lu",c_feq_but5);   // Write num with 5 numbers max 
09DF:  MOVLW  10
09E0:  MOVWF  04
09E1:  MOVF   5B,W
09E2:  MOVWF  61
09E3:  MOVF   5A,W
09E4:  MOVWF  60
09E5:  BCF    0A.3
09E6:  CALL   270
09E7:  BSF    0A.3
....................                      lcd_gotoxy(12,2); 
09E8:  MOVLW  0C
09E9:  MOVWF  6A
09EA:  MOVLW  02
09EB:  MOVWF  6B
09EC:  BCF    0A.3
09ED:  CALL   1DC
09EE:  BSF    0A.3
....................                      lcd_putc("Hz"); 
09EF:  MOVLW  8A
09F0:  BSF    03.6
09F1:  MOVWF  0D
09F2:  MOVLW  00
09F3:  MOVWF  0F
09F4:  BCF    0A.3
09F5:  BCF    03.6
09F6:  CALL   21A
09F7:  BSF    0A.3
....................                      fakePointer = -1; 
09F8:  MOVLW  FF
09F9:  MOVWF  39
....................                      break; 
09FA:  GOTO   427
....................             case 6:  lcd_putc('\f'); 
09FB:  MOVLW  0C
09FC:  MOVWF  69
09FD:  BCF    0A.3
09FE:  CALL   1EE
09FF:  BSF    0A.3
....................                      lcd_gotoxy(5, 1);  
0A00:  MOVLW  05
0A01:  MOVWF  6A
0A02:  MOVLW  01
0A03:  MOVWF  6B
0A04:  BCF    0A.3
0A05:  CALL   1DC
0A06:  BSF    0A.3
....................                      lcd_putc("BT6_FEQ");  
0A07:  MOVLW  8C
0A08:  BSF    03.6
0A09:  MOVWF  0D
0A0A:  MOVLW  00
0A0B:  MOVWF  0F
0A0C:  BCF    0A.3
0A0D:  BCF    03.6
0A0E:  CALL   21A
0A0F:  BSF    0A.3
....................                      lcd_gotoxy(5, 2);           // Go to column 7 row 2 
0A10:  MOVLW  05
0A11:  MOVWF  6A
0A12:  MOVLW  02
0A13:  MOVWF  6B
0A14:  BCF    0A.3
0A15:  CALL   1DC
0A16:  BSF    0A.3
....................                      printf(lcd_putc,"%lu",c_feq_but6);   // Write num with 5 numbers max 
0A17:  MOVLW  10
0A18:  MOVWF  04
0A19:  MOVF   5D,W
0A1A:  MOVWF  61
0A1B:  MOVF   5C,W
0A1C:  MOVWF  60
0A1D:  BCF    0A.3
0A1E:  CALL   270
0A1F:  BSF    0A.3
....................                      lcd_gotoxy(12,2); 
0A20:  MOVLW  0C
0A21:  MOVWF  6A
0A22:  MOVLW  02
0A23:  MOVWF  6B
0A24:  BCF    0A.3
0A25:  CALL   1DC
0A26:  BSF    0A.3
....................                      lcd_putc("Hz"); 
0A27:  MOVLW  90
0A28:  BSF    03.6
0A29:  MOVWF  0D
0A2A:  MOVLW  00
0A2B:  MOVWF  0F
0A2C:  BCF    0A.3
0A2D:  BCF    03.6
0A2E:  CALL   21A
0A2F:  BSF    0A.3
....................                      fakePointer = -1; 
0A30:  MOVLW  FF
0A31:  MOVWF  39
....................                      break; 
0A32:  GOTO   427
....................             case 7:  lcd_putc('\f'); 
0A33:  MOVLW  0C
0A34:  MOVWF  69
0A35:  BCF    0A.3
0A36:  CALL   1EE
0A37:  BSF    0A.3
....................                      lcd_gotoxy(4, 1);  
0A38:  MOVLW  04
0A39:  MOVWF  6A
0A3A:  MOVLW  01
0A3B:  MOVWF  6B
0A3C:  BCF    0A.3
0A3D:  CALL   1DC
0A3E:  BSF    0A.3
....................                      lcd_putc("FEQ_RESET");  
0A3F:  MOVLW  92
0A40:  BSF    03.6
0A41:  MOVWF  0D
0A42:  MOVLW  00
0A43:  MOVWF  0F
0A44:  BCF    0A.3
0A45:  BCF    03.6
0A46:  CALL   21A
0A47:  BSF    0A.3
....................                      lcd_gotoxy(5, 2);           // Go to column 7 row 2 
0A48:  MOVLW  05
0A49:  MOVWF  6A
0A4A:  MOVLW  02
0A4B:  MOVWF  6B
0A4C:  BCF    0A.3
0A4D:  CALL   1DC
0A4E:  BSF    0A.3
....................                      printf(lcd_putc,"%lu",inputFeq);   // Write num with 5 numbers max 
0A4F:  MOVLW  10
0A50:  MOVWF  04
0A51:  MOVF   38,W
0A52:  MOVWF  61
0A53:  MOVF   37,W
0A54:  MOVWF  60
0A55:  BCF    0A.3
0A56:  CALL   270
0A57:  BSF    0A.3
....................                      lcd_gotoxy(12,2); 
0A58:  MOVLW  0C
0A59:  MOVWF  6A
0A5A:  MOVLW  02
0A5B:  MOVWF  6B
0A5C:  BCF    0A.3
0A5D:  CALL   1DC
0A5E:  BSF    0A.3
....................                      lcd_putc("Hz"); 
0A5F:  MOVLW  97
0A60:  BSF    03.6
0A61:  MOVWF  0D
0A62:  MOVLW  00
0A63:  MOVWF  0F
0A64:  BCF    0A.3
0A65:  BCF    03.6
0A66:  CALL   21A
0A67:  BSF    0A.3
....................  
....................                      c_but1 = d_but1; 
0A68:  MOVF   3B,W
0A69:  MOVWF  47
0A6A:  MOVF   3A,W
0A6B:  MOVWF  46
....................                      c_but2 = d_but2; 
0A6C:  MOVF   3D,W
0A6D:  MOVWF  49
0A6E:  MOVF   3C,W
0A6F:  MOVWF  48
....................                      c_but3 = d_but3; 
0A70:  MOVF   3F,W
0A71:  MOVWF  4B
0A72:  MOVF   3E,W
0A73:  MOVWF  4A
....................                      c_but4 = d_but4; 
0A74:  MOVF   41,W
0A75:  MOVWF  4D
0A76:  MOVF   40,W
0A77:  MOVWF  4C
....................                      c_but5 = d_but5; 
0A78:  MOVF   43,W
0A79:  MOVWF  4F
0A7A:  MOVF   42,W
0A7B:  MOVWF  4E
....................                      c_but6 = d_but6; 
0A7C:  MOVF   45,W
0A7D:  MOVWF  51
0A7E:  MOVF   44,W
0A7F:  MOVWF  50
....................  
....................                      c_feq_but1 = 1043; 
0A80:  MOVLW  04
0A81:  MOVWF  53
0A82:  MOVLW  13
0A83:  MOVWF  52
....................                      c_feq_but2 = 1175; 
0A84:  MOVLW  04
0A85:  MOVWF  55
0A86:  MOVLW  97
0A87:  MOVWF  54
....................                      c_feq_but3 = 1319; 
0A88:  MOVLW  05
0A89:  MOVWF  57
0A8A:  MOVLW  27
0A8B:  MOVWF  56
....................                      c_feq_but4 = 1399; 
0A8C:  MOVLW  05
0A8D:  MOVWF  59
0A8E:  MOVLW  77
0A8F:  MOVWF  58
....................                      c_feq_but5 = 1565; 
0A90:  MOVLW  06
0A91:  MOVWF  5B
0A92:  MOVLW  1D
0A93:  MOVWF  5A
....................                      c_feq_but6 = 1764; 
0A94:  MOVLW  06
0A95:  MOVWF  5D
0A96:  MOVLW  E4
0A97:  MOVWF  5C
....................  
....................                      fakePointer = -1; 
0A98:  MOVLW  FF
0A99:  MOVWF  39
....................                      break; 
0A9A:  GOTO   427
....................             case 11: lcd_putc('\f'); 
0A9B:  MOVLW  0C
0A9C:  MOVWF  69
0A9D:  BCF    0A.3
0A9E:  CALL   1EE
0A9F:  BSF    0A.3
....................                      lcd_gotoxy(3, 1);  
0AA0:  MOVLW  03
0AA1:  MOVWF  6A
0AA2:  MOVLW  01
0AA3:  MOVWF  6B
0AA4:  BCF    0A.3
0AA5:  CALL   1DC
0AA6:  BSF    0A.3
....................                      lcd_putc("BT1_FEQ_SET"); 
0AA7:  MOVLW  99
0AA8:  BSF    03.6
0AA9:  MOVWF  0D
0AAA:  MOVLW  00
0AAB:  MOVWF  0F
0AAC:  BCF    0A.3
0AAD:  BCF    03.6
0AAE:  CALL   21A
0AAF:  BSF    0A.3
....................                      lcd_gotoxy(5, 2); 
0AB0:  MOVLW  05
0AB1:  MOVWF  6A
0AB2:  MOVLW  02
0AB3:  MOVWF  6B
0AB4:  BCF    0A.3
0AB5:  CALL   1DC
0AB6:  BSF    0A.3
....................                      printf(lcd_putc,"%lu",inputFeq); 
0AB7:  MOVLW  10
0AB8:  MOVWF  04
0AB9:  MOVF   38,W
0ABA:  MOVWF  61
0ABB:  MOVF   37,W
0ABC:  MOVWF  60
0ABD:  BCF    0A.3
0ABE:  CALL   270
0ABF:  BSF    0A.3
....................                      lcd_gotoxy(12,2); 
0AC0:  MOVLW  0C
0AC1:  MOVWF  6A
0AC2:  MOVLW  02
0AC3:  MOVWF  6B
0AC4:  BCF    0A.3
0AC5:  CALL   1DC
0AC6:  BSF    0A.3
....................                      lcd_putc("Hz"); 
0AC7:  MOVLW  9F
0AC8:  BSF    03.6
0AC9:  MOVWF  0D
0ACA:  MOVLW  00
0ACB:  MOVWF  0F
0ACC:  BCF    0A.3
0ACD:  BCF    03.6
0ACE:  CALL   21A
0ACF:  BSF    0A.3
....................                      fakePointer = -1; 
0AD0:  MOVLW  FF
0AD1:  MOVWF  39
....................                      break; 
0AD2:  GOTO   427
....................             case 12: lcd_putc('\f'); 
0AD3:  MOVLW  0C
0AD4:  MOVWF  69
0AD5:  BCF    0A.3
0AD6:  CALL   1EE
0AD7:  BSF    0A.3
....................                      lcd_gotoxy(3, 1);  
0AD8:  MOVLW  03
0AD9:  MOVWF  6A
0ADA:  MOVLW  01
0ADB:  MOVWF  6B
0ADC:  BCF    0A.3
0ADD:  CALL   1DC
0ADE:  BSF    0A.3
....................                      lcd_putc("BT2_FEQ_SET");  
0ADF:  MOVLW  A1
0AE0:  BSF    03.6
0AE1:  MOVWF  0D
0AE2:  MOVLW  00
0AE3:  MOVWF  0F
0AE4:  BCF    0A.3
0AE5:  BCF    03.6
0AE6:  CALL   21A
0AE7:  BSF    0A.3
....................                      lcd_gotoxy(5, 2); 
0AE8:  MOVLW  05
0AE9:  MOVWF  6A
0AEA:  MOVLW  02
0AEB:  MOVWF  6B
0AEC:  BCF    0A.3
0AED:  CALL   1DC
0AEE:  BSF    0A.3
....................                      printf(lcd_putc,"%lu",inputFeq); 
0AEF:  MOVLW  10
0AF0:  MOVWF  04
0AF1:  MOVF   38,W
0AF2:  MOVWF  61
0AF3:  MOVF   37,W
0AF4:  MOVWF  60
0AF5:  BCF    0A.3
0AF6:  CALL   270
0AF7:  BSF    0A.3
....................                      lcd_gotoxy(12,2); 
0AF8:  MOVLW  0C
0AF9:  MOVWF  6A
0AFA:  MOVLW  02
0AFB:  MOVWF  6B
0AFC:  BCF    0A.3
0AFD:  CALL   1DC
0AFE:  BSF    0A.3
....................                      lcd_putc("Hz"); 
0AFF:  MOVLW  A7
0B00:  BSF    03.6
0B01:  MOVWF  0D
0B02:  MOVLW  00
0B03:  MOVWF  0F
0B04:  BCF    0A.3
0B05:  BCF    03.6
0B06:  CALL   21A
0B07:  BSF    0A.3
....................                      fakePointer = -1; 
0B08:  MOVLW  FF
0B09:  MOVWF  39
....................                      break; 
0B0A:  GOTO   427
....................             case 13: lcd_putc('\f'); 
0B0B:  MOVLW  0C
0B0C:  MOVWF  69
0B0D:  BCF    0A.3
0B0E:  CALL   1EE
0B0F:  BSF    0A.3
....................                      lcd_gotoxy(3, 1);  
0B10:  MOVLW  03
0B11:  MOVWF  6A
0B12:  MOVLW  01
0B13:  MOVWF  6B
0B14:  BCF    0A.3
0B15:  CALL   1DC
0B16:  BSF    0A.3
....................                      lcd_putc("BT3_FEQ_SET");  
0B17:  MOVLW  A9
0B18:  BSF    03.6
0B19:  MOVWF  0D
0B1A:  MOVLW  00
0B1B:  MOVWF  0F
0B1C:  BCF    0A.3
0B1D:  BCF    03.6
0B1E:  CALL   21A
0B1F:  BSF    0A.3
....................                      lcd_gotoxy(5, 2); 
0B20:  MOVLW  05
0B21:  MOVWF  6A
0B22:  MOVLW  02
0B23:  MOVWF  6B
0B24:  BCF    0A.3
0B25:  CALL   1DC
0B26:  BSF    0A.3
....................                      printf(lcd_putc,"%lu",inputFeq); 
0B27:  MOVLW  10
0B28:  MOVWF  04
0B29:  MOVF   38,W
0B2A:  MOVWF  61
0B2B:  MOVF   37,W
0B2C:  MOVWF  60
0B2D:  BCF    0A.3
0B2E:  CALL   270
0B2F:  BSF    0A.3
....................                      lcd_gotoxy(12,2); 
0B30:  MOVLW  0C
0B31:  MOVWF  6A
0B32:  MOVLW  02
0B33:  MOVWF  6B
0B34:  BCF    0A.3
0B35:  CALL   1DC
0B36:  BSF    0A.3
....................                      lcd_putc("Hz"); 
0B37:  MOVLW  AF
0B38:  BSF    03.6
0B39:  MOVWF  0D
0B3A:  MOVLW  00
0B3B:  MOVWF  0F
0B3C:  BCF    0A.3
0B3D:  BCF    03.6
0B3E:  CALL   21A
0B3F:  BSF    0A.3
....................                      fakePointer = -1; 
0B40:  MOVLW  FF
0B41:  MOVWF  39
....................                      break; 
0B42:  GOTO   427
....................             case 14: lcd_putc('\f'); 
0B43:  MOVLW  0C
0B44:  MOVWF  69
0B45:  BCF    0A.3
0B46:  CALL   1EE
0B47:  BSF    0A.3
....................                      lcd_gotoxy(3, 1);  
0B48:  MOVLW  03
0B49:  MOVWF  6A
0B4A:  MOVLW  01
0B4B:  MOVWF  6B
0B4C:  BCF    0A.3
0B4D:  CALL   1DC
0B4E:  BSF    0A.3
....................                      lcd_putc("BT4_FEQ_SET");  
0B4F:  MOVLW  B1
0B50:  BSF    03.6
0B51:  MOVWF  0D
0B52:  MOVLW  00
0B53:  MOVWF  0F
0B54:  BCF    0A.3
0B55:  BCF    03.6
0B56:  CALL   21A
0B57:  BSF    0A.3
....................                      lcd_gotoxy(5, 2); 
0B58:  MOVLW  05
0B59:  MOVWF  6A
0B5A:  MOVLW  02
0B5B:  MOVWF  6B
0B5C:  BCF    0A.3
0B5D:  CALL   1DC
0B5E:  BSF    0A.3
....................                      printf(lcd_putc,"%lu",inputFeq); 
0B5F:  MOVLW  10
0B60:  MOVWF  04
0B61:  MOVF   38,W
0B62:  MOVWF  61
0B63:  MOVF   37,W
0B64:  MOVWF  60
0B65:  BCF    0A.3
0B66:  CALL   270
0B67:  BSF    0A.3
....................                      lcd_gotoxy(12,2); 
0B68:  MOVLW  0C
0B69:  MOVWF  6A
0B6A:  MOVLW  02
0B6B:  MOVWF  6B
0B6C:  BCF    0A.3
0B6D:  CALL   1DC
0B6E:  BSF    0A.3
....................                      lcd_putc("Hz"); 
0B6F:  MOVLW  B7
0B70:  BSF    03.6
0B71:  MOVWF  0D
0B72:  MOVLW  00
0B73:  MOVWF  0F
0B74:  BCF    0A.3
0B75:  BCF    03.6
0B76:  CALL   21A
0B77:  BSF    0A.3
....................                      fakePointer = -1; 
0B78:  MOVLW  FF
0B79:  MOVWF  39
....................                      break; 
0B7A:  GOTO   427
....................             case 15: lcd_putc('\f'); 
0B7B:  MOVLW  0C
0B7C:  MOVWF  69
0B7D:  BCF    0A.3
0B7E:  CALL   1EE
0B7F:  BSF    0A.3
....................                      lcd_gotoxy(3, 1);  
0B80:  MOVLW  03
0B81:  MOVWF  6A
0B82:  MOVLW  01
0B83:  MOVWF  6B
0B84:  BCF    0A.3
0B85:  CALL   1DC
0B86:  BSF    0A.3
....................                      lcd_putc("BT5_FEQ_SET");  
0B87:  MOVLW  B9
0B88:  BSF    03.6
0B89:  MOVWF  0D
0B8A:  MOVLW  00
0B8B:  MOVWF  0F
0B8C:  BCF    0A.3
0B8D:  BCF    03.6
0B8E:  CALL   21A
0B8F:  BSF    0A.3
....................                      lcd_gotoxy(5, 2); 
0B90:  MOVLW  05
0B91:  MOVWF  6A
0B92:  MOVLW  02
0B93:  MOVWF  6B
0B94:  BCF    0A.3
0B95:  CALL   1DC
0B96:  BSF    0A.3
....................                      printf(lcd_putc,"%lu",inputFeq); 
0B97:  MOVLW  10
0B98:  MOVWF  04
0B99:  MOVF   38,W
0B9A:  MOVWF  61
0B9B:  MOVF   37,W
0B9C:  MOVWF  60
0B9D:  BCF    0A.3
0B9E:  CALL   270
0B9F:  BSF    0A.3
....................                      lcd_gotoxy(12,2); 
0BA0:  MOVLW  0C
0BA1:  MOVWF  6A
0BA2:  MOVLW  02
0BA3:  MOVWF  6B
0BA4:  BCF    0A.3
0BA5:  CALL   1DC
0BA6:  BSF    0A.3
....................                      lcd_putc("Hz"); 
0BA7:  MOVLW  BF
0BA8:  BSF    03.6
0BA9:  MOVWF  0D
0BAA:  MOVLW  00
0BAB:  MOVWF  0F
0BAC:  BCF    0A.3
0BAD:  BCF    03.6
0BAE:  CALL   21A
0BAF:  BSF    0A.3
....................                      fakePointer = -1; 
0BB0:  MOVLW  FF
0BB1:  MOVWF  39
....................                      break; 
0BB2:  GOTO   427
....................             case 16: lcd_putc('\f'); 
0BB3:  MOVLW  0C
0BB4:  MOVWF  69
0BB5:  BCF    0A.3
0BB6:  CALL   1EE
0BB7:  BSF    0A.3
....................                      lcd_gotoxy(3, 1);  
0BB8:  MOVLW  03
0BB9:  MOVWF  6A
0BBA:  MOVLW  01
0BBB:  MOVWF  6B
0BBC:  BCF    0A.3
0BBD:  CALL   1DC
0BBE:  BSF    0A.3
....................                      lcd_putc("BT6_FEQ_SET");  
0BBF:  MOVLW  C1
0BC0:  BSF    03.6
0BC1:  MOVWF  0D
0BC2:  MOVLW  00
0BC3:  MOVWF  0F
0BC4:  BCF    0A.3
0BC5:  BCF    03.6
0BC6:  CALL   21A
0BC7:  BSF    0A.3
....................                      lcd_gotoxy(5, 2); 
0BC8:  MOVLW  05
0BC9:  MOVWF  6A
0BCA:  MOVLW  02
0BCB:  MOVWF  6B
0BCC:  BCF    0A.3
0BCD:  CALL   1DC
0BCE:  BSF    0A.3
....................                      printf(lcd_putc,"%lu",inputFeq); 
0BCF:  MOVLW  10
0BD0:  MOVWF  04
0BD1:  MOVF   38,W
0BD2:  MOVWF  61
0BD3:  MOVF   37,W
0BD4:  MOVWF  60
0BD5:  BCF    0A.3
0BD6:  CALL   270
0BD7:  BSF    0A.3
....................                      lcd_gotoxy(12,2); 
0BD8:  MOVLW  0C
0BD9:  MOVWF  6A
0BDA:  MOVLW  02
0BDB:  MOVWF  6B
0BDC:  BCF    0A.3
0BDD:  CALL   1DC
0BDE:  BSF    0A.3
....................                      lcd_putc("Hz"); 
0BDF:  MOVLW  C7
0BE0:  BSF    03.6
0BE1:  MOVWF  0D
0BE2:  MOVLW  00
0BE3:  MOVWF  0F
0BE4:  BCF    0A.3
0BE5:  BCF    03.6
0BE6:  CALL   21A
0BE7:  BSF    0A.3
....................                      fakePointer = -1; 
0BE8:  MOVLW  FF
0BE9:  MOVWF  39
....................                      break; 
0BEA:  GOTO   427
....................             case 99: lcd_putc('\f'); 
0BEB:  MOVLW  0C
0BEC:  MOVWF  69
0BED:  BCF    0A.3
0BEE:  CALL   1EE
0BEF:  BSF    0A.3
....................                      lcd_gotoxy(4, 1);  
0BF0:  MOVLW  04
0BF1:  MOVWF  6A
0BF2:  MOVLW  01
0BF3:  MOVWF  6B
0BF4:  BCF    0A.3
0BF5:  CALL   1DC
0BF6:  BSF    0A.3
....................                      lcd_putc("CURRENT_FEQ"); 
0BF7:  MOVLW  C9
0BF8:  BSF    03.6
0BF9:  MOVWF  0D
0BFA:  MOVLW  00
0BFB:  MOVWF  0F
0BFC:  BCF    0A.3
0BFD:  BCF    03.6
0BFE:  CALL   21A
0BFF:  BSF    0A.3
....................                      lcd_gotoxy(5, 2);           // Go to column 7 row 2 
0C00:  MOVLW  05
0C01:  MOVWF  6A
0C02:  MOVLW  02
0C03:  MOVWF  6B
0C04:  BCF    0A.3
0C05:  CALL   1DC
0C06:  BSF    0A.3
....................                      printf(lcd_putc,"%lu",inputFeq);   // Write num with 5 numbers max 
0C07:  MOVLW  10
0C08:  MOVWF  04
0C09:  MOVF   38,W
0C0A:  MOVWF  61
0C0B:  MOVF   37,W
0C0C:  MOVWF  60
0C0D:  BCF    0A.3
0C0E:  CALL   270
0C0F:  BSF    0A.3
....................                      lcd_gotoxy(12,2); 
0C10:  MOVLW  0C
0C11:  MOVWF  6A
0C12:  MOVLW  02
0C13:  MOVWF  6B
0C14:  BCF    0A.3
0C15:  CALL   1DC
0C16:  BSF    0A.3
....................                      lcd_putc("Hz"); 
0C17:  MOVLW  CF
0C18:  BSF    03.6
0C19:  MOVWF  0D
0C1A:  MOVLW  00
0C1B:  MOVWF  0F
0C1C:  BCF    0A.3
0C1D:  BCF    03.6
0C1E:  CALL   21A
0C1F:  BSF    0A.3
....................                      fakePointer = -1; 
0C20:  MOVLW  FF
0C21:  MOVWF  39
....................                      break; 
0C22:  GOTO   427
....................             defalut : disable_interrupts(INT_TIMER1); break; 
0C23:  BSF    03.5
0C24:  BCF    0C.0
0C25:  BCF    03.5
0C26:  GOTO   427
....................                       
....................          } 
....................       if (!input(PIN_C2)){//reset 
0C27:  BSF    35.2
0C28:  MOVF   35,W
0C29:  BSF    03.5
0C2A:  MOVWF  07
0C2B:  BCF    03.5
0C2C:  BTFSC  07.2
0C2D:  GOTO   442
....................          inputFeq = 500; 
0C2E:  MOVLW  01
0C2F:  MOVWF  38
0C30:  MOVLW  F4
0C31:  MOVWF  37
....................          lcd_putc('\f'); 
0C32:  MOVLW  0C
0C33:  MOVWF  69
0C34:  BCF    0A.3
0C35:  CALL   1EE
0C36:  BSF    0A.3
....................          fakePointer = 7; 
0C37:  MOVLW  07
0C38:  MOVWF  39
....................          printf("reset pressed\n"); 
0C39:  MOVLW  D1
0C3A:  BSF    03.6
0C3B:  MOVWF  0D
0C3C:  MOVLW  00
0C3D:  MOVWF  0F
0C3E:  BCF    0A.3
0C3F:  BCF    03.6
0C40:  CALL   2EC
0C41:  BSF    0A.3
....................           
....................       } 
....................       if (!input(PIN_B5)){//inc 
0C42:  BSF    03.5
0C43:  BSF    06.5
0C44:  BCF    03.5
0C45:  BTFSC  06.5
0C46:  GOTO   464
....................          if(inputFeq < 25000){ 
0C47:  MOVF   38,W
0C48:  SUBLW  61
0C49:  BTFSS  03.0
0C4A:  GOTO   455
0C4B:  BTFSS  03.2
0C4C:  GOTO   451
0C4D:  MOVF   37,W
0C4E:  SUBLW  A7
0C4F:  BTFSS  03.0
0C50:  GOTO   455
....................             inputFeq++; 
0C51:  INCF   37,F
0C52:  BTFSC  03.2
0C53:  INCF   38,F
....................          } 
0C54:  GOTO   459
....................          else { 
....................             inputFeq = 25000; 
0C55:  MOVLW  61
0C56:  MOVWF  38
0C57:  MOVLW  A8
0C58:  MOVWF  37
....................              
....................          } 
....................          fakePointer = 99; 
0C59:  MOVLW  63
0C5A:  MOVWF  39
....................          printf("inc pressed\n"); 
0C5B:  MOVLW  D9
0C5C:  BSF    03.6
0C5D:  MOVWF  0D
0C5E:  MOVLW  00
0C5F:  MOVWF  0F
0C60:  BCF    0A.3
0C61:  BCF    03.6
0C62:  CALL   2EC
0C63:  BSF    0A.3
....................       } 
....................       if (!input(PIN_B4)){//dec 
0C64:  BSF    03.5
0C65:  BSF    06.4
0C66:  BCF    03.5
0C67:  BTFSC  06.4
0C68:  GOTO   488
....................          if(inputFeq >500){ 
0C69:  MOVF   38,W
0C6A:  SUBLW  00
0C6B:  BTFSC  03.0
0C6C:  GOTO   479
0C6D:  XORLW  FF
0C6E:  BTFSS  03.2
0C6F:  GOTO   474
0C70:  MOVF   37,W
0C71:  SUBLW  F4
0C72:  BTFSC  03.0
0C73:  GOTO   479
....................             inputFeq--; 
0C74:  MOVF   37,W
0C75:  BTFSC  03.2
0C76:  DECF   38,F
0C77:  DECF   37,F
....................          } 
0C78:  GOTO   47D
....................          else { 
....................             inputFeq = 500; 
0C79:  MOVLW  01
0C7A:  MOVWF  38
0C7B:  MOVLW  F4
0C7C:  MOVWF  37
....................          } 
....................          fakePointer = 99; 
0C7D:  MOVLW  63
0C7E:  MOVWF  39
....................          printf("dec pressed\n"); 
0C7F:  MOVLW  E0
0C80:  BSF    03.6
0C81:  MOVWF  0D
0C82:  MOVLW  00
0C83:  MOVWF  0F
0C84:  BCF    0A.3
0C85:  BCF    03.6
0C86:  CALL   2EC
0C87:  BSF    0A.3
....................       } 
....................  
....................       if(!input(PIN_B7)){ 
0C88:  BSF    03.5
0C89:  BSF    06.7
0C8A:  BCF    03.5
0C8B:  BTFSC  06.7
0C8C:  GOTO   536
....................          switch(lastButton) 
0C8D:  MOVLW  01
0C8E:  SUBWF  36,W
0C8F:  ADDLW  FA
0C90:  BTFSC  03.0
0C91:  GOTO   536
0C92:  ADDLW  06
0C93:  GOTO   5F3
....................          { 
....................          case 1:  c_but1 = convertTimer(inputFeq); 
0C94:  MOVF   38,W
0C95:  MOVWF  5F
0C96:  MOVF   37,W
0C97:  MOVWF  5E
0C98:  BCF    0A.3
0C99:  CALL   344
0C9A:  BSF    0A.3
0C9B:  MOVF   79,W
0C9C:  MOVWF  47
0C9D:  MOVF   78,W
0C9E:  MOVWF  46
....................                   c_feq_but1 = inputFeq; 
0C9F:  MOVF   38,W
0CA0:  MOVWF  53
0CA1:  MOVF   37,W
0CA2:  MOVWF  52
....................                   fakePointer = 11; 
0CA3:  MOVLW  0B
0CA4:  MOVWF  39
....................                   printf("set pressed\n"); 
0CA5:  MOVLW  E7
0CA6:  BSF    03.6
0CA7:  MOVWF  0D
0CA8:  MOVLW  00
0CA9:  MOVWF  0F
0CAA:  BCF    0A.3
0CAB:  BCF    03.6
0CAC:  CALL   2EC
0CAD:  BSF    0A.3
....................                   break; 
0CAE:  GOTO   536
....................          case 2:  c_but2 = convertTimer(inputFeq); 
0CAF:  MOVF   38,W
0CB0:  MOVWF  5F
0CB1:  MOVF   37,W
0CB2:  MOVWF  5E
0CB3:  BCF    0A.3
0CB4:  CALL   344
0CB5:  BSF    0A.3
0CB6:  MOVF   79,W
0CB7:  MOVWF  49
0CB8:  MOVF   78,W
0CB9:  MOVWF  48
....................                   c_feq_but2 = inputFeq;  
0CBA:  MOVF   38,W
0CBB:  MOVWF  55
0CBC:  MOVF   37,W
0CBD:  MOVWF  54
....................                   fakePointer = 12;  
0CBE:  MOVLW  0C
0CBF:  MOVWF  39
....................                   printf("set pressed\n"); 
0CC0:  MOVLW  EE
0CC1:  BSF    03.6
0CC2:  MOVWF  0D
0CC3:  MOVLW  00
0CC4:  MOVWF  0F
0CC5:  BCF    0A.3
0CC6:  BCF    03.6
0CC7:  CALL   2EC
0CC8:  BSF    0A.3
....................                   break; 
0CC9:  GOTO   536
....................          case 3:  c_but1 = convertTimer(inputFeq); 
0CCA:  MOVF   38,W
0CCB:  MOVWF  5F
0CCC:  MOVF   37,W
0CCD:  MOVWF  5E
0CCE:  BCF    0A.3
0CCF:  CALL   344
0CD0:  BSF    0A.3
0CD1:  MOVF   79,W
0CD2:  MOVWF  47
0CD3:  MOVF   78,W
0CD4:  MOVWF  46
....................                   c_feq_but3 = inputFeq;  
0CD5:  MOVF   38,W
0CD6:  MOVWF  57
0CD7:  MOVF   37,W
0CD8:  MOVWF  56
....................                   fakePointer = 13;   
0CD9:  MOVLW  0D
0CDA:  MOVWF  39
....................                   printf("set pressed\n"); 
0CDB:  MOVLW  F5
0CDC:  BSF    03.6
0CDD:  MOVWF  0D
0CDE:  MOVLW  00
0CDF:  MOVWF  0F
0CE0:  BCF    0A.3
0CE1:  BCF    03.6
0CE2:  CALL   2EC
0CE3:  BSF    0A.3
....................                   break; 
0CE4:  GOTO   536
....................          case 4:  c_but1 = convertTimer(inputFeq); 
0CE5:  MOVF   38,W
0CE6:  MOVWF  5F
0CE7:  MOVF   37,W
0CE8:  MOVWF  5E
0CE9:  BCF    0A.3
0CEA:  CALL   344
0CEB:  BSF    0A.3
0CEC:  MOVF   79,W
0CED:  MOVWF  47
0CEE:  MOVF   78,W
0CEF:  MOVWF  46
....................                   c_feq_but4 = inputFeq;  
0CF0:  MOVF   38,W
0CF1:  MOVWF  59
0CF2:  MOVF   37,W
0CF3:  MOVWF  58
....................                   fakePointer = 14; 
0CF4:  MOVLW  0E
0CF5:  MOVWF  39
....................                   printf("set pressed\n"); 
0CF6:  MOVLW  FC
0CF7:  BSF    03.6
0CF8:  MOVWF  0D
0CF9:  MOVLW  00
0CFA:  MOVWF  0F
0CFB:  BCF    0A.3
0CFC:  BCF    03.6
0CFD:  CALL   2EC
0CFE:  BSF    0A.3
....................                   break; 
0CFF:  GOTO   536
....................          case 5:  c_but1 = convertTimer(inputFeq); 
0D00:  MOVF   38,W
0D01:  MOVWF  5F
0D02:  MOVF   37,W
0D03:  MOVWF  5E
0D04:  BCF    0A.3
0D05:  CALL   344
0D06:  BSF    0A.3
0D07:  MOVF   79,W
0D08:  MOVWF  47
0D09:  MOVF   78,W
0D0A:  MOVWF  46
....................                   c_feq_but5 = inputFeq;  
0D0B:  MOVF   38,W
0D0C:  MOVWF  5B
0D0D:  MOVF   37,W
0D0E:  MOVWF  5A
....................                   fakePointer = 15;   
0D0F:  MOVLW  0F
0D10:  MOVWF  39
....................                   printf("set pressed\n"); 
0D11:  MOVLW  03
0D12:  BSF    03.6
0D13:  MOVWF  0D
0D14:  MOVLW  01
0D15:  MOVWF  0F
0D16:  BCF    0A.3
0D17:  BCF    03.6
0D18:  CALL   2EC
0D19:  BSF    0A.3
....................                   break; 
0D1A:  GOTO   536
....................          case 6:  c_but1 = convertTimer(inputFeq); 
0D1B:  MOVF   38,W
0D1C:  MOVWF  5F
0D1D:  MOVF   37,W
0D1E:  MOVWF  5E
0D1F:  BCF    0A.3
0D20:  CALL   344
0D21:  BSF    0A.3
0D22:  MOVF   79,W
0D23:  MOVWF  47
0D24:  MOVF   78,W
0D25:  MOVWF  46
....................                   c_feq_but6 = inputFeq;  
0D26:  MOVF   38,W
0D27:  MOVWF  5D
0D28:  MOVF   37,W
0D29:  MOVWF  5C
....................                   fakePointer = 16; 
0D2A:  MOVLW  10
0D2B:  MOVWF  39
....................                   printf("set pressed\n"); 
0D2C:  MOVLW  0A
0D2D:  BSF    03.6
0D2E:  MOVWF  0D
0D2F:  MOVLW  01
0D30:  MOVWF  0F
0D31:  BCF    0A.3
0D32:  BCF    03.6
0D33:  CALL   2EC
0D34:  BSF    0A.3
....................                   break; 
0D35:  GOTO   536
....................          } 
....................       } 
....................        
....................       if(!input(PIN_B3)){ 
0D36:  BSF    03.5
0D37:  BSF    06.3
0D38:  BCF    03.5
0D39:  BTFSC  06.3
0D3A:  GOTO   550
....................          lastButton = 1; 
0D3B:  MOVLW  01
0D3C:  MOVWF  36
....................          START_TIME  = c_but1; 
0D3D:  MOVF   47,W
0D3E:  MOVWF  32
0D3F:  MOVF   46,W
0D40:  MOVWF  31
....................          enable_interrupts(INT_TIMER1); 
0D41:  BSF    03.5
0D42:  BSF    0C.0
....................          printf("1 pressed\n"); 
0D43:  MOVLW  11
0D44:  BCF    03.5
0D45:  BSF    03.6
0D46:  MOVWF  0D
0D47:  MOVLW  01
0D48:  MOVWF  0F
0D49:  BCF    0A.3
0D4A:  BCF    03.6
0D4B:  CALL   2EC
0D4C:  BSF    0A.3
....................          fakePointer = 1; 
0D4D:  MOVLW  01
0D4E:  MOVWF  39
....................       } 
0D4F:  GOTO   5F1
....................       else if(!input(PIN_B2)){ 
0D50:  BSF    03.5
0D51:  BSF    06.2
0D52:  BCF    03.5
0D53:  BTFSC  06.2
0D54:  GOTO   56A
....................          lastButton = 2; 
0D55:  MOVLW  02
0D56:  MOVWF  36
....................          START_TIME  = c_but2; 
0D57:  MOVF   49,W
0D58:  MOVWF  32
0D59:  MOVF   48,W
0D5A:  MOVWF  31
....................          enable_interrupts(INT_TIMER1); 
0D5B:  BSF    03.5
0D5C:  BSF    0C.0
....................          printf("2 pressed\n"); 
0D5D:  MOVLW  17
0D5E:  BCF    03.5
0D5F:  BSF    03.6
0D60:  MOVWF  0D
0D61:  MOVLW  01
0D62:  MOVWF  0F
0D63:  BCF    0A.3
0D64:  BCF    03.6
0D65:  CALL   2EC
0D66:  BSF    0A.3
....................          fakePointer = 2; 
0D67:  MOVLW  02
0D68:  MOVWF  39
....................       } 
0D69:  GOTO   5F1
....................       else if(!input(PIN_B1)){ 
0D6A:  BSF    03.5
0D6B:  BSF    06.1
0D6C:  BCF    03.5
0D6D:  BTFSC  06.1
0D6E:  GOTO   58B
....................          lastButton = 3; 
0D6F:  MOVLW  03
0D70:  MOVWF  36
....................          START_TIME  = c_but3; 
0D71:  MOVF   4B,W
0D72:  MOVWF  32
0D73:  MOVF   4A,W
0D74:  MOVWF  31
....................          enable_interrupts(INT_TIMER1); 
0D75:  BSF    03.5
0D76:  BSF    0C.0
....................          printf("3 pressed\n"); 
0D77:  MOVLW  1D
0D78:  BCF    03.5
0D79:  BSF    03.6
0D7A:  MOVWF  0D
0D7B:  MOVLW  01
0D7C:  MOVWF  0F
0D7D:  BCF    0A.3
0D7E:  BCF    03.6
0D7F:  CALL   2EC
0D80:  BSF    0A.3
....................          fakePointer = 3; 
0D81:  MOVLW  03
0D82:  MOVWF  39
....................          lcd_Show(c_feq_but3); 
0D83:  MOVF   57,W
0D84:  MOVWF  5F
0D85:  MOVF   56,W
0D86:  MOVWF  5E
0D87:  BCF    0A.3
0D88:  CALL   2D3
0D89:  BSF    0A.3
....................       } 
0D8A:  GOTO   5F1
....................       else if(!input(PIN_B0)){ 
0D8B:  BSF    03.5
0D8C:  BSF    06.0
0D8D:  BCF    03.5
0D8E:  BTFSC  06.0
0D8F:  GOTO   5AC
....................          lastButton = 4; 
0D90:  MOVLW  04
0D91:  MOVWF  36
....................          START_TIME  = c_but4; 
0D92:  MOVF   4D,W
0D93:  MOVWF  32
0D94:  MOVF   4C,W
0D95:  MOVWF  31
....................          enable_interrupts(INT_TIMER1); 
0D96:  BSF    03.5
0D97:  BSF    0C.0
....................           printf("4 pressed\n"); 
0D98:  MOVLW  23
0D99:  BCF    03.5
0D9A:  BSF    03.6
0D9B:  MOVWF  0D
0D9C:  MOVLW  01
0D9D:  MOVWF  0F
0D9E:  BCF    0A.3
0D9F:  BCF    03.6
0DA0:  CALL   2EC
0DA1:  BSF    0A.3
....................          fakePointer = 4; 
0DA2:  MOVLW  04
0DA3:  MOVWF  39
....................          lcd_Show(c_feq_but4); 
0DA4:  MOVF   59,W
0DA5:  MOVWF  5F
0DA6:  MOVF   58,W
0DA7:  MOVWF  5E
0DA8:  BCF    0A.3
0DA9:  CALL   2D3
0DAA:  BSF    0A.3
....................       } 
0DAB:  GOTO   5F1
....................       else if(!input(PIN_C5)){ 
0DAC:  BSF    35.5
0DAD:  MOVF   35,W
0DAE:  BSF    03.5
0DAF:  MOVWF  07
0DB0:  BCF    03.5
0DB1:  BTFSC  07.5
0DB2:  GOTO   5CF
....................          lastButton = 5; 
0DB3:  MOVLW  05
0DB4:  MOVWF  36
....................          START_TIME  = c_but5; 
0DB5:  MOVF   4F,W
0DB6:  MOVWF  32
0DB7:  MOVF   4E,W
0DB8:  MOVWF  31
....................          enable_interrupts(INT_TIMER1); 
0DB9:  BSF    03.5
0DBA:  BSF    0C.0
....................           printf("5 pressed\n"); 
0DBB:  MOVLW  29
0DBC:  BCF    03.5
0DBD:  BSF    03.6
0DBE:  MOVWF  0D
0DBF:  MOVLW  01
0DC0:  MOVWF  0F
0DC1:  BCF    0A.3
0DC2:  BCF    03.6
0DC3:  CALL   2EC
0DC4:  BSF    0A.3
....................          fakePointer = 5; 
0DC5:  MOVLW  05
0DC6:  MOVWF  39
....................          lcd_Show(c_feq_but5); 
0DC7:  MOVF   5B,W
0DC8:  MOVWF  5F
0DC9:  MOVF   5A,W
0DCA:  MOVWF  5E
0DCB:  BCF    0A.3
0DCC:  CALL   2D3
0DCD:  BSF    0A.3
....................       } 
0DCE:  GOTO   5F1
....................       else if(!input(PIN_C4)){ 
0DCF:  BSF    35.4
0DD0:  MOVF   35,W
0DD1:  BSF    03.5
0DD2:  MOVWF  07
0DD3:  BCF    03.5
0DD4:  BTFSC  07.4
0DD5:  GOTO   5F1
....................          lastButton = 6; 
0DD6:  MOVLW  06
0DD7:  MOVWF  36
....................          START_TIME  = c_but6; 
0DD8:  MOVF   51,W
0DD9:  MOVWF  32
0DDA:  MOVF   50,W
0DDB:  MOVWF  31
....................          enable_interrupts(INT_TIMER1); 
0DDC:  BSF    03.5
0DDD:  BSF    0C.0
....................          printf("6 pressed\n"); 
0DDE:  MOVLW  2F
0DDF:  BCF    03.5
0DE0:  BSF    03.6
0DE1:  MOVWF  0D
0DE2:  MOVLW  01
0DE3:  MOVWF  0F
0DE4:  BCF    0A.3
0DE5:  BCF    03.6
0DE6:  CALL   2EC
0DE7:  BSF    0A.3
....................          fakePointer = 6; 
0DE8:  MOVLW  06
0DE9:  MOVWF  39
....................          lcd_Show(c_feq_but6); 
0DEA:  MOVF   5D,W
0DEB:  MOVWF  5F
0DEC:  MOVF   5C,W
0DED:  MOVWF  5E
0DEE:  BCF    0A.3
0DEF:  CALL   2D3
0DF0:  BSF    0A.3
....................       } 
0DF1:  GOTO   0B0
....................        
....................    }   
.................... } 
0DF2:  SLEEP

Configuration Fuses:
   Word  1: 2FC4   INTRC_IO NOWDT PUT NOMCLR NOPROTECT NOCPD BROWNOUT IESO FCMEN NOLVP NODEBUG
   Word  2: 3FFF   BORV40 NOWRT
