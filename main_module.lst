CCS PCM C Compiler, Version 5.074, 32906               10-มี.ค.-21 23:26

               Filename:   D:\WORK\em_lab\project\main_module.lst

               ROM used:   1569 words (19%)
                           Largest free fragment is 2048
               RAM used:   155 (42%) at main() level
                           177 (48%) worst case
               Stack used: 1 locations (0 in main + 1 for interrupts)
               Stack size: 8

*
0000:  MOVLW  03
0001:  MOVWF  0A
0002:  GOTO   396
0003:  NOP
0004:  MOVWF  7F
0005:  SWAPF  03,W
0006:  CLRF   03
0007:  MOVWF  21
0008:  MOVF   0A,W
0009:  MOVWF  20
000A:  CLRF   0A
000B:  MOVF   04,W
000C:  MOVWF  22
000D:  MOVF   77,W
000E:  MOVWF  23
000F:  MOVF   78,W
0010:  MOVWF  24
0011:  MOVF   79,W
0012:  MOVWF  25
0013:  MOVF   7A,W
0014:  MOVWF  26
0015:  BSF    03.6
0016:  MOVF   0D,W
0017:  BCF    03.6
0018:  MOVWF  27
0019:  BSF    03.6
001A:  MOVF   0F,W
001B:  BCF    03.6
001C:  MOVWF  28
001D:  BSF    03.6
001E:  MOVF   0C,W
001F:  BCF    03.6
0020:  MOVWF  29
0021:  BSF    03.6
0022:  MOVF   0E,W
0023:  BCF    03.6
0024:  MOVWF  2A
0025:  BCF    03.7
0026:  BCF    03.5
0027:  MOVLW  8C
0028:  MOVWF  04
0029:  BTFSS  00.0
002A:  GOTO   02D
002B:  BTFSC  0C.0
002C:  GOTO   04E
002D:  MOVF   22,W
002E:  MOVWF  04
002F:  MOVF   23,W
0030:  MOVWF  77
0031:  MOVF   24,W
0032:  MOVWF  78
0033:  MOVF   25,W
0034:  MOVWF  79
0035:  MOVF   26,W
0036:  MOVWF  7A
0037:  MOVF   27,W
0038:  BSF    03.6
0039:  MOVWF  0D
003A:  BCF    03.6
003B:  MOVF   28,W
003C:  BSF    03.6
003D:  MOVWF  0F
003E:  BCF    03.6
003F:  MOVF   29,W
0040:  BSF    03.6
0041:  MOVWF  0C
0042:  BCF    03.6
0043:  MOVF   2A,W
0044:  BSF    03.6
0045:  MOVWF  0E
0046:  BCF    03.6
0047:  MOVF   20,W
0048:  MOVWF  0A
0049:  SWAPF  21,W
004A:  MOVWF  03
004B:  SWAPF  7F,F
004C:  SWAPF  7F,W
004D:  RETFIE
004E:  BCF    0A.3
004F:  BCF    0A.4
0050:  GOTO   051
.................... #include <16F886.h> 
.................... //////////// Standard Header file for the PIC16F886 device //////////////// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996, 2014 Custom Computer Services          //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... #device PIC16F886 
*
005F:  DATA 48,3D
0060:  DATA 00,00
0061:  DATA C3,2A
0062:  DATA D2,22
0063:  DATA 4E,2A
0064:  DATA 5F,23
0065:  DATA C5,28
0066:  DATA 00,01
0067:  DATA 48,3D
0068:  DATA 00,01
0069:  DATA 31,10
006A:  DATA 70,39
006B:  DATA E5,39
006C:  DATA F3,32
006D:  DATA 64,05
006E:  DATA 00,00
006F:  DATA 53,2A
0070:  DATA 41,29
0071:  DATA D4,2F
0072:  DATA D4,24
0073:  DATA CD,22
0074:  DATA A0,1E
0075:  DATA A0,12
0076:  DATA EC,3A
0077:  DATA 0A,00
0078:  DATA 32,10
0079:  DATA 70,39
007A:  DATA E5,39
007B:  DATA F3,32
007C:  DATA 64,05
007D:  DATA 00,01
007E:  DATA 53,2A
007F:  DATA 41,29
0080:  DATA D4,2F
0081:  DATA D4,24
0082:  DATA CD,22
0083:  DATA A0,1E
0084:  DATA A0,12
0085:  DATA EC,3A
0086:  DATA 0A,00
*
01A8:  MOVF   0B,W
01A9:  BSF    03.6
01AA:  MOVWF  10
01AB:  BCF    03.6
01AC:  BCF    0B.7
01AD:  BSF    03.5
01AE:  BSF    03.6
01AF:  BSF    0C.7
01B0:  BSF    0C.0
01B1:  NOP
01B2:  NOP
01B3:  BCF    03.5
01B4:  BTFSS  10.7
01B5:  GOTO   1B9
01B6:  BCF    03.6
01B7:  BSF    0B.7
01B8:  BSF    03.6
01B9:  MOVF   0C,W
01BA:  ANDLW  7F
01BB:  BTFSC  03.2
01BC:  GOTO   1F6
01BD:  MOVWF  10
01BE:  MOVF   0D,W
01BF:  MOVWF  11
01C0:  MOVF   0F,W
01C1:  MOVWF  12
01C2:  MOVF   10,W
01C3:  MOVWF  17
01C4:  BCF    03.6
01C5:  CALL   16E
01C6:  BSF    03.6
01C7:  MOVF   11,W
01C8:  MOVWF  0D
01C9:  MOVF   12,W
01CA:  MOVWF  0F
01CB:  BCF    03.6
01CC:  MOVF   0B,W
01CD:  BSF    03.6
01CE:  MOVWF  13
01CF:  BCF    03.6
01D0:  BCF    0B.7
01D1:  BSF    03.5
01D2:  BSF    03.6
01D3:  BSF    0C.7
01D4:  BSF    0C.0
01D5:  NOP
01D6:  NOP
01D7:  BCF    03.5
01D8:  BTFSS  13.7
01D9:  GOTO   1DD
01DA:  BCF    03.6
01DB:  BSF    0B.7
01DC:  BSF    03.6
01DD:  RLF    0C,W
01DE:  RLF    0E,W
01DF:  ANDLW  7F
01E0:  BTFSC  03.2
01E1:  GOTO   1F6
01E2:  MOVWF  10
01E3:  MOVF   0D,W
01E4:  MOVWF  11
01E5:  MOVF   0F,W
01E6:  MOVWF  12
01E7:  MOVF   10,W
01E8:  MOVWF  17
01E9:  BCF    03.6
01EA:  CALL   16E
01EB:  BSF    03.6
01EC:  MOVF   11,W
01ED:  MOVWF  0D
01EE:  MOVF   12,W
01EF:  MOVWF  0F
01F0:  INCF   0D,F
01F1:  BTFSC  03.2
01F2:  INCF   0F,F
01F3:  BCF    03.6
01F4:  GOTO   1A8
01F5:  BSF    03.6
01F6:  BCF    03.6
01F7:  RETURN
01F8:  BSF    03.6
01F9:  CLRF   16
01FA:  MOVF   04,W
01FB:  MOVWF  15
01FC:  BCF    16.0
01FD:  BTFSC  03.7
01FE:  BSF    16.0
01FF:  BSF    03.5
0200:  BCF    03.6
0201:  SWAPF  6F,W
0202:  IORLW  F0
0203:  BCF    03.5
0204:  BSF    03.6
0205:  MOVWF  11
0206:  ADDWF  11,F
0207:  ADDLW  E2
0208:  MOVWF  12
0209:  ADDLW  32
020A:  MOVWF  14
020B:  BSF    03.5
020C:  BCF    03.6
020D:  MOVF   6F,W
020E:  ANDLW  0F
020F:  BCF    03.5
0210:  BSF    03.6
0211:  ADDWF  12,F
0212:  ADDWF  12,F
0213:  ADDWF  14,F
0214:  ADDLW  E9
0215:  MOVWF  13
0216:  ADDWF  13,F
0217:  ADDWF  13,F
0218:  BSF    03.5
0219:  BCF    03.6
021A:  SWAPF  6E,W
021B:  ANDLW  0F
021C:  BCF    03.5
021D:  BSF    03.6
021E:  ADDWF  13,F
021F:  ADDWF  14,F
0220:  RLF    13,F
0221:  RLF    14,F
0222:  COMF   14,F
0223:  RLF    14,F
0224:  BSF    03.5
0225:  BCF    03.6
0226:  MOVF   6E,W
0227:  ANDLW  0F
0228:  BCF    03.5
0229:  BSF    03.6
022A:  ADDWF  14,F
022B:  RLF    11,F
022C:  MOVLW  07
022D:  MOVWF  10
022E:  MOVLW  0A
022F:  ADDWF  14,F
0230:  DECF   13,F
0231:  BTFSS  03.0
0232:  GOTO   22F
0233:  ADDWF  13,F
0234:  DECF   12,F
0235:  BTFSS  03.0
0236:  GOTO   233
0237:  ADDWF  12,F
0238:  DECF   11,F
0239:  BTFSS  03.0
023A:  GOTO   237
023B:  ADDWF  11,F
023C:  DECF   10,F
023D:  BTFSS  03.0
023E:  GOTO   23B
023F:  MOVLW  10
0240:  MOVWF  04
0241:  BSF    03.7
0242:  MOVLW  07
0243:  ANDWF  15,W
0244:  BCF    15.6
0245:  ADDWF  04,F
0246:  MOVLW  14
0247:  SUBWF  04,W
0248:  BTFSC  03.2
0249:  BSF    15.6
024A:  MOVF   00,W
024B:  MOVWF  77
024C:  BTFSS  03.2
024D:  GOTO   256
024E:  BTFSC  15.6
024F:  GOTO   256
0250:  BTFSC  15.4
0251:  GOTO   270
0252:  BTFSC  15.3
0253:  GOTO   256
0254:  MOVLW  20
0255:  GOTO   259
0256:  BSF    15.3
0257:  BCF    15.4
0258:  MOVLW  30
0259:  ADDWF  77,F
025A:  BSF    03.5
025B:  BCF    03.6
025C:  CLRF   6F
025D:  MOVF   04,W
025E:  MOVWF  6E
025F:  BCF    6F.0
0260:  BTFSC  03.7
0261:  BSF    6F.0
0262:  MOVF   77,W
0263:  BCF    03.5
0264:  BSF    03.6
0265:  MOVWF  17
0266:  BCF    03.6
0267:  CALL   16E
0268:  BSF    03.5
0269:  MOVF   6E,W
026A:  MOVWF  04
026B:  BCF    03.7
026C:  BTFSC  6F.0
026D:  BSF    03.7
026E:  BCF    03.5
026F:  BSF    03.6
0270:  INCF   04,F
0271:  BTFSS  15.6
0272:  GOTO   246
0273:  BCF    03.6
0274:  BCF    0A.3
0275:  BCF    0A.4
0276:  GOTO   4D7 (RETURN)
0277:  MOVF   0B,W
0278:  BSF    03.6
0279:  MOVWF  10
027A:  BCF    03.6
027B:  BCF    0B.7
027C:  BSF    03.5
027D:  BSF    03.6
027E:  BSF    0C.7
027F:  BSF    0C.0
0280:  NOP
0281:  NOP
0282:  BCF    03.5
0283:  BTFSS  10.7
0284:  GOTO   288
0285:  BCF    03.6
0286:  BSF    0B.7
0287:  BSF    03.6
0288:  MOVF   0C,W
0289:  ANDLW  7F
028A:  BTFSC  03.2
028B:  GOTO   2C7
028C:  MOVWF  10
028D:  MOVF   0D,W
028E:  MOVWF  11
028F:  MOVF   0F,W
0290:  MOVWF  12
0291:  MOVF   10,W
0292:  BCF    03.6
0293:  BTFSS  0C.4
0294:  GOTO   293
0295:  MOVWF  19
0296:  BSF    03.6
0297:  MOVF   11,W
0298:  MOVWF  0D
0299:  MOVF   12,W
029A:  MOVWF  0F
029B:  BCF    03.6
029C:  MOVF   0B,W
029D:  BSF    03.6
029E:  MOVWF  13
029F:  BCF    03.6
02A0:  BCF    0B.7
02A1:  BSF    03.5
02A2:  BSF    03.6
02A3:  BSF    0C.7
02A4:  BSF    0C.0
02A5:  NOP
02A6:  NOP
02A7:  BCF    03.5
02A8:  BTFSS  13.7
02A9:  GOTO   2AD
02AA:  BCF    03.6
02AB:  BSF    0B.7
02AC:  BSF    03.6
02AD:  RLF    0C,W
02AE:  RLF    0E,W
02AF:  ANDLW  7F
02B0:  BTFSC  03.2
02B1:  GOTO   2C7
02B2:  MOVWF  10
02B3:  MOVF   0D,W
02B4:  MOVWF  11
02B5:  MOVF   0F,W
02B6:  MOVWF  12
02B7:  MOVF   10,W
02B8:  BCF    03.6
02B9:  BTFSS  0C.4
02BA:  GOTO   2B9
02BB:  MOVWF  19
02BC:  BSF    03.6
02BD:  MOVF   11,W
02BE:  MOVWF  0D
02BF:  MOVF   12,W
02C0:  MOVWF  0F
02C1:  INCF   0D,F
02C2:  BTFSC  03.2
02C3:  INCF   0F,F
02C4:  BCF    03.6
02C5:  GOTO   277
02C6:  BSF    03.6
02C7:  BCF    03.6
02C8:  RETURN
02C9:  MOVF   0B,W
02CA:  BSF    03.6
02CB:  MOVWF  10
02CC:  BCF    03.6
02CD:  BCF    0B.7
02CE:  BSF    03.5
02CF:  BSF    03.6
02D0:  BSF    0C.7
02D1:  BSF    0C.0
02D2:  NOP
02D3:  NOP
02D4:  BCF    03.5
02D5:  BTFSS  10.7
02D6:  GOTO   2DA
02D7:  BCF    03.6
02D8:  BSF    0B.7
02D9:  BSF    03.6
02DA:  BTFSC  03.0
02DB:  GOTO   30A
02DC:  MOVF   0C,W
02DD:  ANDLW  7F
02DE:  MOVWF  10
02DF:  MOVF   0D,W
02E0:  MOVWF  11
02E1:  MOVF   0F,W
02E2:  MOVWF  12
02E3:  MOVF   10,W
02E4:  BCF    03.6
02E5:  BTFSS  0C.4
02E6:  GOTO   2E5
02E7:  MOVWF  19
02E8:  BSF    03.6
02E9:  MOVF   11,W
02EA:  MOVWF  0D
02EB:  MOVF   12,W
02EC:  MOVWF  0F
02ED:  BCF    03.6
02EE:  MOVF   0B,W
02EF:  BSF    03.6
02F0:  MOVWF  13
02F1:  BCF    03.6
02F2:  BCF    0B.7
02F3:  BSF    03.5
02F4:  BSF    03.6
02F5:  BSF    0C.7
02F6:  BSF    0C.0
02F7:  NOP
02F8:  NOP
02F9:  BCF    03.5
02FA:  BTFSS  13.7
02FB:  GOTO   2FF
02FC:  BCF    03.6
02FD:  BSF    0B.7
02FE:  BSF    03.6
02FF:  BSF    03.5
0300:  BCF    03.6
0301:  DECFSZ 6E,F
0302:  GOTO   304
0303:  GOTO   307
0304:  BCF    03.5
0305:  BSF    03.6
0306:  GOTO   30A
0307:  GOTO   327
0308:  BCF    03.5
0309:  BSF    03.6
030A:  RLF    0C,W
030B:  RLF    0E,W
030C:  ANDLW  7F
030D:  MOVWF  10
030E:  MOVF   0D,W
030F:  MOVWF  11
0310:  MOVF   0F,W
0311:  MOVWF  12
0312:  MOVF   10,W
0313:  BCF    03.6
0314:  BTFSS  0C.4
0315:  GOTO   314
0316:  MOVWF  19
0317:  BSF    03.6
0318:  MOVF   11,W
0319:  MOVWF  0D
031A:  MOVF   12,W
031B:  MOVWF  0F
031C:  INCF   0D,F
031D:  BTFSC  03.2
031E:  INCF   0F,F
031F:  BCF    03.0
0320:  BSF    03.5
0321:  BCF    03.6
0322:  DECFSZ 6E,F
0323:  GOTO   325
0324:  GOTO   327
0325:  BCF    03.5
0326:  GOTO   2C9
0327:  BCF    03.5
0328:  RETURN
0329:  BSF    03.6
032A:  CLRF   16
032B:  MOVF   04,W
032C:  MOVWF  15
032D:  BCF    16.0
032E:  BTFSC  03.7
032F:  BSF    16.0
0330:  BSF    03.5
0331:  BCF    03.6
0332:  SWAPF  6F,W
0333:  IORLW  F0
0334:  BCF    03.5
0335:  BSF    03.6
0336:  MOVWF  11
0337:  ADDWF  11,F
0338:  ADDLW  E2
0339:  MOVWF  12
033A:  ADDLW  32
033B:  MOVWF  14
033C:  BSF    03.5
033D:  BCF    03.6
033E:  MOVF   6F,W
033F:  ANDLW  0F
0340:  BCF    03.5
0341:  BSF    03.6
0342:  ADDWF  12,F
0343:  ADDWF  12,F
0344:  ADDWF  14,F
0345:  ADDLW  E9
0346:  MOVWF  13
0347:  ADDWF  13,F
0348:  ADDWF  13,F
0349:  BSF    03.5
034A:  BCF    03.6
034B:  SWAPF  6E,W
034C:  ANDLW  0F
034D:  BCF    03.5
034E:  BSF    03.6
034F:  ADDWF  13,F
0350:  ADDWF  14,F
0351:  RLF    13,F
0352:  RLF    14,F
0353:  COMF   14,F
0354:  RLF    14,F
0355:  BSF    03.5
0356:  BCF    03.6
0357:  MOVF   6E,W
0358:  ANDLW  0F
0359:  BCF    03.5
035A:  BSF    03.6
035B:  ADDWF  14,F
035C:  RLF    11,F
035D:  MOVLW  07
035E:  MOVWF  10
035F:  MOVLW  0A
0360:  ADDWF  14,F
0361:  DECF   13,F
0362:  BTFSS  03.0
0363:  GOTO   360
0364:  ADDWF  13,F
0365:  DECF   12,F
0366:  BTFSS  03.0
0367:  GOTO   364
0368:  ADDWF  12,F
0369:  DECF   11,F
036A:  BTFSS  03.0
036B:  GOTO   368
036C:  ADDWF  11,F
036D:  DECF   10,F
036E:  BTFSS  03.0
036F:  GOTO   36C
0370:  MOVLW  10
0371:  MOVWF  04
0372:  BSF    03.7
0373:  MOVLW  07
0374:  ANDWF  15,W
0375:  BCF    15.6
0376:  ADDWF  04,F
0377:  MOVLW  14
0378:  SUBWF  04,W
0379:  BTFSC  03.2
037A:  BSF    15.6
037B:  MOVF   00,W
037C:  MOVWF  77
037D:  BTFSS  03.2
037E:  GOTO   387
037F:  BTFSC  15.6
0380:  GOTO   387
0381:  BTFSC  15.4
0382:  GOTO   391
0383:  BTFSC  15.3
0384:  GOTO   387
0385:  MOVLW  20
0386:  GOTO   38A
0387:  BSF    15.3
0388:  BCF    15.4
0389:  MOVLW  30
038A:  ADDWF  77,F
038B:  MOVF   77,W
038C:  BCF    03.6
038D:  BTFSS  0C.4
038E:  GOTO   38D
038F:  MOVWF  19
0390:  BSF    03.6
0391:  INCF   04,F
0392:  BTFSS  15.6
0393:  GOTO   377
0394:  BCF    03.6
0395:  RETURN
*
0617:  BCF    0A.0
0618:  BSF    0A.1
0619:  BSF    0A.2
061A:  ADDWF  02,F
061B:  GOTO   536
061C:  GOTO   53C
061D:  GOTO   542
061E:  GOTO   548
061F:  GOTO   54E
0620:  GOTO   554
....................  
.................... #list 
....................  
.................... #device ADC=10 *=16 
....................  
.................... #FUSES NOWDT                    //No Watch Dog Timer 
.................... #FUSES PUT                      //Power Up Timer 
.................... #FUSES NOMCLR                   //Master Clear pin not enabled 
.................... #FUSES NOPROTECT                //Code not protected from reading 
.................... #FUSES NOCPD                    //No EE protection 
.................... #FUSES BROWNOUT                 //Brownout reset 
.................... #FUSES IESO                     //Internal External Switch Over mode enabled 
.................... #FUSES FCMEN                    //Fail-safe clock monitor enabled 
.................... #FUSES NOLVP                    //No low voltage prgming, B3(PIC16) or B5(PIC18) used for I/O 
.................... #FUSES NODEBUG                  //No Debug mode for ICD 
.................... #FUSES NOWRT                    //Program memory not write protected 
.................... #FUSES BORV40                   //Brownout reset at 4.0V 
.................... #FUSES RESERVED                 //Used to set the reserved FUSE bits 
.................... #FUSES INTRC_IO  
....................  
.................... #use delay(clock=8M) 
*
0087:  MOVLW  18
0088:  MOVWF  04
0089:  BSF    03.7
008A:  MOVF   00,W
008B:  BTFSC  03.2
008C:  GOTO   09A
008D:  MOVLW  02
008E:  MOVWF  78
008F:  CLRF   77
0090:  DECFSZ 77,F
0091:  GOTO   090
0092:  DECFSZ 78,F
0093:  GOTO   08F
0094:  MOVLW  97
0095:  MOVWF  77
0096:  DECFSZ 77,F
0097:  GOTO   096
0098:  DECFSZ 00,F
0099:  GOTO   08D
009A:  RETURN
....................  
.................... #use rs232(baud=9600,parity=N,xmit=PIN_C6,rcv=PIN_C7,bits=8) 
....................  
.................... #define RUN_BUTTON   PIN_B7 
.................... #define _FLEX_LCD216_H  //  LCD Type 16x2 
.................... //#define _FLEX_LCD416_H  //  LCD Type 16x4 
.................... // Assign MCU's pin to LCD 
.................... #define LCD_DB4   PIN_A0 
.................... #define LCD_DB5   PIN_A1 
.................... #define LCD_DB6   PIN_A2 
.................... #define LCD_DB7   PIN_A3 
.................... #define LCD_RS    PIN_C1 
.................... #define LCD_E     PIN_A5 
....................  
.................... #include <stdio.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDIO 
.................... #define _STDIO 
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) || defined(__PCM__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *memmove(void *s1,void *s2,size_t n) 
.................... { 
....................    unsigned char *sc1; 
....................    unsigned char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *strncpy(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................   unsigned char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... unsigned char *strcat(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... unsigned char *strncat(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,void *s2,size_t n) 
.................... { 
.................... unsigned char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1, returns number of chars written ot s1. 
....................    if s1 is NULL and n is 0, then it returns the length of s2.*/ 
.................... size_t strxfrm(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char c; 
....................    unsigned int8 n1; 
....................     
....................    if (!s1 && !n) 
....................       n = -1; //find length 
....................  
....................    n1 = 0; 
....................     
....................    for (; n1 < n; n1++) 
....................    { 
....................       c = *s2++; 
....................       if (!c) 
....................          break; 
....................       if (s1) 
....................          *s1++ = c; 
....................    } 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... unsigned char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    unsigned char uc; 
....................    unsigned char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... unsigned char *strchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... unsigned char *strpbrk(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... unsigned char *strrchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... unsigned char *strstr(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... size_t strlen(unsigned char *s) 
.................... { 
....................    unsigned char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... unsigned char *strtok(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *beg, *end; 
....................    static char *save; 
*
03C0:  BCF    03.6
03C1:  CLRF   2B
03C2:  CLRF   2C
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................       return(0); 
....................        
....................    end = strpbrk(beg, s2); 
....................    if (end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................       save = end; 
....................    } 
....................    else 
....................       save = beg + strlen(beg); 
....................     
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... unsigned char * strerror(unsigned int8 errnum) 
.................... { 
.................... static unsigned char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strlwr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strupr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
.................... #ifndef getc 
.................... #define getc getch 
.................... #define getchar getch 
.................... #define puts(s) {printf(s); putchar(13); putchar(10);} 
.................... #define putc putchar 
.................... #endif 
.................... /* maps error number to an error message. Writes a sequence of characters to 
.................... stderr stream thus: if s is not null then string pointed to by s follwed by 
.................... a colon (:) and a space and the appropriate error message returned by strerror 
.................... function with argument errno 
....................  
.................... Returns: no value 
.................... */ 
....................  
.................... #ifdef _ERRNO 
.................... void perror(char *s) 
.................... { 
....................   if(s) 
....................   fprintf(STDERR,"%s: ",s); 
....................   fprintf(STDERR,"%s\r\n",strerror(errno)); 
.................... } 
.................... #endif 
.................... #endif 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... #include <ctype.h> 
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *memmove(void *s1,void *s2,size_t n) 
.................... { 
....................    unsigned char *sc1; 
....................    unsigned char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *strncpy(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................   unsigned char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... unsigned char *strcat(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... unsigned char *strncat(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,void *s2,size_t n) 
.................... { 
.................... unsigned char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1, returns number of chars written ot s1. 
....................    if s1 is NULL and n is 0, then it returns the length of s2.*/ 
.................... size_t strxfrm(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char c; 
....................    unsigned int8 n1; 
....................     
....................    if (!s1 && !n) 
....................       n = -1; //find length 
....................  
....................    n1 = 0; 
....................     
....................    for (; n1 < n; n1++) 
....................    { 
....................       c = *s2++; 
....................       if (!c) 
....................          break; 
....................       if (s1) 
....................          *s1++ = c; 
....................    } 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... unsigned char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    unsigned char uc; 
....................    unsigned char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... unsigned char *strchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... unsigned char *strpbrk(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... unsigned char *strrchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... unsigned char *strstr(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... size_t strlen(unsigned char *s) 
.................... { 
....................    unsigned char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... unsigned char *strtok(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................       return(0); 
....................        
....................    end = strpbrk(beg, s2); 
....................    if (end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................       save = end; 
....................    } 
....................    else 
....................       save = beg + strlen(beg); 
....................     
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... unsigned char * strerror(unsigned int8 errnum) 
.................... { 
.................... static unsigned char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strlwr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strupr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
.................... #include <stdlib.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2007 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
....................  
.................... #ifndef _STDLIB 
.................... #define _STDLIB 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Definitions and types 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #ifndef RAND_MAX 
.................... #define RAND_MAX  32767    // The value of which is the maximum value 
....................                            // ... returned by the rand function 
.................... #endif 
....................  
....................  
.................... #IF (sizeof(int16*)>1) 
.................... #DEFINE LONG_POINTERS 1 
.................... #ELSE  
.................... #DEFINE LONG_POINTERS 0 
.................... #ENDIF 
....................  
.................... typedef struct { 
....................    signed int quot; 
....................    signed int rem; 
.................... } div_t; 
....................  
.................... typedef struct { 
....................    signed long quot; 
....................    signed long rem; 
.................... } ldiv_t; 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) || defined(__PCM__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // String conversion functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Standard template: signed int  atoi(char * s) 
....................  * converts the initial portion of the string s to a signed int 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed int atoi(char *s); 
....................  
.................... /* Syntax: signed int32  atoi32(char * s) 
....................    converts the initial portion of the string s to a signed int32 
....................    returns the converted value if any, 0 otherwise*/ 
.................... #if (sizeof(long)==4) 
....................  #define atoi32(s) atol(s) 
.................... #else  
....................  signed int32 atoi32(char *s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
.................... /* Syntax: signed int48  atoi48(char * s) 
....................    converts the initial portion of the string s to a signed int48 
....................    returns the converted value if any, 0 otherwise*/ 
....................     
.................... signed int48 atoi48(char *s); 
....................  
.................... /* Syntax: signed int64  atoi64(char * s) 
....................    converts the initial portion of the string s to a signed int64 
....................    returns the converted value if any, 0 otherwise*/ 
.................... signed int64 atoi64(char *s); 
.................... #endif 
....................  
.................... /* Syntax: char *  itoa(signed int32 num, int8 base, char * s) 
....................    converts the signed int32 to a string and 
....................    returns the converted value if any, 0 otherwise*/ 
.................... char * itoa(signed int32 num, unsigned int base, char * s); 
....................  
.................... /* Standard template: signed int16  atol(char * s) 
....................  * converts the initial portion of the string s to a signed int16 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed long atol(char *s); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base  to a signed long. 
....................  * Returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... signed long strtol(char *s,char *endptr, signed int base); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base to a unsigned long. 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... unsigned long strtoul(char *s,char *endptr, signed int base); 
....................  
.................... /* Standart template: float strtof(char * s,char *endptr) 
....................                       float48 strtof48(char *s,char *endptr); 
....................                       float64 strtod(char *s,char *endptr); 
....................  * converts the initial portion of the string s to a float32, float48 or float64, 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null                    
.................... */ 
.................... float strtof(char *s,char **endptr); 
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s,char **endptr); 
.................... float64 strtod(char *s,char **endptr); 
.................... #else 
.................... //provided for compatibility 
.................... #define strtof48(s, e) strtof(s, e) 
.................... #define strtod(s, e) strtof(s, e) 
.................... #endif 
....................  
.................... /* Standard template: float32 atof(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof(s)   strtof(s, (char*)0) 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
....................  
.................... /* Standard template: float48 atof48(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof48(s) strtof48(s, 0) 
....................  
.................... /* Standard template: float64 atof64(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof64(s) strtod(s, 0) 
.................... #endif 
....................  
.................... /* Standard template: float32 atoe(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  * also handles E format numbers 
....................  */ 
.................... #if !defined(__PCD__) 
.................... float atoe(char * s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s); 
.................... #endif 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Pseudo-random sequence generation functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The rand function computes a sequence of pseudo-random integers in 
....................  * the range 0 to RAND_MAX 
....................  * 
....................  * Parameters: 
....................  *       (none) 
....................  * 
....................  * Returns: 
....................  *       The pseudo-random integer 
....................  */ 
.................... unsigned int16 rand(void); 
....................  
.................... /* The srand function uses the argument as a seed for a new sequence of 
....................  * pseudo-random numbers to be returned by subsequent calls to rand. 
....................  * 
....................  * Parameters: 
....................  *       [in] seed: The seed value to start from. You might need to pass 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  * 
....................  * Remarks 
....................  *          The srand function sets the starting point for generating 
....................  *       a series of pseudorandom integers. To reinitialize the 
....................  *       generator, use 1 as the seed argument. Any other value for 
....................  *       seed sets the generator to a random starting point. rand 
....................  *       retrieves the pseudorandom numbers that are generated. 
....................  *       Calling rand before any call to srand generates the same 
....................  *       sequence as calling srand with seed passed as 1. 
....................  *          Usually, you need to pass a time here from outer source 
....................  *       so that the numbers will be different every time you run. 
....................  */ 
.................... void srand(unsigned int32 seed); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Memory management functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Comming soon 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Communication with the environment 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The function returns 0 always 
....................  */ 
.................... signed int8 system(char *string); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Performs a binary search of a sorted array.. 
....................  * 
....................  * Parameters: 
....................  *       [in] key: Object to search for 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       bsearch returns a pointer to an occurrence of key in the array pointed 
....................  *       to by base. If key is not found, the function returns NULL. If the 
....................  *       array is not in order or contains duplicate records with identical keys, 
....................  *       the result is unpredictable. 
....................  */ 
.................... //void *bsearch(const void *key, const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... /* Performs the shell-metzner sort (not the quick sort algorithm). The contents 
....................  * of the array are sorted into ascending order according to a comparison 
....................  * function pointed to by compar. 
....................  * 
....................  * Parameters: 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  */ 
.................... //void *qsort(const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Integer arithmetic functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #define labs abs 
....................  
.................... div_t div(signed int numer, signed int denom); 
.................... ldiv_t ldiv(signed long numer, signed long denom); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte character functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte string functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Internal implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) || defined(__PCM__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... #include <ctype.h> 
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *memmove(void *s1,void *s2,size_t n) 
.................... { 
....................    unsigned char *sc1; 
....................    unsigned char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *strncpy(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................   unsigned char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... unsigned char *strcat(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... unsigned char *strncat(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,void *s2,size_t n) 
.................... { 
.................... unsigned char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1, returns number of chars written ot s1. 
....................    if s1 is NULL and n is 0, then it returns the length of s2.*/ 
.................... size_t strxfrm(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char c; 
....................    unsigned int8 n1; 
....................     
....................    if (!s1 && !n) 
....................       n = -1; //find length 
....................  
....................    n1 = 0; 
....................     
....................    for (; n1 < n; n1++) 
....................    { 
....................       c = *s2++; 
....................       if (!c) 
....................          break; 
....................       if (s1) 
....................          *s1++ = c; 
....................    } 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... unsigned char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    unsigned char uc; 
....................    unsigned char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... unsigned char *strchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... unsigned char *strpbrk(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... unsigned char *strrchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... unsigned char *strstr(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... size_t strlen(unsigned char *s) 
.................... { 
....................    unsigned char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... unsigned char *strtok(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................       return(0); 
....................        
....................    end = strpbrk(beg, s2); 
....................    if (end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................       save = end; 
....................    } 
....................    else 
....................       save = beg + strlen(beg); 
....................     
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... unsigned char * strerror(unsigned int8 errnum) 
.................... { 
.................... static unsigned char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strlwr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strupr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
.................... div_t div(signed int numer, signed int denom) 
.................... { 
....................    div_t val; 
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... ldiv_t ldiv(signed long numer, signed long denom) 
.................... { 
....................    ldiv_t val; 
....................  
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s) 
.................... { 
....................    float32 pow10 = 1.0; 
....................    float32 result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float32 exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if !defined(__PCD__) 
.................... float atoe(char * s) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... signed int atoi(char *s) 
.................... { 
....................    signed int result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    // Omit all preceeding alpha characters 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................  
....................       // Check for hexa number 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c<='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++]; 
....................             c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (sign == 1 && base == 10) 
....................        result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed long atol(char *s) 
.................... { 
....................    signed long result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... /* A fast routine to multiply by 10 
....................  */ 
.................... signed int32 mult_with10(int32 num) 
.................... { 
....................    return ( (num << 1) + (num << 3) ); 
.................... } 
....................  
.................... #if sizeof(long)==2 
.................... signed int32 atoi32(char *s) 
.................... { 
....................    signed int32 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
....................  
.................... signed int48 atoi48(char *s) 
.................... { 
....................    signed int48 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed int64 atoi64(char *s) 
.................... { 
....................    signed int64 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... char * itoa(signed int32 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int32 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #if defined(__PCD__) 
....................  
.................... char * itoa(signed int48 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int48 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... char * itoa(signed int64 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int64 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................       
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1;         
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................              
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #endif 
....................  
.................... float strtof(char *s, char **endptr) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s, char **endptr) 
.................... { 
....................    float48 pow10 = 1.0; 
....................    float48 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float48)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float48)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... float64 strtod(char *s, char **endptr) 
.................... { 
....................    float64 pow10 = 1.0; 
....................    float64 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float64)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float64)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... unsigned long strtoul(char *s, char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    unsigned long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if(sign=='-' || base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtoulGO; 
....................  
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(; sd!=0; ) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtoulGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................          } 
....................    return 0; 
....................    } 
....................    if (endptr) 
....................    { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................          #ELSE 
....................          *((char *)endptr)=sc;  
....................          #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
....................  
.................... signed long strtol(char *s,char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    signed long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if (base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtolGO; 
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................  
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(;sd!=0;) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtolGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................       } 
....................    return 0; 
....................    } 
....................    if(sign=='-') 
....................       x  =-x; 
....................    if (endptr) 
....................    { 
....................         #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................         #ELSE 
....................         *((char *)endptr)=sc; 
....................         #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
.................... signed int8 system(char *string) 
.................... { 
....................    return 0; 
.................... } 
....................  
.................... size_t mblen(char *s,size_t n) 
.................... { 
....................    return strlen(s); 
.................... } 
....................  
.................... int8 mbtowc(wchar_t *pwc,char *s,size_t n) 
.................... { 
....................    *pwc=*s; 
....................    return 1; 
.................... } 
....................  
.................... int8 wctomb(char *s,wchar_t wchar) 
.................... { 
....................    *s=wchar; 
....................    return 1; 
.................... } 
....................  
.................... size_t mbstowcs(wchar_t *pwcs,char *s,size_t n) 
.................... { 
....................    strncpy(pwcs,s,n); 
....................    return strlen(pwcs); 
.................... } 
....................  
.................... size_t wcstombs(char *s,wchar_t *pwcs,size_t n) 
.................... { 
....................    strncpy(s,pwcs,n); 
....................    return strlen(s); 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // The random number implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... unsigned int32 _Randseed; 
....................  
.................... unsigned int16 rand(void) 
.................... { 
....................    _Randseed = _Randseed * 1103515245 + 12345; 
....................    return ((unsigned int16)(_Randseed >> 16) % RAND_MAX); 
.................... } 
....................  
.................... void srand(unsigned int32 seed) 
.................... { 
....................    _Randseed = seed; 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #if !defined(__PCD__) 
.................... typedef signed int8 (*_Cmpfun)(char * p1,char * p2);  
.................... #else  
.................... typedef signed int16 (*_Cmpfun)(char * p1,char * p2);  
.................... #endif 
....................  
....................  
....................  
.................... void qsort(char * qdata, unsigned int qitems, unsigned int qsize, _Cmpfun cmp) { 
....................    unsigned int m,j,i,l; 
....................    int1 done; 
....................    unsigned int8 t[16]; 
....................  
....................    m = qitems/2; 
....................    while( m > 0 ) { 
....................      for(j=0; j<(qitems-m); ++j) { 
....................         i = j; 
....................         do 
....................         { 
....................            done=1; 
....................            l = i+m; 
....................            if( (*cmp)(qdata+i*qsize, qdata+l*qsize) > 0 ) { 
....................               memcpy(t, qdata+i*qsize, qsize); 
....................               memcpy(qdata+i*qsize, qdata+l*qsize, qsize); 
....................               memcpy(qdata+l*qsize, t, qsize); 
....................               if(m <= i) 
....................                 i -= m; 
....................                 done = 0; 
....................            } 
....................         } while(!done); 
....................      } 
....................      m = m/2; 
....................    } 
.................... } 
....................  
....................  
.................... char *bsearch(char *key, char *base, size_t num, size_t width,_Cmpfun cmp) 
.................... { 
....................    char *p, *q; 
....................    size_t n; 
....................    size_t pivot; 
....................    signed int val; 
....................  
....................    p = base; 
....................    n = num; 
....................  
....................    while (n > 0) 
....................    { 
....................       pivot = n >> 1; 
....................       q = p + width * pivot; 
....................  
....................       val = (*cmp)(key, q); 
....................  
....................       if (val < 0) 
....................          n = pivot; 
....................       else if (val == 0) 
....................          return ((char *)q); 
....................       else { 
....................          p = q + width; 
....................          n -= pivot + 1; 
....................       } 
....................    } 
....................  
....................    return NULL;      // There's no match 
.................... } 
....................  
....................  
.................... #endif 
....................  
.................... #include <lcd.c> 
.................... /////////////////////////////////////////////////////////////////////////////// 
.................... ////                             LCD.C                                     //// 
.................... ////                 Driver for common LCD modules                         //// 
.................... ////                                                                       //// 
.................... ////  lcd_init()   Must be called before any other function.               //// 
.................... ////                                                                       //// 
.................... ////  lcd_putc(c)  Will display c on the next position of the LCD.         //// 
.................... ////                 \a  Set cursor position to upper left                 //// 
.................... ////                 \f  Clear display, set cursor to upper left           //// 
.................... ////                 \n  Go to start of second line                        //// 
.................... ////                 \b  Move back one position                            //// 
.................... ////              If LCD_EXTENDED_NEWLINE is defined, the \n character     //// 
.................... ////              will erase all remanining characters on the current      //// 
.................... ////              line, and move the cursor to the beginning of the next   //// 
.................... ////              line.                                                    //// 
.................... ////              If LCD_EXTENDED_NEWLINE is defined, the \r character     //// 
.................... ////              will move the cursor to the start of the current         //// 
.................... ////              line.                                                    //// 
.................... ////                                                                       //// 
.................... ////  lcd_gotoxy(x,y) Set write position on LCD (upper left is 1,1)        //// 
.................... ////                                                                       //// 
.................... ////  lcd_getc(x,y)   Returns character at position x,y on LCD             //// 
.................... ////                                                                       //// 
.................... ////  lcd_cursor_on(int1 on)   Turn the cursor on (on=TRUE) or off         //// 
.................... ////              (on=FALSE).                                              //// 
.................... ////                                                                       //// 
.................... ////  lcd_set_cgram_char(w, *p)   Write a custom character to the CGRAM.   //// 
.................... ////                                                                       //// 
.................... ////                                                                       //// 
.................... ////  CONFIGURATION                                                        //// 
.................... ////  The LCD can be configured in one of two ways: a.) port access or     //// 
.................... ////  b.) pin access.  Port access requires the entire 7 bit interface     //// 
.................... ////  connected to one GPIO port, and the data bits (D4:D7 of the LCD)     //// 
.................... ////  connected to sequential pins on the GPIO.  Pin access                //// 
.................... ////  has no requirements, all 7 bits of the control interface can         //// 
.................... ////  can be connected to any GPIO using several ports.                    //// 
.................... ////                                                                       //// 
.................... ////  To use port access, #define LCD_DATA_PORT to the SFR location of     //// 
.................... ////  of the GPIO port that holds the interface, -AND- edit LCD_PIN_MAP    //// 
.................... ////  of this file to configure the pin order.  If you are using a         //// 
.................... ////  baseline PIC (PCB), then LCD_OUTPUT_MAP and LCD_INPUT_MAP also must  //// 
.................... ////  be defined.                                                          //// 
.................... ////                                                                       //// 
.................... ////  Example of port access:                                              //// 
.................... ////     #define LCD_DATA_PORT getenv("SFR:PORTD")                         //// 
.................... ////                                                                       //// 
.................... ////  To use pin access, the following pins must be defined:               //// 
.................... ////     LCD_ENABLE_PIN                                                    //// 
.................... ////     LCD_RS_PIN                                                        //// 
.................... ////     LCD_RW_PIN                                                        //// 
.................... ////     LCD_DATA4                                                         //// 
.................... ////     LCD_DATA5                                                         //// 
.................... ////     LCD_DATA6                                                         //// 
.................... ////     LCD_DATA7                                                         //// 
.................... ////                                                                       //// 
.................... ////  Example of pin access:                                               //// 
.................... ////     #define LCD_ENABLE_PIN  PIN_E0                                    //// 
.................... ////     #define LCD_RS_PIN      PIN_E1                                    //// 
.................... ////     #define LCD_RW_PIN      PIN_E2                                    //// 
.................... ////     #define LCD_DATA4       PIN_D4                                    //// 
.................... ////     #define LCD_DATA5       PIN_D5                                    //// 
.................... ////     #define LCD_DATA6       PIN_D6                                    //// 
.................... ////     #define LCD_DATA7       PIN_D7                                    //// 
.................... ////                                                                       //// 
.................... /////////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2010 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef __LCD_C__ 
.................... #define __LCD_C__ 
....................  
.................... // define the pinout. 
.................... // only required if port access is being used. 
.................... typedef struct   
.................... {                            // This structure is overlayed 
....................    int1 enable;           // on to an I/O port to gain 
....................    int1 rs;               // access to the LCD pins. 
....................    int1 rw;               // The bits are allocated from 
....................    int1 unused;           // low order up.  ENABLE will 
....................    unsigned int     data : 4;         // be LSB pin of that port. 
....................   #if defined(__PCD__)       // The port used will be LCD_DATA_PORT. 
....................    unsigned int    reserved: 8; 
....................   #endif 
.................... } LCD_PIN_MAP; 
....................  
.................... // this is to improve compatability with previous LCD drivers that accepted 
.................... // a define labeled 'use_portb_lcd' that configured the LCD onto port B. 
.................... #if ((defined(use_portb_lcd)) && (use_portb_lcd==TRUE)) 
....................  #define LCD_DATA_PORT getenv("SFR:PORTB") 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
....................    // these definitions only need to be modified for baseline PICs. 
....................    // all other PICs use LCD_PIN_MAP or individual LCD_xxx pin definitions. 
.................... /*                                    EN, RS,   RW,   UNUSED,  DATA  */ 
....................  const LCD_PIN_MAP LCD_OUTPUT_MAP =  {0,  0,    0,    0,       0}; 
....................  const LCD_PIN_MAP LCD_INPUT_MAP =   {0,  0,    0,    0,       0xF}; 
.................... #endif 
....................  
.................... ////////////////////// END CONFIGURATION /////////////////////////////////// 
....................  
.................... #ifndef LCD_ENABLE_PIN 
....................    #define lcd_output_enable(x) lcdlat.enable=x 
....................    #define lcd_enable_tris()   lcdtris.enable=0 
.................... #else 
....................    #define lcd_output_enable(x) output_bit(LCD_ENABLE_PIN, x) 
....................    #define lcd_enable_tris()  output_drive(LCD_ENABLE_PIN) 
.................... #endif 
....................  
.................... #ifndef LCD_RS_PIN 
....................    #define lcd_output_rs(x) lcdlat.rs=x 
....................    #define lcd_rs_tris()   lcdtris.rs=0 
.................... #else 
....................    #define lcd_output_rs(x) output_bit(LCD_RS_PIN, x) 
....................    #define lcd_rs_tris()  output_drive(LCD_RS_PIN) 
.................... #endif 
....................  
.................... #ifndef LCD_RW_PIN 
....................    #define lcd_output_rw(x) lcdlat.rw=x 
....................    #define lcd_rw_tris()   lcdtris.rw=0 
.................... #else 
....................    #define lcd_output_rw(x) output_bit(LCD_RW_PIN, x) 
....................    #define lcd_rw_tris()  output_drive(LCD_RW_PIN) 
.................... #endif 
....................  
.................... // original version of this library incorrectly labeled LCD_DATA0 as LCD_DATA4, 
.................... // LCD_DATA1 as LCD_DATA5, and so on.  this block of code makes the driver 
.................... // compatible with any code written for the original library 
.................... #if (defined(LCD_DATA0) && defined(LCD_DATA1) && defined(LCD_DATA2) && defined(LCD_DATA3) && !defined(LCD_DATA4) && !defined(LCD_DATA5) && !defined(LCD_DATA6) && !defined(LCD_DATA7)) 
....................    #define  LCD_DATA4    LCD_DATA0 
....................    #define  LCD_DATA5    LCD_DATA1 
....................    #define  LCD_DATA6    LCD_DATA2 
....................    #define  LCD_DATA7    LCD_DATA3 
.................... #endif 
....................  
.................... #ifndef LCD_DATA4 
.................... #ifndef LCD_DATA_PORT 
....................    #if defined(__PCB__) 
....................       #define LCD_DATA_PORT      0x06     //portb 
....................       #define set_tris_lcd(x)   set_tris_b(x) 
....................    #else 
....................      #if defined(PIN_D0) 
....................       #define LCD_DATA_PORT      getenv("SFR:PORTD")     //portd 
....................      #else 
....................       #define LCD_DATA_PORT      getenv("SFR:PORTB")     //portb 
....................      #endif 
....................    #endif    
.................... #endif 
....................  
.................... #if defined(__PCB__) 
....................    LCD_PIN_MAP lcd, lcdlat; 
....................    #byte lcd = LCD_DATA_PORT 
....................    #byte lcdlat = LCD_DATA_PORT 
.................... #elif defined(__PCM__) 
....................    LCD_PIN_MAP lcd, lcdlat, lcdtris; 
....................    #byte lcd = LCD_DATA_PORT 
....................    #byte lcdlat = LCD_DATA_PORT 
....................    #byte lcdtris = LCD_DATA_PORT+0x80 
.................... #elif defined(__PCH__) 
....................    LCD_PIN_MAP lcd, lcdlat, lcdtris; 
....................    #byte lcd = LCD_DATA_PORT 
....................    #byte lcdlat = LCD_DATA_PORT+9 
....................    #byte lcdtris = LCD_DATA_PORT+0x12 
.................... #elif defined(__PCD__) 
....................    LCD_PIN_MAP lcd, lcdlat, lcdtris; 
....................    #word lcd = LCD_DATA_PORT 
....................    #word lcdlat = LCD_DATA_PORT+2 
....................    #word lcdtris = LCD_DATA_PORT-0x02 
.................... #endif 
.................... #endif   //LCD_DATA4 not defined 
....................  
.................... #ifndef LCD_TYPE 
....................    #define LCD_TYPE 2           // 0=5x7, 1=5x10, 2=2 lines 
.................... #endif 
....................  
.................... #ifndef LCD_LINE_TWO 
....................    #define LCD_LINE_TWO 0x40    // LCD RAM address for the second line 
.................... #endif 
....................  
.................... #ifndef LCD_LINE_LENGTH 
....................    #define LCD_LINE_LENGTH 20 
.................... #endif 
....................  
.................... unsigned int8 lcd_read_nibble(void); 
....................  
.................... unsigned int8 lcd_read_byte(void) 
.................... { 
....................    unsigned int8 low,high; 
....................  
....................  #if defined(__PCB__) 
....................    set_tris_lcd(LCD_INPUT_MAP); 
....................  #else 
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7)) 
....................    output_float(LCD_DATA4); 
....................    output_float(LCD_DATA5); 
....................    output_float(LCD_DATA6); 
....................    output_float(LCD_DATA7); 
....................   #else 
....................    lcdtris.data = 0xF; 
*
00B6:  MOVLW  0F
00B7:  BSF    03.5
00B8:  ANDWF  06,W
00B9:  IORLW  F0
00BA:  MOVWF  06
....................   #endif 
....................  #endif 
....................          
....................    lcd_output_rw(1); 
00BB:  BCF    03.5
00BC:  BSF    06.2
....................    delay_cycles(1); 
00BD:  NOP
....................    lcd_output_enable(1); 
00BE:  BSF    06.0
....................    delay_cycles(1); 
00BF:  NOP
....................    high = lcd_read_nibble(); 
00C0:  CALL   0AA
00C1:  MOVF   78,W
00C2:  BSF    03.6
00C3:  MOVWF  1F
....................        
....................    lcd_output_enable(0); 
00C4:  BCF    03.6
00C5:  BCF    06.0
....................    delay_cycles(1); 
00C6:  NOP
....................    lcd_output_enable(1); 
00C7:  BSF    06.0
....................    delay_us(1); 
00C8:  GOTO   0C9
....................    low = lcd_read_nibble(); 
00C9:  CALL   0AA
00CA:  MOVF   78,W
00CB:  BSF    03.6
00CC:  MOVWF  1E
....................        
....................    lcd_output_enable(0); 
00CD:  BCF    03.6
00CE:  BCF    06.0
....................  
....................  #if defined(__PCB__) 
....................    set_tris_lcd(LCD_OUTPUT_MAP); 
....................  #else 
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7)) 
....................    output_drive(LCD_DATA4); 
....................    output_drive(LCD_DATA5); 
....................    output_drive(LCD_DATA6); 
....................    output_drive(LCD_DATA7); 
....................   #else 
....................    lcdtris.data = 0x0; 
00CF:  MOVLW  0F
00D0:  BSF    03.5
00D1:  ANDWF  06,W
00D2:  MOVWF  06
....................   #endif 
....................  #endif 
....................  
....................    return( (high<<4) | low); 
00D3:  BCF    03.5
00D4:  BSF    03.6
00D5:  SWAPF  1F,W
00D6:  MOVWF  77
00D7:  MOVLW  F0
00D8:  ANDWF  77,F
00D9:  MOVF   77,W
00DA:  IORWF  1E,W
00DB:  MOVWF  78
.................... } 
....................  
.................... unsigned int8 lcd_read_nibble(void) 
.................... { 
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7)) 
....................    unsigned int8 n = 0x00; 
....................  
....................    /* Read the data port */ 
....................    n |= input(LCD_DATA4); 
....................    n |= input(LCD_DATA5) << 1; 
....................    n |= input(LCD_DATA6) << 2; 
....................    n |= input(LCD_DATA7) << 3; 
....................     
....................    return(n); 
....................   #else 
....................    return(lcd.data); 
*
00AA:  MOVF   06,W
00AB:  MOVWF  77
00AC:  SWAPF  06,W
00AD:  ANDLW  0F
00AE:  MOVWF  78
....................   #endif 
00AF:  RETURN
.................... } 
....................  
.................... void lcd_send_nibble(unsigned int8 n) 
.................... { 
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7)) 
....................    /* Write to the data port */ 
....................    output_bit(LCD_DATA4, bit_test(n, 0)); 
....................    output_bit(LCD_DATA5, bit_test(n, 1)); 
....................    output_bit(LCD_DATA6, bit_test(n, 2)); 
....................    output_bit(LCD_DATA7, bit_test(n, 3)); 
....................   #else       
....................    lcdlat.data = n; 
*
009B:  BSF    03.6
009C:  SWAPF  1F,W
009D:  ANDLW  F0
009E:  MOVWF  77
009F:  MOVLW  0F
00A0:  BCF    03.6
00A1:  ANDWF  06,W
00A2:  IORWF  77,W
00A3:  MOVWF  06
....................   #endif 
....................        
....................    delay_cycles(1); 
00A4:  NOP
....................    lcd_output_enable(1); 
00A5:  BSF    06.0
....................    delay_us(2); 
00A6:  GOTO   0A7
00A7:  GOTO   0A8
....................    lcd_output_enable(0); 
00A8:  BCF    06.0
00A9:  RETURN
.................... } 
....................  
.................... void lcd_send_byte(unsigned int8 address, unsigned int8 n) 
.................... { 
....................   #if defined(__PCB__) 
....................    set_tris_lcd(LCD_OUTPUT_MAP); 
....................   #else 
....................    lcd_enable_tris(); 
*
00B0:  BSF    03.5
00B1:  BCF    06.0
....................    lcd_rs_tris(); 
00B2:  BCF    06.1
....................    lcd_rw_tris(); 
00B3:  BCF    06.2
....................   #endif 
....................  
....................    lcd_output_rs(0); 
00B4:  BCF    03.5
00B5:  BCF    06.1
....................    while ( bit_test(lcd_read_byte(),7) ) ; 
*
00DC:  MOVF   78,W
00DD:  MOVWF  1E
00DE:  BTFSS  1E.7
00DF:  GOTO   0E2
00E0:  BCF    03.6
00E1:  GOTO   0B6
....................    lcd_output_rs(address); 
00E2:  BTFSC  1C.0
00E3:  GOTO   0E7
00E4:  BCF    03.6
00E5:  BCF    06.1
00E6:  BSF    03.6
00E7:  BTFSS  1C.0
00E8:  GOTO   0EC
00E9:  BCF    03.6
00EA:  BSF    06.1
00EB:  BSF    03.6
....................    delay_cycles(1); 
00EC:  NOP
....................    lcd_output_rw(0); 
00ED:  BCF    03.6
00EE:  BCF    06.2
....................    delay_cycles(1); 
00EF:  NOP
....................    lcd_output_enable(0); 
00F0:  BCF    06.0
....................    lcd_send_nibble(n >> 4); 
00F1:  BSF    03.6
00F2:  SWAPF  1D,W
00F3:  MOVWF  1E
00F4:  MOVLW  0F
00F5:  ANDWF  1E,F
00F6:  MOVF   1E,W
00F7:  MOVWF  1F
00F8:  BCF    03.6
00F9:  CALL   09B
....................    lcd_send_nibble(n & 0xf); 
00FA:  BSF    03.6
00FB:  MOVF   1D,W
00FC:  ANDLW  0F
00FD:  MOVWF  1E
00FE:  MOVWF  1F
00FF:  BCF    03.6
0100:  CALL   09B
0101:  RETURN
.................... } 
....................  
.................... #if defined(LCD_EXTENDED_NEWLINE) 
.................... unsigned int8 g_LcdX, g_LcdY; 
.................... #endif 
....................  
.................... void lcd_init(void)  
.................... { 
....................    unsigned int8 i; 
....................    unsigned int8 LCD_INIT_STRING[4] = {0x20 | (LCD_TYPE << 2), 0xc, 1, 6}; 
0102:  MOVLW  28
0103:  BSF    03.6
0104:  MOVWF  10
0105:  MOVLW  0C
0106:  MOVWF  11
0107:  MOVLW  01
0108:  MOVWF  12
0109:  MOVLW  06
010A:  MOVWF  13
....................                              // These bytes need to be sent to the LCD 
....................                              // to start it up. 
....................     
....................  
....................    lcd_output_enable(0); 
010B:  BCF    03.6
010C:  BCF    06.0
....................    lcd_output_rs(0); 
010D:  BCF    06.1
....................    lcd_output_rw(0); 
010E:  BCF    06.2
....................  
....................  #if defined(__PCB__) 
....................    set_tris_lcd(LCD_OUTPUT_MAP); 
....................  #else 
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7)) 
....................    output_drive(LCD_DATA4); 
....................    output_drive(LCD_DATA5); 
....................    output_drive(LCD_DATA6); 
....................    output_drive(LCD_DATA7); 
....................   #else 
....................    lcdtris.data = 0x0; 
010F:  MOVLW  0F
0110:  BSF    03.5
0111:  ANDWF  06,W
0112:  MOVWF  06
....................   #endif 
....................    lcd_enable_tris(); 
0113:  BCF    06.0
....................    lcd_rs_tris(); 
0114:  BCF    06.1
....................    lcd_rw_tris(); 
0115:  BCF    06.2
....................  #endif 
....................      
....................    delay_ms(15); 
0116:  MOVLW  0F
0117:  BCF    03.5
0118:  BSF    03.6
0119:  MOVWF  18
011A:  BCF    03.6
011B:  CALL   087
....................    for(i=1;i<=3;++i) 
011C:  MOVLW  01
011D:  BSF    03.5
011E:  MOVWF  6E
011F:  MOVF   6E,W
0120:  SUBLW  03
0121:  BTFSS  03.0
0122:  GOTO   131
....................    { 
....................        lcd_send_nibble(3); 
0123:  MOVLW  03
0124:  BCF    03.5
0125:  BSF    03.6
0126:  MOVWF  1F
0127:  BCF    03.6
0128:  CALL   09B
....................        delay_ms(5); 
0129:  MOVLW  05
012A:  BSF    03.6
012B:  MOVWF  18
012C:  BCF    03.6
012D:  CALL   087
012E:  BSF    03.5
012F:  INCF   6E,F
0130:  GOTO   11F
....................    } 
....................     
....................    lcd_send_nibble(2); 
0131:  MOVLW  02
0132:  BCF    03.5
0133:  BSF    03.6
0134:  MOVWF  1F
0135:  BCF    03.6
0136:  CALL   09B
....................    delay_ms(5); 
0137:  MOVLW  05
0138:  BSF    03.6
0139:  MOVWF  18
013A:  BCF    03.6
013B:  CALL   087
....................    for(i=0;i<=3;++i) 
013C:  BSF    03.5
013D:  CLRF   6E
013E:  MOVF   6E,W
013F:  SUBLW  03
0140:  BTFSS  03.0
0141:  GOTO   156
....................       lcd_send_byte(0,LCD_INIT_STRING[i]); 
0142:  MOVLW  10
0143:  ADDWF  6E,W
0144:  MOVWF  04
0145:  BSF    03.7
0146:  MOVF   00,W
0147:  MOVWF  6F
0148:  BCF    03.5
0149:  BSF    03.6
014A:  CLRF   1C
014B:  BSF    03.5
014C:  BCF    03.6
014D:  MOVF   6F,W
014E:  BCF    03.5
014F:  BSF    03.6
0150:  MOVWF  1D
0151:  BCF    03.6
0152:  CALL   0B0
....................  
....................   #if defined(LCD_EXTENDED_NEWLINE) 
0153:  BSF    03.5
0154:  INCF   6E,F
0155:  GOTO   13E
0156:  BCF    03.5
0157:  BCF    0A.3
0158:  BCF    0A.4
0159:  GOTO   46E (RETURN)
....................    g_LcdX = 0; 
....................    g_LcdY = 0; 
....................   #endif 
.................... } 
....................  
.................... void lcd_gotoxy(unsigned int8 x, unsigned int8 y) 
.................... { 
....................    unsigned int8 address; 
....................     
....................    if(y!=1) 
015A:  BSF    03.6
015B:  DECFSZ 19,W
015C:  GOTO   15E
015D:  GOTO   161
....................       address=LCD_LINE_TWO; 
015E:  MOVLW  40
015F:  MOVWF  1A
0160:  GOTO   162
....................    else 
....................       address=0; 
0161:  CLRF   1A
....................       
....................    address+=x-1; 
0162:  MOVLW  01
0163:  SUBWF  18,W
0164:  ADDWF  1A,F
....................    lcd_send_byte(0,0x80|address); 
0165:  MOVF   1A,W
0166:  IORLW  80
0167:  MOVWF  1B
0168:  CLRF   1C
0169:  MOVF   1B,W
016A:  MOVWF  1D
016B:  BCF    03.6
016C:  CALL   0B0
....................  
....................   #if defined(LCD_EXTENDED_NEWLINE) 
016D:  RETURN
....................    g_LcdX = x - 1; 
....................    g_LcdY = y - 1; 
....................   #endif 
.................... } 
....................  
.................... void lcd_putc(char c) 
.................... { 
....................    switch (c) 
016E:  BSF    03.6
016F:  MOVF   17,W
0170:  XORLW  07
0171:  BCF    03.6
0172:  BTFSC  03.2
0173:  GOTO   17E
0174:  XORLW  0B
0175:  BTFSC  03.2
0176:  GOTO   185
0177:  XORLW  06
0178:  BTFSC  03.2
0179:  GOTO   191
017A:  XORLW  02
017B:  BTFSC  03.2
017C:  GOTO   199
017D:  GOTO   1A0
....................    { 
....................       case '\a'   :  lcd_gotoxy(1,1);     break; 
017E:  MOVLW  01
017F:  BSF    03.6
0180:  MOVWF  18
0181:  MOVWF  19
0182:  BCF    03.6
0183:  CALL   15A
0184:  GOTO   1A7
....................  
....................       case '\f'   :  lcd_send_byte(0,1); 
0185:  BSF    03.6
0186:  CLRF   1C
0187:  MOVLW  01
0188:  MOVWF  1D
0189:  BCF    03.6
018A:  CALL   0B0
....................                      delay_ms(2); 
018B:  MOVLW  02
018C:  BSF    03.6
018D:  MOVWF  18
018E:  BCF    03.6
018F:  CALL   087
....................                     #if defined(LCD_EXTENDED_NEWLINE) 
....................                      g_LcdX = 0; 
....................                      g_LcdY = 0; 
....................                     #endif 
....................                      break; 
0190:  GOTO   1A7
....................  
....................      #if defined(LCD_EXTENDED_NEWLINE) 
....................       case '\r'   :  lcd_gotoxy(1, g_LcdY+1);   break; 
....................       case '\n'   : 
....................          while (g_LcdX++ < LCD_LINE_LENGTH) 
....................          { 
....................             lcd_send_byte(1, ' '); 
....................          } 
....................          lcd_gotoxy(1, g_LcdY+2); 
....................          break; 
....................      #else 
....................       case '\n'   : lcd_gotoxy(1,2);        break; 
0191:  MOVLW  01
0192:  BSF    03.6
0193:  MOVWF  18
0194:  MOVLW  02
0195:  MOVWF  19
0196:  BCF    03.6
0197:  CALL   15A
0198:  GOTO   1A7
....................      #endif 
....................       
....................       case '\b'   : lcd_send_byte(0,0x10);  break; 
0199:  BSF    03.6
019A:  CLRF   1C
019B:  MOVLW  10
019C:  MOVWF  1D
019D:  BCF    03.6
019E:  CALL   0B0
019F:  GOTO   1A7
....................       
....................      #if defined(LCD_EXTENDED_NEWLINE) 
....................       default     :  
....................          if (g_LcdX < LCD_LINE_LENGTH) 
....................          { 
....................             lcd_send_byte(1, c); 
....................             g_LcdX++; 
....................          } 
....................          break; 
....................      #else 
....................       default     : lcd_send_byte(1,c);     break; 
01A0:  MOVLW  01
01A1:  BSF    03.6
01A2:  MOVWF  1C
01A3:  MOVF   17,W
01A4:  MOVWF  1D
01A5:  BCF    03.6
01A6:  CALL   0B0
....................      #endif 
....................    } 
01A7:  RETURN
.................... } 
....................   
.................... char lcd_getc(unsigned int8 x, unsigned int8 y) 
.................... { 
....................    char value; 
....................  
....................    lcd_gotoxy(x,y); 
....................    while ( bit_test(lcd_read_byte(),7) ); // wait until busy flag is low 
....................    lcd_output_rs(1); 
....................    value = lcd_read_byte(); 
....................    lcd_output_rs(0); 
....................     
....................    return(value); 
.................... } 
....................  
.................... // write a custom character to the ram 
.................... // which is 0-7 and specifies which character array we are modifying. 
.................... // ptr points to an array of 8 bytes, where each byte is the next row of 
.................... //    pixels.  only bits 0-4 are used.  the last row is the cursor row, and 
.................... //    usually you will want to leave this byte 0x00. 
.................... void lcd_set_cgram_char(unsigned int8 which, unsigned int8 *ptr) 
.................... { 
....................    unsigned int i; 
....................  
....................    which <<= 3; 
....................    which &= 0x38; 
....................  
....................    lcd_send_byte(0, 0x40 | which);  //set cgram address 
....................  
....................    for(i=0; i<8; i++) 
....................    { 
....................       lcd_send_byte(1, *ptr++); 
....................    } 
....................    
....................    #if defined(LCD_EXTENDED_NEWLINE) 
....................     lcd_gotoxy(g_LcdX+1, g_LcdY+1);  //set ddram address 
....................    #endif 
.................... } 
....................  
.................... void lcd_cursor_on(int1 on) 
.................... { 
....................    if (on) 
....................    { 
....................       lcd_send_byte(0,0x0F);           //turn LCD cursor ON 
....................    } 
....................    else 
....................    { 
....................       lcd_send_byte(0,0x0C);           //turn LCD cursor OFF 
....................    } 
.................... } 
....................  
.................... #endif 
....................  
....................  
....................  
.................... int16 START_TIME = 65059; 
....................  
.................... //Happy Birthday 
.................... int16 arr[25] = { 
.................... 65059,65059,65111,65059,65179,65157,65059,65059,65111,65059,65218,65179, 
.................... 65059,65059,65306,65252,65179,65157,65111, 
.................... 65268,65268,65252,65179,65218,65179 
.................... }; 
*
03C3:  MOVLW  23
03C4:  MOVWF  33
03C5:  MOVLW  FE
03C6:  MOVWF  34
03C7:  MOVLW  23
03C8:  MOVWF  35
03C9:  MOVLW  FE
03CA:  MOVWF  36
03CB:  MOVLW  57
03CC:  MOVWF  37
03CD:  MOVLW  FE
03CE:  MOVWF  38
03CF:  MOVLW  23
03D0:  MOVWF  39
03D1:  MOVLW  FE
03D2:  MOVWF  3A
03D3:  MOVLW  9B
03D4:  MOVWF  3B
03D5:  MOVLW  FE
03D6:  MOVWF  3C
03D7:  MOVLW  85
03D8:  MOVWF  3D
03D9:  MOVLW  FE
03DA:  MOVWF  3E
03DB:  MOVLW  23
03DC:  MOVWF  3F
03DD:  MOVLW  FE
03DE:  MOVWF  40
03DF:  MOVLW  23
03E0:  MOVWF  41
03E1:  MOVLW  FE
03E2:  MOVWF  42
03E3:  MOVLW  57
03E4:  MOVWF  43
03E5:  MOVLW  FE
03E6:  MOVWF  44
03E7:  MOVLW  23
03E8:  MOVWF  45
03E9:  MOVLW  FE
03EA:  MOVWF  46
03EB:  MOVLW  C2
03EC:  MOVWF  47
03ED:  MOVLW  FE
03EE:  MOVWF  48
03EF:  MOVLW  9B
03F0:  MOVWF  49
03F1:  MOVLW  FE
03F2:  MOVWF  4A
03F3:  MOVLW  23
03F4:  MOVWF  4B
03F5:  MOVLW  FE
03F6:  MOVWF  4C
03F7:  MOVLW  23
03F8:  MOVWF  4D
03F9:  MOVLW  FE
03FA:  MOVWF  4E
03FB:  MOVLW  1A
03FC:  MOVWF  4F
03FD:  MOVLW  FF
03FE:  MOVWF  50
03FF:  MOVLW  E4
0400:  MOVWF  51
0401:  MOVLW  FE
0402:  MOVWF  52
0403:  MOVLW  9B
0404:  MOVWF  53
0405:  MOVLW  FE
0406:  MOVWF  54
0407:  MOVLW  85
0408:  MOVWF  55
0409:  MOVLW  FE
040A:  MOVWF  56
040B:  MOVLW  57
040C:  MOVWF  57
040D:  MOVLW  FE
040E:  MOVWF  58
040F:  MOVLW  F4
0410:  MOVWF  59
0411:  MOVLW  FE
0412:  MOVWF  5A
0413:  MOVLW  F4
0414:  MOVWF  5B
0415:  MOVLW  FE
0416:  MOVWF  5C
0417:  MOVLW  E4
0418:  MOVWF  5D
0419:  MOVLW  FE
041A:  MOVWF  5E
041B:  MOVLW  9B
041C:  MOVWF  5F
041D:  MOVLW  FE
041E:  MOVWF  60
041F:  MOVLW  C2
0420:  MOVWF  61
0421:  MOVLW  FE
0422:  MOVWF  62
0423:  MOVLW  9B
0424:  MOVWF  63
0425:  MOVLW  FE
0426:  MOVWF  64
.................... int16 time[25] = { 
.................... 100,80,140,120,120,140,100,80,140,120,120,140,100,80,140,140,120,120,120,100,80,140,120,120,120 
.................... }; 
0427:  MOVLW  64
0428:  BSF    03.5
0429:  MOVWF  20
042A:  CLRF   21
042B:  MOVLW  50
042C:  MOVWF  22
042D:  CLRF   23
042E:  MOVLW  8C
042F:  MOVWF  24
0430:  CLRF   25
0431:  MOVLW  78
0432:  MOVWF  26
0433:  CLRF   27
0434:  MOVWF  28
0435:  CLRF   29
0436:  MOVLW  8C
0437:  MOVWF  2A
0438:  CLRF   2B
0439:  MOVLW  64
043A:  MOVWF  2C
043B:  CLRF   2D
043C:  MOVLW  50
043D:  MOVWF  2E
043E:  CLRF   2F
043F:  MOVLW  8C
0440:  MOVWF  30
0441:  CLRF   31
0442:  MOVLW  78
0443:  MOVWF  32
0444:  CLRF   33
0445:  MOVWF  34
0446:  CLRF   35
0447:  MOVLW  8C
0448:  MOVWF  36
0449:  CLRF   37
044A:  MOVLW  64
044B:  MOVWF  38
044C:  CLRF   39
044D:  MOVLW  50
044E:  MOVWF  3A
044F:  CLRF   3B
0450:  MOVLW  8C
0451:  MOVWF  3C
0452:  CLRF   3D
0453:  MOVWF  3E
0454:  CLRF   3F
0455:  MOVLW  78
0456:  MOVWF  40
0457:  CLRF   41
0458:  MOVWF  42
0459:  CLRF   43
045A:  MOVWF  44
045B:  CLRF   45
045C:  MOVLW  64
045D:  MOVWF  46
045E:  CLRF   47
045F:  MOVLW  50
0460:  MOVWF  48
0461:  CLRF   49
0462:  MOVLW  8C
0463:  MOVWF  4A
0464:  CLRF   4B
0465:  MOVLW  78
0466:  MOVWF  4C
0467:  CLRF   4D
0468:  MOVWF  4E
0469:  CLRF   4F
046A:  MOVWF  50
046B:  CLRF   51
....................  
.................... #INT_TIMER1 
.................... void timer1_isr(){ 
....................    set_timer1(START_TIME); 
*
0051:  CLRF   0E
0052:  MOVF   32,W
0053:  MOVWF  0F
0054:  MOVF   31,W
0055:  MOVWF  0E
....................    output_toggle(PIN_B6); 
0056:  BSF    03.5
0057:  BCF    06.6
0058:  MOVLW  40
0059:  BCF    03.5
005A:  XORWF  06,F
005B:  BCF    0C.0
005C:  BCF    0A.3
005D:  BCF    0A.4
005E:  GOTO   02D
.................... } 
....................  
.................... //lcd display function 
.................... void lcd_Show(long f){ 
....................       lcd_gotoxy(5, 2);           // Go to column 5 row 2 
....................       printf(lcd_putc,"%lu",f); 
....................       lcd_gotoxy(12,2); 
....................       lcd_putc("Hz"); 
.................... } 
....................  
.................... //calculate given frequency to timer 
.................... int16 convertTimer(long f){ 
....................    return 65536 - (1000000/(4*f)); 
.................... } 
....................  
.................... void main() 
*
0396:  MOVF   03,W
0397:  ANDLW  1F
0398:  MOVWF  03
0399:  MOVLW  71
039A:  BSF    03.5
039B:  MOVWF  0F
039C:  CLRF   10
039D:  MOVF   0F,W
039E:  BSF    03.6
039F:  BCF    07.3
03A0:  MOVLW  0C
03A1:  BCF    03.6
03A2:  MOVWF  19
03A3:  MOVLW  A2
03A4:  MOVWF  18
03A5:  MOVLW  90
03A6:  BCF    03.5
03A7:  MOVWF  18
03A8:  MOVLW  FE
03A9:  MOVWF  32
03AA:  MOVLW  23
03AB:  MOVWF  31
03AC:  CLRF   66
03AD:  CLRF   65
03AE:  MOVLW  FF
03AF:  MOVWF  67
03B0:  BSF    03.5
03B1:  BSF    03.6
03B2:  MOVF   09,W
03B3:  ANDLW  C0
03B4:  MOVWF  09
03B5:  BCF    03.6
03B6:  BCF    1F.4
03B7:  BCF    1F.5
03B8:  MOVLW  00
03B9:  BSF    03.6
03BA:  MOVWF  08
03BB:  BCF    03.5
03BC:  CLRF   07
03BD:  CLRF   08
03BE:  CLRF   09
03BF:  BCF    03.7
.................... { 
....................    lcd_init(); 
*
046C:  BCF    03.5
046D:  GOTO   102
....................    //initial code for setup timer for interrupt 
....................    setup_timer_1(T1_INTERNAL | T1_DIV_BY_4); 
046E:  MOVLW  25
046F:  MOVWF  10
....................    set_timer1(START_TIME); 
0470:  CLRF   0E
0471:  MOVF   32,W
0472:  MOVWF  0F
0473:  MOVF   31,W
0474:  MOVWF  0E
....................    enable_interrupts(INT_TIMER1); 
0475:  BSF    03.5
0476:  BSF    0C.0
....................    enable_interrupts(GLOBAL); 
0477:  MOVLW  C0
0478:  BCF    03.5
0479:  IORWF  0B,F
....................    //-----------------------------------------------------// 
....................    //var decaration 
....................    int lastButton = -1; 
....................    long inputFeq = 500; 
....................    //-----------------------------------------------------// 
.................... //!   long default_feq [6] = {1043, 1175, 1319, 1399, 1565, 1764}; 
....................    int16 d_but1 = 65306; 
....................    int16 d_but2 = 65333; 
....................    int16 d_but3 = 65356; 
....................    int16 d_but4 = 65367; 
....................    int16 d_but5 = 65386; 
....................    int16 d_but6 = 65404  ; 
.................... //!   long current_feq [6]; 
....................    int16 c_but1 = d_but1; 
....................    int16 c_but2 = d_but2; 
....................    int16 c_but3 = d_but3; 
....................    int16 c_but4 = d_but4; 
....................    int16 c_but5 = d_but5; 
....................    int16 c_but6 = d_but6; 
....................    //copy arr from defalut -> current for initialize value 
.................... //!   int loop; 
.................... //!   for(loop = 0; loop < 10; loop++) { 
.................... //!      current_feq[loop] = default_feq[loop]; 
.................... //!   } 
....................    //-----------------------------------------------------// 
....................    boolean setIsPressed = input(PIN_B7); 
047A:  MOVLW  FF
047B:  BSF    03.5
047C:  MOVWF  52
047D:  MOVLW  01
047E:  MOVWF  54
047F:  MOVLW  F4
0480:  MOVWF  53
0481:  MOVLW  FF
0482:  MOVWF  56
0483:  MOVLW  1A
0484:  MOVWF  55
0485:  MOVLW  FF
0486:  MOVWF  58
0487:  MOVLW  35
0488:  MOVWF  57
0489:  MOVLW  FF
048A:  MOVWF  5A
048B:  MOVLW  4C
048C:  MOVWF  59
048D:  MOVLW  FF
048E:  MOVWF  5C
048F:  MOVLW  57
0490:  MOVWF  5B
0491:  MOVLW  FF
0492:  MOVWF  5E
0493:  MOVLW  6A
0494:  MOVWF  5D
0495:  MOVLW  FF
0496:  MOVWF  60
0497:  MOVLW  7C
0498:  MOVWF  5F
0499:  MOVF   56,W
049A:  MOVWF  62
049B:  MOVF   55,W
049C:  MOVWF  61
049D:  MOVF   58,W
049E:  MOVWF  64
049F:  MOVF   57,W
04A0:  MOVWF  63
04A1:  MOVF   5A,W
04A2:  MOVWF  66
04A3:  MOVF   59,W
04A4:  MOVWF  65
04A5:  MOVF   5C,W
04A6:  MOVWF  68
04A7:  MOVF   5B,W
04A8:  MOVWF  67
04A9:  MOVF   5E,W
04AA:  MOVWF  6A
04AB:  MOVF   5D,W
04AC:  MOVWF  69
04AD:  MOVF   60,W
04AE:  MOVWF  6C
04AF:  MOVF   5F,W
04B0:  MOVWF  6B
04B1:  BSF    06.7
04B2:  BCF    6D.0
04B3:  BCF    03.5
04B4:  BTFSS  06.7
04B5:  GOTO   4B9
04B6:  BSF    03.5
04B7:  BSF    6D.0
04B8:  BCF    03.5
....................    While(1){ 
....................       lcd_gotoxy(4, 1);           // Go to column 4 row 1 
04B9:  MOVLW  04
04BA:  BSF    03.6
04BB:  MOVWF  18
04BC:  MOVLW  01
04BD:  MOVWF  19
04BE:  BCF    03.6
04BF:  CALL   15A
....................       lcd_putc("CURENT_FEQ"); 
04C0:  MOVLW  61
04C1:  BSF    03.6
04C2:  MOVWF  0D
04C3:  MOVLW  00
04C4:  MOVWF  0F
04C5:  BCF    03.6
04C6:  CALL   1A8
....................       lcd_gotoxy(5, 2);           // Go to column 7 row 2 
04C7:  MOVLW  05
04C8:  BSF    03.6
04C9:  MOVWF  18
04CA:  MOVLW  02
04CB:  MOVWF  19
04CC:  BCF    03.6
04CD:  CALL   15A
....................       printf(lcd_putc,"%lu",inputFeq);   // Write num with 5 numbers max 
04CE:  MOVLW  10
04CF:  MOVWF  04
04D0:  BSF    03.5
04D1:  MOVF   54,W
04D2:  MOVWF  6F
04D3:  MOVF   53,W
04D4:  MOVWF  6E
04D5:  BCF    03.5
04D6:  GOTO   1F8
....................       if (!input(PIN_C2)){//reset 
04D7:  BSF    67.2
04D8:  MOVF   67,W
04D9:  BSF    03.5
04DA:  MOVWF  07
04DB:  BCF    03.5
04DC:  BTFSC  07.2
04DD:  GOTO   4E9
....................          inputFeq = 500; 
04DE:  MOVLW  01
04DF:  BSF    03.5
04E0:  MOVWF  54
04E1:  MOVLW  F4
04E2:  MOVWF  53
....................          lcd_putc('\f'); 
04E3:  MOVLW  0C
04E4:  BCF    03.5
04E5:  BSF    03.6
04E6:  MOVWF  17
04E7:  BCF    03.6
04E8:  CALL   16E
....................       } 
....................       if (!input(PIN_B5)){//inc 
04E9:  BSF    03.5
04EA:  BSF    06.5
04EB:  BCF    03.5
04EC:  BTFSC  06.5
04ED:  GOTO   502
....................          if(inputFeq < 25000){ 
04EE:  BSF    03.5
04EF:  MOVF   54,W
04F0:  SUBLW  61
04F1:  BTFSS  03.0
04F2:  GOTO   4FD
04F3:  BTFSS  03.2
04F4:  GOTO   4F9
04F5:  MOVF   53,W
04F6:  SUBLW  A7
04F7:  BTFSS  03.0
04F8:  GOTO   4FD
....................             inputFeq++; 
04F9:  INCF   53,F
04FA:  BTFSC  03.2
04FB:  INCF   54,F
....................          } 
04FC:  GOTO   501
....................          else { 
....................             inputFeq = 25000; 
04FD:  MOVLW  61
04FE:  MOVWF  54
04FF:  MOVLW  A8
0500:  MOVWF  53
0501:  BCF    03.5
....................          } 
....................       } 
....................       if (!input(PIN_B4)){//dec 
0502:  BSF    03.5
0503:  BSF    06.4
0504:  BCF    03.5
0505:  BTFSC  06.4
0506:  GOTO   51D
....................          if(inputFeq >500){ 
0507:  BSF    03.5
0508:  MOVF   54,W
0509:  SUBLW  00
050A:  BTFSC  03.0
050B:  GOTO   518
050C:  XORLW  FF
050D:  BTFSS  03.2
050E:  GOTO   513
050F:  MOVF   53,W
0510:  SUBLW  F4
0511:  BTFSC  03.0
0512:  GOTO   518
....................             inputFeq--; 
0513:  MOVF   53,W
0514:  BTFSC  03.2
0515:  DECF   54,F
0516:  DECF   53,F
....................          } 
0517:  GOTO   51C
....................          else { 
....................             inputFeq = 500; 
0518:  MOVLW  01
0519:  MOVWF  54
051A:  MOVLW  F4
051B:  MOVWF  53
051C:  BCF    03.5
....................          } 
....................       } 
....................       lcd_gotoxy(12,2); 
051D:  MOVLW  0C
051E:  BSF    03.6
051F:  MOVWF  18
0520:  MOVLW  02
0521:  MOVWF  19
0522:  BCF    03.6
0523:  CALL   15A
....................       lcd_putc("Hz"); 
0524:  MOVLW  67
0525:  BSF    03.6
0526:  MOVWF  0D
0527:  MOVLW  00
0528:  MOVWF  0F
0529:  BCF    03.6
052A:  CALL   1A8
....................       if(setIsPressed){ 
052B:  BSF    03.5
052C:  BTFSS  6D.0
052D:  GOTO   55B
....................          switch(lastButton) 
052E:  MOVLW  01
052F:  SUBWF  52,W
0530:  ADDLW  FA
0531:  BTFSC  03.0
0532:  GOTO   55B
0533:  ADDLW  06
0534:  BCF    03.5
0535:  GOTO   617
....................          { 
....................          case 1: c_but1 = inputFeq; break; 
0536:  BSF    03.5
0537:  MOVF   54,W
0538:  MOVWF  62
0539:  MOVF   53,W
053A:  MOVWF  61
053B:  GOTO   55B
....................          case 2: c_but2 = inputFeq; break; 
053C:  BSF    03.5
053D:  MOVF   54,W
053E:  MOVWF  64
053F:  MOVF   53,W
0540:  MOVWF  63
0541:  GOTO   55B
....................          case 3: c_but3 = inputFeq; break; 
0542:  BSF    03.5
0543:  MOVF   54,W
0544:  MOVWF  66
0545:  MOVF   53,W
0546:  MOVWF  65
0547:  GOTO   55B
....................          case 4: c_but4 = inputFeq; break; 
0548:  BSF    03.5
0549:  MOVF   54,W
054A:  MOVWF  68
054B:  MOVF   53,W
054C:  MOVWF  67
054D:  GOTO   55B
....................          case 5: c_but5 = inputFeq; break; 
054E:  BSF    03.5
054F:  MOVF   54,W
0550:  MOVWF  6A
0551:  MOVF   53,W
0552:  MOVWF  69
0553:  GOTO   55B
....................          case 6: c_but6 = inputFeq; break; 
0554:  BSF    03.5
0555:  MOVF   54,W
0556:  MOVWF  6C
0557:  MOVF   53,W
0558:  MOVWF  6B
0559:  GOTO   55B
055A:  BSF    03.5
....................          } 
.................... //!         current_feq[lastButton-1] = inputFeq; 
....................       } 
....................       if(!input(PIN_B3)){ 
055B:  BSF    06.3
055C:  BCF    03.5
055D:  BTFSC  06.3
055E:  GOTO   591
....................          lastButton = 1; 
055F:  MOVLW  01
0560:  BSF    03.5
0561:  MOVWF  52
....................          printf("1 pressed\n"); 
0562:  MOVLW  69
0563:  BCF    03.5
0564:  BSF    03.6
0565:  MOVWF  0D
0566:  MOVLW  00
0567:  MOVWF  0F
0568:  BCF    03.6
0569:  CALL   277
....................          START_TIME  = c_but1; 
056A:  BSF    03.5
056B:  MOVF   62,W
056C:  BCF    03.5
056D:  MOVWF  32
056E:  BSF    03.5
056F:  MOVF   61,W
0570:  BCF    03.5
0571:  MOVWF  31
.................... //!         START_TIME  = convertTimer(current_feq[1-1]); 
....................          enable_interrupts(INT_TIMER1); 
0572:  BSF    03.5
0573:  BSF    0C.0
....................          printf("START_TIME = %lu\n",START_TIME); 
0574:  MOVLW  6F
0575:  BCF    03.5
0576:  BSF    03.6
0577:  MOVWF  0D
0578:  MOVLW  00
0579:  MOVWF  0F
057A:  BCF    03.0
057B:  MOVLW  0D
057C:  BSF    03.5
057D:  BCF    03.6
057E:  MOVWF  6E
057F:  BCF    03.5
0580:  CALL   2C9
0581:  MOVLW  10
0582:  MOVWF  04
0583:  MOVF   32,W
0584:  BSF    03.5
0585:  MOVWF  6F
0586:  BCF    03.5
0587:  MOVF   31,W
0588:  BSF    03.5
0589:  MOVWF  6E
058A:  BCF    03.5
058B:  CALL   329
058C:  MOVLW  0A
058D:  BTFSS  0C.4
058E:  GOTO   58D
058F:  MOVWF  19
....................       } 
0590:  GOTO   615
....................       else if(!input(PIN_B2)){ 
0591:  BSF    03.5
0592:  BSF    06.2
0593:  BCF    03.5
0594:  BTFSC  06.2
0595:  GOTO   5C6
....................          lastButton = 2; 
0596:  MOVLW  02
0597:  BSF    03.5
0598:  MOVWF  52
....................          START_TIME  = c_but2; 
0599:  MOVF   64,W
059A:  BCF    03.5
059B:  MOVWF  32
059C:  BSF    03.5
059D:  MOVF   63,W
059E:  BCF    03.5
059F:  MOVWF  31
.................... //!         START_TIME  = convertTimer(current_feq[2-1]); 
....................          enable_interrupts(INT_TIMER1); 
05A0:  BSF    03.5
05A1:  BSF    0C.0
....................          printf("2 pressed\n"); 
05A2:  MOVLW  78
05A3:  BCF    03.5
05A4:  BSF    03.6
05A5:  MOVWF  0D
05A6:  MOVLW  00
05A7:  MOVWF  0F
05A8:  BCF    03.6
05A9:  CALL   277
....................          printf("START_TIME = %lu\n",START_TIME); 
05AA:  MOVLW  7E
05AB:  BSF    03.6
05AC:  MOVWF  0D
05AD:  MOVLW  00
05AE:  MOVWF  0F
05AF:  BCF    03.0
05B0:  MOVLW  0D
05B1:  BSF    03.5
05B2:  BCF    03.6
05B3:  MOVWF  6E
05B4:  BCF    03.5
05B5:  CALL   2C9
05B6:  MOVLW  10
05B7:  MOVWF  04
05B8:  MOVF   32,W
05B9:  BSF    03.5
05BA:  MOVWF  6F
05BB:  BCF    03.5
05BC:  MOVF   31,W
05BD:  BSF    03.5
05BE:  MOVWF  6E
05BF:  BCF    03.5
05C0:  CALL   329
05C1:  MOVLW  0A
05C2:  BTFSS  0C.4
05C3:  GOTO   5C2
05C4:  MOVWF  19
....................       } 
05C5:  GOTO   615
....................       else if(input(PIN_B1)){ 
05C6:  BSF    03.5
05C7:  BSF    06.1
05C8:  BCF    03.5
05C9:  BTFSS  06.1
05CA:  GOTO   5D9
....................          lastButton = 3; 
05CB:  MOVLW  03
05CC:  BSF    03.5
05CD:  MOVWF  52
....................          START_TIME  = c_but3; 
05CE:  MOVF   66,W
05CF:  BCF    03.5
05D0:  MOVWF  32
05D1:  BSF    03.5
05D2:  MOVF   65,W
05D3:  BCF    03.5
05D4:  MOVWF  31
....................          enable_interrupts(INT_TIMER1); 
05D5:  BSF    03.5
05D6:  BSF    0C.0
....................       } 
05D7:  GOTO   614
05D8:  BCF    03.5
....................       else if(input(PIN_B0)){ 
05D9:  BSF    03.5
05DA:  BSF    06.0
05DB:  BCF    03.5
05DC:  BTFSS  06.0
05DD:  GOTO   5EC
....................          lastButton = 4; 
05DE:  MOVLW  04
05DF:  BSF    03.5
05E0:  MOVWF  52
....................          START_TIME  = c_but4; 
05E1:  MOVF   68,W
05E2:  BCF    03.5
05E3:  MOVWF  32
05E4:  BSF    03.5
05E5:  MOVF   67,W
05E6:  BCF    03.5
05E7:  MOVWF  31
....................          enable_interrupts(INT_TIMER1); 
05E8:  BSF    03.5
05E9:  BSF    0C.0
....................       } 
05EA:  GOTO   614
05EB:  BCF    03.5
....................       else if(input(PIN_C5)){ 
05EC:  BSF    67.5
05ED:  MOVF   67,W
05EE:  BSF    03.5
05EF:  MOVWF  07
05F0:  BCF    03.5
05F1:  BTFSS  07.5
05F2:  GOTO   601
....................          lastButton = 5; 
05F3:  MOVLW  05
05F4:  BSF    03.5
05F5:  MOVWF  52
....................          START_TIME  = c_but5; 
05F6:  MOVF   6A,W
05F7:  BCF    03.5
05F8:  MOVWF  32
05F9:  BSF    03.5
05FA:  MOVF   69,W
05FB:  BCF    03.5
05FC:  MOVWF  31
....................          enable_interrupts(INT_TIMER1); 
05FD:  BSF    03.5
05FE:  BSF    0C.0
....................       } 
05FF:  GOTO   614
0600:  BCF    03.5
....................       else if(input(PIN_C4)){ 
0601:  BSF    67.4
0602:  MOVF   67,W
0603:  BSF    03.5
0604:  MOVWF  07
0605:  BCF    03.5
0606:  BTFSS  07.4
0607:  GOTO   615
....................          lastButton = 6; 
0608:  MOVLW  06
0609:  BSF    03.5
060A:  MOVWF  52
....................          START_TIME  = c_but6; 
060B:  MOVF   6C,W
060C:  BCF    03.5
060D:  MOVWF  32
060E:  BSF    03.5
060F:  MOVF   6B,W
0610:  BCF    03.5
0611:  MOVWF  31
....................          enable_interrupts(INT_TIMER1); 
0612:  BSF    03.5
0613:  BSF    0C.0
0614:  BCF    03.5
....................       } 
0615:  GOTO   4B9
....................        
....................    }   
.................... } 
....................  
0616:  SLEEP

Configuration Fuses:
   Word  1: 2FC4   INTRC_IO NOWDT PUT NOMCLR NOPROTECT NOCPD BROWNOUT IESO FCMEN NOLVP NODEBUG
   Word  2: 3FFF   BORV40 NOWRT
